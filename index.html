<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#667eea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GF">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Gerenciador Financeiro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 800px;
            margin-top: 5px;
            margin-bottom: 18px;
            margin-left: -1px;   /* ‚Üê AJUSTE AQUI: borda ESQUERDA do Conteiner Geral*/
            margin-right: -4px;   /* ‚Üê AJUSTE AQUI: borda DIREITA do Conteiner Geral*/
            background: white;
            border-radius: 20px;
            padding: 27px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 8px;
            font-size: 22px;
            font-weight: bold;
        }

        .mes-atual {
            color: #333;
            margin-bottom: 12px;
            font-size: 17px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 5px 10px;  /* ‚Üê AJUSTAR altura e largura do bot√£o ‚ûï Adicionar Conta */
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            margin-bottom: 12px;
            font-weight: bold;  /* ‚Üê ADICIONE ESTA LINHA para deixar em negrito */
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .conta {
            background: #ffffff;
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
            position: relative;
            border: 1px solid #c0c0c0;  /* ‚Üê AJUSTAR o contraste da borda dos Conteiners*/
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }

        .conta.pago {
            opacity: 0.7;
            background: #f1f8f4;
            border-color: #c3e6cb;
            border-left: 4px solid #28a745;
        }

        .conta.recebimento {
            background: #ffffff;
            border-color: #c3e6cb;
            border-left: 4px solid #28a745;
        }

        .conta-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .conta-nome {
            font-size: 15px;
            font-weight: bold;
            color: #333;
        }

        .conta-valor {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
        }

        .conta.pago .conta-valor {
            color: #28a745;
        }

        .conta.recebimento .conta-valor {
            color: #28a745;
        }

        .pessoa {
            padding: 6px 0;
            color: #555;
            border-bottom: 1px dashed #ddd;
            font-size: 13px;
        }

        .pessoa:last-child {
            border-bottom: none;
        }

        .pessoa.pago {
            text-decoration: line-through;
            color: #999;
        }

        .info-conta {
            margin-top: 8px;
            color: #666;
            font-size: 12px;
        }

        .limite {
            color: #28a745;
            font-weight: bold;
        }

        .acoes {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }

        .btn-pequeno {
            padding: 4px 3px;
            font-size: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-editar {
            background: #ffc107;
            color: #333;
        }

        .btn-editar:hover {
            background: #e0a800;
        }

        .btn-excluir {
            background: #dc3545;
            color: white;
        }

        .btn-excluir:hover {
            background: #c82333;
        }

        .btn-pagar {
            background: #28a745;
            color: white;
        }

        .btn-pagar:hover {
            background: #218838;
        }

        .total {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 12px;
            text-align: center;
        }

        .total h2 {
            font-size: 13px;
            margin-bottom: 4px;
        }

        .total-valor {
            font-size: 20px;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.ativo {
            display: flex;
        }

        .modal-conteudo {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .form-grupo {
            margin-bottom: 14px;
        }

        .form-grupo label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
            font-size: 13px;
        }

        .form-grupo input, .form-grupo select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            transition: border 0.3s;
        }

        .form-grupo input:focus, .form-grupo select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .form-grupo textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-grupo textarea {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            transition: border 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .pessoas-lista {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-top: 8px;
            border: 1px solid #e0e0e0;
        }

        .pessoa-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 13px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .btn-remover {
            background: #dc3545;
            color: white;
            border: none;
            padding: 3px 7px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .btn-editar-pessoa {
            background: #ffc107;
            color: #333;
            border: none;
            padding: 3px 7px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-right: 4px;
        }

        .btn-adicionar-pessoa {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            margin-top: 8px;
            font-size: 12px;
        }

        .form-acoes {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .form-acoes button {
            flex: 1;
        }

        .btn-cancelar {
            background: #6c757d;
            color: white;
        }

        .btn-cancelar:hover {
            background: #5a6268;
        }

        .status-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
        }

        .badge-pago {
            background: #28a745;
            color: white;
        }

        .badge-pendente {
            background: #ffc107;
            color: #333;
        }
        .btn-backup {
            position: fixed;
            top: 23px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #E6EE9C 60%);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 7px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            z-index: 1000;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-backup:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .menu-backup {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 999;
            min-width: 180px;
        }

        .menu-backup.ativo {
            display: flex;
        }

        .menu-backup-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-backup-btn-salvar {
            background: #28a745;
            color: white;
        }

        .menu-backup-btn-salvar:hover {
            background: #218838;
        }

        .menu-backup-btn-carregar {
            background: #ffc107;
            color: #333;
        }

        .menu-backup-btn-carregar:hover {
            background: #e0a800;
        }

        .input-file-hidden {
            display: none;
        }
        .modal-menu {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-menu.ativo {
            display: flex;
        }

        .modal-menu-conteudo {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-menu-titulo {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .menu-opcoes {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .menu-btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .menu-btn-adicionar {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .menu-btn-adicionar:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .menu-btn-editar {
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            color: #333;
        }

        .menu-btn-editar:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
        }

        .menu-btn-cancelar {
            background: #6c757d;
            color: white;
        }

        .menu-btn-cancelar:hover {
            background: #5a6268;
        }

        .lista-compras {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
        }

        .compra-item {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }

        .compra-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .compra-nome {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }

        .compra-valor {
            font-weight: bold;
            color: #667eea;
            font-size: 15px;
        }

        .compra-info {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .compra-acoes {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }
        .modal-form {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .modal-form.ativo {
            display: flex;
        }

        .modal-form-conteudo {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 450px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-form-titulo {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .form-grupo-modal {
            margin-bottom: 16px;
        }

        .form-grupo-modal label {
            display: block;
            margin-bottom: 6px;
            color: #333;
            font-weight: 600;
            font-size: 13px;
        }

        .form-grupo-modal input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border 0.3s;
        }

        .form-grupo-modal input:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-acoes-modal {
            display: flex;
            gap: 10px;
            margin-top: 24px;
        }

        .form-acoes-modal button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-salvar-modal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-salvar-modal:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-cancelar-modal {
            background: #6c757d;
            color: white;
        }

        .btn-cancelar-modal:hover {
            background: #5a6268;
        }
        .modal-pendencias {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .modal-pendencias.ativo {
            display: flex;
        }

        .modal-pendencias-conteudo {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-pendencias-titulo {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .modal-pendencias-subtitulo {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            text-align: center;
        }

        .pendencia-mes {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 16px;
        }

        .pendencia-mes-titulo {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .pendencia-pessoa {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid #dc3545;
        }

        .pendencia-pessoa-nome {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .pendencia-compra {
            padding: 8px 0 8px 16px;
            border-left: 2px solid #e0e0e0;
            margin-left: 8px;
        }

        .pendencia-compra-nome {
            font-size: 13px;
            color: #555;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .pendencia-compra-valor {
            font-size: 15px;
            font-weight: bold;
            color: #dc3545;
        }

        .pendencia-compra-info {
            font-size: 11px;
            color: #999;
            margin-top: 2px;
        }

        .pendencia-total {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            padding: 16px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
        }

        .pendencia-total-titulo {
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .pendencia-total-valor {
            font-size: 24px;
            font-weight: bold;
        }

        .modal-pendencias-fechar {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin-top: 16px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .modal-pendencias-fechar:hover {
            background: #5a6268;
        }
        .modal-detalhes {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .modal-detalhes.ativo {
            display: flex;
        }

        .modal-detalhes-conteudo {
            background: white;
            border-radius: 16px;
            padding: 20px;
            max-width: 420px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-detalhes-header {
            margin-bottom: 20px;
        }

        .modal-detalhes-titulo {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-detalhes-subtitulo {
            font-size: 14px;
            color: #666;
        }

        .modal-detalhes-resumo {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .modal-detalhes-resumo-label {
            font-size: 11px;
            opacity: 0.9;
            margin-bottom: 4px;
        }

        .modal-detalhes-resumo-valor {
            font-size: 22px;
            font-weight: bold;
        }

        .modal-detalhes-secao {
            margin-bottom: 16px;
        }

        .modal-detalhes-secao-titulo {
            font-size: 15px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .detalhes-compra-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
            border-left: 4px solid #667eea;
            transition: all 0.3s;
        }

        .detalhes-compra-card:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .detalhes-compra-card.recebimento {
            border-left-color: #28a745;
        }

        .detalhes-compra-nome {
            font-size: 15px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .detalhes-compra-badge {
            background: #667eea;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .detalhes-compra-badge.recebimento {
            background: #28a745;
        }

        .detalhes-compra-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .detalhes-compra-info-item {
            font-size: 12px;
            color: #666;
        }

        .detalhes-compra-info-label {
            font-weight: 600;
            color: #555;
        }

        .detalhes-compra-info-valor {
            color: #667eea;
            font-weight: bold;
        }

        .detalhes-compra-info-valor.recebimento {
            color: #28a745;
        }

        .modal-detalhes-total {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-top: 16px;
            text-align: center;
        }

        .modal-detalhes-total.recebimento {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .modal-detalhes-total-label {
            font-size: 11px;
            opacity: 0.9;
            margin-bottom: 4px;
        }

        .modal-detalhes-total-valor {
            font-size: 20px;
            font-weight: bold;
        }

        .modal-detalhes-fechar {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin-top: 12px;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .modal-detalhes-fechar:hover {
            background: #5a6268;
        }
        .modal-valor {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .modal-valor.ativo {
            display: flex;
        }

        .modal-valor-conteudo {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 550px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-valor-header {
            margin-bottom: 20px;
        }

        .modal-valor-titulo {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-valor-subtitulo {
            font-size: 14px;
            color: #666;
        }

        .modal-valor-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 16px;
            border-left: 4px solid #667eea;
        }

        .modal-valor-card.recebimento {
            border-left-color: #28a745;
        }

        .modal-valor-card-label {
            font-size: 13px;
            color: #666;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .modal-valor-card-valor {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
        }

        .modal-valor-card-valor.recebimento {
            color: #28a745;
        }

        .modal-valor-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px;
            border-radius: 10px;
            margin-bottom: 16px;
        }

        .modal-valor-info.recebimento {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .modal-valor-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .modal-valor-info-row:last-child {
            border-bottom: none;
        }

        .modal-valor-info-label {
            font-size: 13px;
            opacity: 0.9;
        }

        .modal-valor-info-valor {
            font-size: 16px;
            font-weight: bold;
        }

        .modal-valor-destaque {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 14px;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .modal-valor-destaque.alerta {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .modal-valor-destaque-texto {
            font-size: 14px;
            color: #1976D2;
            line-height: 1.6;
        }

        .modal-valor-destaque.alerta .modal-valor-destaque-texto {
            color: #856404;
        }

        .modal-valor-fechar {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin-top: 16px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .modal-valor-fechar:hover {
            background: #5a6268;
        }
        .modal-resumo {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .modal-resumo.ativo {
            display: flex;
        }

        .modal-resumo-conteudo {
            background: white;
            border-radius: 16px;
            padding: 20px;          /* ‚Üê ESPA√áAMENTO INTERNO (espa√ßo entre borda e conte√∫do) */
            max-width: 420px;       /* ‚Üê LARGURA M√ÅXIMA do container */
            width: 90%;             /* ‚Üê largura em % (adapta em telas pequenas) */
            max-height: 90vh;       /* ‚Üê ALTURA M√ÅXIMA (80% da altura da tela) */
            overflow-y: auto;       /* ‚Üê permite rolar se passar da altura */
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-resumo-titulo {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 16px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .resumo-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .resumo-card.recebimentos {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        .resumo-card.saldo-positivo {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        .resumo-card.saldo-negativo {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        }

        .resumo-card-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .resumo-card-valor {
            font-size: 24px;
            font-weight: bold;
        }

        .resumo-divisor {
            border: none;
            border-top: 2px dashed #e0e0e0;
            margin: 20px 0;
        }

        .resumo-saldo {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 14px;
            margin-top: 16px;
        }

        .resumo-saldo-header {
            text-align: center;
            margin-bottom: 12px;
        }

        .resumo-saldo-label {
            font-size: 13px;
            color: #666;
            margin-bottom: 6px;
        }

        .resumo-saldo-valor {
            font-size: 28px;
            font-weight: bold;
        }

        .resumo-saldo-valor.positivo {
            color: #28a745;
        }

        .resumo-saldo-valor.negativo {
            color: #dc3545;
        }

        .resumo-saldo-badge {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
            margin-top: 8px;
        }

        .resumo-saldo-badge.positivo {
            background: #d4edda;
            color: #155724;
        }

        .resumo-saldo-badge.negativo {
            background: #f8d7da;
            color: #721c24;
        }

        .resumo-detalhes {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #e0e0e0;
        }

        .resumo-detalhes-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 14px;
        }

        .resumo-detalhes-label {
            color: #666;
        }

        .resumo-detalhes-valor {
            font-weight: bold;
            color: #333;
        }

        .resumo-icone-grande {
            font-size: 36px;
            text-align: center;
            margin: 12px 0;
        }

        .modal-resumo-fechar {
            position: fixed;
            bottom: 80px;           /* ‚Üê ALTURA (dist√¢ncia da parte inferior) */
            right: 35px;            /* ‚Üê dist√¢ncia da direita */
            background: #6c757d;  /* ‚Üê COR DE FUNDO do bot√£o X */
            color: white;           /* ‚Üê COR DO X (branco) */
            border: none;
            padding: 0;             /* ‚Üê PADDING (espa√ßamento interno) */
            border-radius: 6px;     /* ‚Üê arredondamento das bordas */
            cursor: pointer;
            width: 40px;            /* ‚Üê LARGURA do bot√£o */
            height: 40px;           /* ‚Üê ALTURA do bot√£o */
            font-size: 18px;        /* ‚Üê tamanho do X */
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
            z-index: 3001;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.85;          /* ‚Üê TRANSPAR√äNCIA (0 = invis√≠vel, 1 = opaco) */
        }

        .modal-resumo-fechar:hover {
            background: #c82333;
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
        }

        .resumo-info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 12px;
            border-radius: 6px;
            margin-top: 16px;
            font-size: 13px;
            color: #1976D2;
        }

        .pendencia-sem-resultado {
            text-align: center;
            padding: 40px 20px;
            color: #28a745;
        }

        .pendencia-sem-resultado-icone {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .pendencia-sem-resultado-texto {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .pendencia-sem-resultado-sub {
            font-size: 14px;
            color: #666;
        }
        
        .modal-limpar {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .modal-limpar.ativo {
            display: flex;
        }

        .modal-limpar-conteudo {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            min-height: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-limpar-titulo {
            font-size: 20px;
            font-weight: bold;
            color: #dc3545;
            margin-bottom: 16px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .modal-limpar-texto {
            font-size: 14px;
            color: #333;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-limpar-aviso {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #856404;
        }

        .modal-limpar-acoes {
            display: flex;
            gap: 10px;
        }

        .modal-limpar-acoes button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-limpar-confirmar {
            background: #dc3545;
            color: white;
        }

        .btn-limpar-confirmar:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn-limpar-cancelar {
            background: #6c757d;
            color: white;
        }

        .btn-limpar-cancelar:hover {
            background: #5a6268;
        }
        
        .parceria-container {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        
        .parceria-titulo {
            font-size: 13px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .parceria-pessoa {
            display: grid;
            grid-template-columns: 1fr 100px 40px;
            gap: 8px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .parceria-pessoa input {
            padding: 6px 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 12px;
            min-width: 0;
        }
        
        .parceria-pessoa input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn-remover-parceria {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 3px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            width: 28px;  /* ‚Üê Largura fixa */
            min-width: 20px;
        }
        
        .btn-remover-parceria:hover {
            background: #c82333;
        }
        
        .btn-adicionar-parceria {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            width: 100%;
            margin-top: 10px;
        }
        
        .btn-adicionar-parceria:hover {
            background: #218838;
        }
        
        .parceria-aviso {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 10px;
            border-radius: 6px;
            margin-top: 12px;
            font-size: 12px;
            color: #1976D2;
        }
        
        .parceria-modal-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 12px;
            border-left: 4px solid #667eea;
        }
        
        .parceria-modal-item.pago {
            background: #d4edda;
            border-left-color: #28a745;
            opacity: 0.8;
        }
        
        .parceria-modal-nome {
            font-size: 15px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .parceria-modal-valor {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }
        
        .parceria-modal-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .parceria-modal-status.pago {
            background: #28a745;
            color: white;
        }
        
        .parceria-modal-status.pendente {
            background: #ffc107;
            color: #333;
        }
        
        .btn-marcar-pessoa {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 8px;
        }
        
        .btn-marcar-pessoa.pagar {
            background: #28a745;
            color: white;
        }
        
        .btn-marcar-pessoa.pagar:hover {
            background: #218838;
        }
        
        .btn-marcar-pessoa.desfazer {
            background: #6c757d;
            color: white;
        }
        
        .btn-marcar-pessoa.desfazer:hover {
            background: #5a6268;
        }
        
        .conta-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;  /* ‚Üê AJUSTAR espa√ßo/espa√ßamento entre as setas e o conteiner ao lado */
            margin-bottom: 2px;  /* ‚Üê AJUSTAR espa√ßo/espa√ßamento entre os conteiners */
            margin-left: -22px;  /* ‚Üê AJUSTAR espa√ßo/espa√ßamento entre as setas e a borda esquerda */
        }
        
        .conta-setas {
            display: flex;
            flex-direction: column;
            gap: 40px;  /* ‚Üê AJUSTAR espa√ßo/espa√ßamento entre a seta de cima e a seta debaixo dos conteiners */
            margin-left: 0;
            justify-content: center;
            align-items: center;
            margin-top: -10px;  /* ‚Üê AJUSTE este valor para subir/descer as setas (valores negativos sobem) */
        }
        
        .btn-seta {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            width: 13px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 1px 4px rgba(102, 126, 234, 0.3);
            padding: 0;
        }
        
        .btn-seta:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }
        
        .btn-seta:active {
            transform: scale(1);
        }
        
        .btn-seta:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }
        
        .conta-conteudo {
            flex: 1;
            margin-right: -12px;  /* ‚Üê AJUSTAR o espa√ßo da borda DIREITA dos Conteiners*/
        }
        
    </style>
</head>
<body>
    <div class="container">
    <button class="btn-backup" onclick="toggleMenuBackup()" title="Backup">üíæ</button>
        <div class="menu-backup" id="menuBackup">
            <button class="menu-backup-btn menu-backup-btn-salvar" onclick="salvarBackup()">
                üíæ Salvar Backup
            </button>
            <button class="menu-backup-btn menu-backup-btn-carregar" onclick="document.getElementById('inputCarregarBackup').click()">
                üìÇ Carregar Backup
            </button>
            <input type="file" id="inputCarregarBackup" class="input-file-hidden" accept=".json" onchange="carregarBackup(event)">
        </div>
        <h1 id="tituloGastos" ontouchstart="iniciarLongPressLimpar(event)" ontouchend="cancelarLongPressLimpar()" ontouchmove="cancelarLongPressLimpar()" onmousedown="iniciarLongPressLimpar(event)" onmouseup="cancelarLongPressLimpar()" onmouseleave="cancelarLongPressLimpar()" style="cursor: pointer; user-select: none;" title="Mantenha pressionado para limpar dados">üí∞ Gastos do M√™s</h1>
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; gap: 8px;">
            <button class="btn" onclick="voltarMes()" style="padding: 4px 8px; font-size: 11px; margin-bottom: 0; min-width: 50px;">‚óÄ Ante</button>
            <p class="mes-atual" id="mesAtual" style="margin: 0; text-align: center; flex: 1;"></p>
            <button class="btn" onclick="avancarMes()" style="padding: 4px 8px; font-size: 11px; margin-bottom: 0; min-width: 50px;">Prox ‚ñ∂</button>
        </div>
        
        <button class="btn" onclick="abrirModal()">‚ûï Adicionar Conta</button>
        
        <div id="listaContas"></div>
        
        <div class="total" style="cursor: pointer;" onclick="mostrarDetalhesTotal()" title="Clique para ver detalhes">
            <h2>Total Gastos:</h2>
            <div class="total-valor" id="totalValor">R$ 0,00</div>
        </div>
    </div>

    <div class="modal" id="modal">
        <div class="modal-conteudo">
            <h2 id="modalTitulo">Adicionar Conta</h2>
            <form id="formConta" onsubmit="salvarConta(event)">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="form-grupo" style="grid-column: 1 / -1;">
                        <label>Nome da Conta:</label>
                        <input type="text" id="nomeConta" required>
                    </div>

                    <div class="form-grupo">
                        <label>Tipo de Transa√ß√£o:</label>
                        <select id="tipoTransacao" onchange="atualizarFormulario()">
                            <option value="pagamento">Pagamento</option>
                            <option value="pagamento-custom">Pagamento (custom)</option>
                            <option value="recebimento">Recebimento</option>
                        </select>
                    </div>

                    <div class="form-grupo">
                        <label>Tipo:</label>
                        <select id="tipoConta" onchange="atualizarFormulario()">
                            <option value="cartao">Cart√£o de Cr√©dito</option>
                            <option value="boleto">Boleto/Conta</option>
                            <option value="dinheiro">Dinheiro</option>
                            <option value="pix">PIX</option>
                            <option value="outro">Outro</option>
                        </select>
                    </div>
                </div>

                <div id="camposCartao">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                        <div class="form-grupo">
                            <label>Limite Total:</label>
                            <input type="number" id="limiteTotal" step="0.01">
                        </div>

                        <div class="form-grupo">
                            <label>Dia Fecha:</label>
                            <input type="number" id="diaFechamento" min="1" max="31">
                        </div>

                        <div class="form-grupo">
                            <label>Dia Venc:</label>
                            <input type="number" id="diaVencimento" min="1" max="31">
                        </div>
                    </div>
                </div>

                <div class="form-grupo">
                    <label>Nome da Compra/Descri√ß√£o:</label>
                    <input type="text" id="nomeCompra" placeholder="Ex: Fone de ouvido, Conta de luz...">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="form-grupo">
                        <label id="labelMeuValor">Meu Valor (opcional):</label>
                        <input type="number" id="meuValor" step="0.01" placeholder="0.00 (opcional)">
                    </div>

                    <div class="form-grupo">
                        <label>Parcelas:</label>
                        <input type="number" id="numeroParcelas" min="1" placeholder="1 ou vazio">
                    </div>
                </div>

                <div class="form-grupo">
                    <div class="checkbox-group">
                        <input type="checkbox" id="compraEmAndamento" onchange="toggleParcelasEmAndamento()">
                        <label for="compraEmAndamento" style="font-size: 12px;">Compra em andamento</label>
                    </div>
                </div>

                <div class="form-grupo" id="grupoParcelasNormal" style="display: none;">
                    <!-- Grupo vazio, apenas para compatibilidade com a fun√ß√£o toggle -->
                </div>

                <div class="form-grupo" id="grupoParcelasAndamento" style="display: none;">
                    <label>J√° pagas:</label>
                    <input type="number" id="parcelasJaPagas" min="0" placeholder="0">
                </div>

                <div class="form-grupo">
                    <div class="checkbox-group">
                        <input type="checkbox" id="contaRecorrente" onchange="toggleContaRecorrente()">
                        <label for="contaRecorrente" style="font-size: 12px;">Conta recorrente (√°gua, luz, plano...)</label>
                    </div>
                </div>
<div class="form-grupo" id="grupoObservacoes">
                    <label>Observa√ß√µes:</label>
                    <textarea id="observacoes" placeholder="Ex: Pagamento quinzenal, PIX, etc...&#10;Pressione Enter para nova linha" rows="3" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 13px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; resize: vertical; transition: border 0.3s;"></textarea>
                </div>
                <div class="form-grupo">
                    <label>Outras Pessoas/Parcelas:</label>
                    <div class="pessoas-lista" id="pessoasLista"></div>
                    <button type="button" class="btn-adicionar-pessoa" onclick="adicionarPessoa()">+ Adicionar Pessoa/Parcela</button>
                </div>

                <div class="form-grupo">
                    <div class="checkbox-group">
                        <input type="checkbox" id="contaPaga">
                        <label for="contaPaga">Marcar como pago</label>
                    </div>
                </div>

                <div class="form-acoes">
                    <button type="button" class="btn btn-cancelar" onclick="fecharModal()">Cancelar</button>
                    <button type="submit" class="btn">Salvar</button>
                </div>
            </form>
        </div>
    </div>
    <div class="modal-form" id="modalForm">
        <div class="modal-form-conteudo">
            <h3 class="modal-form-titulo" id="modalFormTitulo"></h3>
            <div id="modalFormConteudo"></div>
        </div>
    </div>
    <div class="modal-valor" id="modalValor">
        <div class="modal-valor-conteudo">
            <div class="modal-valor-header">
                <h3 class="modal-valor-titulo" id="modalValorTitulo"></h3>
                <p class="modal-valor-subtitulo" id="modalValorSubtitulo"></p>
            </div>
            <div id="modalValorConteudo"></div>
            <button class="modal-valor-fechar" onclick="fecharModalValor()">‚úï Fechar</button>
        </div>
    </div>
    <div class="modal-resumo" id="modalResumo">
        <div class="modal-resumo-conteudo">
            <h3 class="modal-resumo-titulo">üìä Resumo Financeiro do M√™s</h3>
            <div id="modalResumoConteudo"></div>
            <button class="modal-resumo-fechar" onclick="fecharModalResumo()">‚úï</button>
        </div>
    </div>
    <div class="modal-detalhes" id="modalDetalhes">
        <div class="modal-detalhes-conteudo">
            <div class="modal-detalhes-header">
                <h3 class="modal-detalhes-titulo" id="modalDetalhesTitulo"></h3>
                <p class="modal-detalhes-subtitulo" id="modalDetalhesSubtitulo"></p>
            </div>
            <div id="modalDetalhesConteudo"></div>
            <button class="modal-detalhes-fechar" onclick="fecharModalDetalhes()">‚úï Fechar</button>
        </div>
    </div>
    <div class="modal-pendencias" id="modalPendencias">
        <div class="modal-pendencias-conteudo">
            <h3 class="modal-pendencias-titulo" id="modalPendenciasTitulo"></h3>
            <p class="modal-pendencias-subtitulo" id="modalPendenciasSubtitulo"></p>
            <div id="modalPendenciasConteudo"></div>
            <button class="modal-pendencias-fechar" onclick="fecharModalPendencias()">‚úï Fechar</button>
        </div>
    </div>
    <!-- PAINEL DE DEBUG -->
    <div id="painelDebug" style="position: fixed; top: 80px; left: 10px; width: 350px; max-height: 450px; background: white; border: 3px solid #667eea; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.4); z-index: 5000; display: none; flex-direction: column;">
        <div id="debugHeader" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 10px 10px 0 0; display: flex; justify-content: space-between; align-items: center; cursor: move; user-select: none;">
            <span style="font-weight: bold; font-size: 14px;">üêõ LOG DE DEBUG</span>
            <button onclick="fecharDebug()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">‚úï</button>
        </div>
        <div id="debugConteudo" style="padding: 12px; overflow-y: auto; max-height: 350px; font-family: 'Courier New', monospace; font-size: 11px; background: #f8f9fa;">
            <p style="color: #999; text-align: center; padding: 20px;">Nenhum log registrado ainda...</p>
        </div>
        <div style="padding: 10px; border-top: 2px solid #e0e0e0; display: flex; gap: 8px;">
            <button onclick="copiarLog()" style="flex: 1; background: #28a745; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">üìã Copiar Log</button>
            <button onclick="limparLog()" style="flex: 1; background: #dc3545; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">üóëÔ∏è Limpar</button>
        </div>
    </div>

    <!-- BOT√ÉO FLUTUANTE DE DEBUG -->
    <button id="btnDebug" onclick="toggleDebug()" style="position: fixed; top: 23px; left: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 14px; border-radius: 50px; cursor: pointer; font-size: 13px; font-weight: bold; box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5); z-index: 4999; transition: all 0.3s; display: none;">
        üêõ DEBUG
    </button>
    <div class="modal-detalhes" id="modalResumoDetalhado">
        <div class="modal-detalhes-conteudo">
            <div class="modal-detalhes-header">
                <h3 class="modal-detalhes-titulo" id="modalResumoDetalhadoTitulo"></h3>
                <p class="modal-detalhes-subtitulo" id="modalResumoDetalhadoSubtitulo"></p>
            </div>
            <div id="modalResumoDetalhadoConteudo"></div>
            <button class="modal-resumo-fechar" onclick="fecharModalResumoDetalhado()">‚úï</button>
        </div>
    </div>
    
    <!-- MODAL PARA MARCAR COMPRA EM PARCERIA -->
    <div class="modal-menu" id="modalMarcarParceria">
        <div class="modal-menu-conteudo" style="max-width: 450px;">
            <h3 class="modal-menu-titulo" id="modalMarcarParceriaTitulo">üë• Compra em Parceria</h3>
            <div id="modalMarcarParceriaConteudo"></div>
        </div>
    </div>
    
    <div class="modal-limpar" id="modalLimpar">
        <div class="modal-limpar-conteudo">
            <h3 class="modal-limpar-titulo">‚ö†Ô∏è LIMPAR DADOS</h3>
            <p class="modal-limpar-texto">
                Voc√™ est√° prestes a <strong>APAGAR TODOS OS DADOS</strong> do Gestor Financeiro.
            </p>
            <div class="modal-limpar-aviso">
                <strong>‚ö†Ô∏è ESCOLHA O TIPO DE LIMPEZA:</strong>
            </div>
            <div style="margin-bottom: 16px;">
                <button class="btn-limpar-confirmar" onclick="limparApenasCache()" style="width: 100%; margin-bottom: 10px; background: #ffc107; color: #333;">
                    üßπ Limpar Apenas Cache/Configura√ß√µes
                </button>
                <p style="font-size: 11px; color: #666; margin: -6px 0 16px 0; text-align: center;">
                    Remove apenas cache e configura√ß√µes antigas.<br>
                    <strong>Mant√©m todos os dados financeiros</strong>
                </p>
                
                <button class="btn-limpar-confirmar" onclick="confirmarLimpezaTotal()" style="width: 100%;">
                    üóëÔ∏è Limpar TUDO (Dados + Cache)
                </button>
                <p style="font-size: 11px; color: #dc3545; margin: 10px 0 0 0; text-align: center;">
                    <strong>‚ö†Ô∏è Apaga TODOS os dados!</strong> N√£o pode ser desfeito.
                </p>
            </div>
            <div class="modal-limpar-acoes">
                <button class="btn-limpar-cancelar" onclick="fecharModalLimpar()" style="width: 100%;">‚úï Cancelar</button>
            </div>
        </div>
    </div>
<div class="modal-menu" id="modalMenu">
        <div class="modal-menu-conteudo">
            <h3 class="modal-menu-titulo" id="modalMenuTitulo"></h3>
            <div id="modalMenuConteudo"></div>
        </div>
    </div>
    <!-- PAINEL DE DEBUG -->
    <div id="painelDebug" style="position: fixed; top: 80px; left: 10px; width: 350px; max-height: 450px; background: white; border: 3px solid #667eea; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.4); z-index: 5000; display: none; flex-direction: column;">
        <div id="debugHeader" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 10px 10px 0 0; display: flex; justify-content: space-between; align-items: center; cursor: move; user-select: none;">
            <span style="font-weight: bold; font-size: 14px;">üêõ LOG DE DEBUG</span>
            <button onclick="fecharDebug()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">‚úï</button>
        </div>
        <div id="debugConteudo" style="padding: 12px; overflow-y: auto; max-height: 350px; font-family: 'Courier New', monospace; font-size: 11px; background: #f8f9fa;">
            <p style="color: #999; text-align: center; padding: 20px;">Nenhum log registrado ainda...</p>
        </div>
        <div style="padding: 10px; border-top: 2px solid #e0e0e0; display: flex; gap: 8px;">
            <button onclick="copiarLog()" style="flex: 1; background: #28a745; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">üìã Copiar Log</button>
            <button onclick="limparLog()" style="flex: 1; background: #dc3545; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">üóëÔ∏è Limpar</button>
        </div>
    </div>

    <!-- BOT√ÉO FLUTUANTE DE DEBUG -->
    <button id="btnDebug" onclick="toggleDebug()" style="position: fixed; top: 23px; left: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 14px; border-radius: 50px; cursor: pointer; font-size: 13px; font-weight: bold; box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5); z-index: 4999; transition: all 0.3s; display: none;">
        üêõ DEBUG
    </button>
    <script>
        let contas = [];
        let contaEditando = null;
        let pessoasTemp = [];
        const VERSAO_ATUAL = '2.0'; // Aumente este n√∫mero quando fizer altera√ß√µes importantes
        const MOSTRAR_DEBUG = false; // ‚Üê MUDE PARA true PARA ATIVAR O BOT√ÉO üêõ DEBUG, false PARA DESATIVAR
        let longPressTimer = null;
        let debugLogs = [];
        let debugAtivo = false;
        let longPressTimerLimpar = null;
        let mesAtual = new Date();
        let todasContas = {}; // Armazena contas de todos os meses
        let historicoLimitePago = {}; // Armazena valores j√° pagos por cart√£o
        let dataUltimaAtualizacao = null;
        
        function toggleParcelasEmAndamento() {
            const checkbox = document.getElementById('compraEmAndamento');
            const grupoAndamento = document.getElementById('grupoParcelasAndamento');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }

        
        function toggleContaRecorrente() {
            const checkbox = document.getElementById('contaRecorrente');
            const camposParcelas = document.getElementById('numeroParcelas');
            const checkboxAndamento = document.getElementById('compraEmAndamento');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamento();
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
            }
        }
        function toggleParcelasEmAndamentoForm() {
            const checkbox = document.getElementById('compraEmAndamentoForm');
            const grupoAndamento = document.getElementById('grupoParcelasAndamentoForm');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }

        function toggleContaRecorrenteForm() {
            const checkbox = document.getElementById('contaRecorrenteForm');
            const camposParcelas = document.getElementById('numParcelasForm');
            const checkboxAndamento = document.getElementById('compraEmAndamentoForm');
            const grupoPagamentoVariavel = document.getElementById('grupoPagamentoVariavelForm');
            const checkboxPagamentoVariavel = document.getElementById('pagamentoVariavelForm');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamentoForm();
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'block';
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'none';
                if (checkboxPagamentoVariavel) checkboxPagamentoVariavel.checked = false;
            }
        }
        function toggleParcelasEmAndamentoAddForm() {
            const checkbox = document.getElementById('compraEmAndamentoAddForm');
            const grupoAndamento = document.getElementById('grupoParcelasAndamentoAddForm');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }

        function toggleContaRecorrenteAddForm() {
            const checkbox = document.getElementById('contaRecorrenteAddForm');
            const camposParcelas = document.getElementById('numParcelasAddForm');
            const checkboxAndamento = document.getElementById('compraEmAndamentoAddForm');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamentoAddForm();
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
            }
        }
        
        function toggleParcelasEmAndamentoEditTemp() {
            const checkbox = document.getElementById('compraEmAndamentoEditTemp');
            const grupoAndamento = document.getElementById('grupoParcelasAndamentoEditTemp');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }
        
        function toggleContaRecorrenteEditTemp() {
            const checkbox = document.getElementById('contaRecorrenteEditTemp');
            const camposParcelas = document.getElementById('numParcelasEditTemp');
            const checkboxAndamento = document.getElementById('compraEmAndamentoEditTemp');
            const grupoPagamentoVariavel = document.getElementById('grupoPagamentoVariavelEditTemp');
            const checkboxPagamentoVariavel = document.getElementById('pagamentoVariavelEditTemp');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamentoEditTemp();
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'block';
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'none';
                if (checkboxPagamentoVariavel) checkboxPagamentoVariavel.checked = false;
            }
        }
        
        function toggleParcelasEmAndamentoEditCompraForm() {
            const checkbox = document.getElementById('compraEmAndamentoEditCompraForm');
            const grupoAndamento = document.getElementById('grupoParcelasAndamentoEditCompraForm');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }
        
        function toggleContaRecorrenteEditCompraForm() {
            const checkbox = document.getElementById('contaRecorrenteEditCompraForm');
            const camposParcelas = document.getElementById('numParcelasEditForm');
            const checkboxAndamento = document.getElementById('compraEmAndamentoEditCompraForm');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamentoEditCompraForm();
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
            }
        }

function voltarMes() {
            adicionarLog(`‚¨ÖÔ∏è VOLTANDO M√äS`, 'importante');
            
            // Salvar estado atual antes de voltar
            const chaveAtual = getChaveMes();
            adicionarLog(`   Salvando m√™s atual: ${chaveAtual}`, 'info');
            
            if (contas.length > 0) {
                todasContas[chaveAtual] = JSON.parse(JSON.stringify(contas));
                localStorage.setItem('todasContas', JSON.stringify(todasContas));
                adicionarLog(`   ‚úÖ ${contas.length} contas salvas`, 'success');
            }
            
            mesAtual.setMonth(mesAtual.getMonth() - 1);
            const novaMesChave = getChaveMes();
            adicionarLog(`   Novo m√™s: ${novaMesChave}`, 'info');
            
            // Salvar o novo m√™s atual
            localStorage.setItem('mesAtualSalvo', JSON.stringify({
                ano: mesAtual.getFullYear(),
                mes: mesAtual.getMonth()
            }));
            
            // FOR√áAR recarga completa do localStorage
            const dadosAtualizados = localStorage.getItem('todasContas');
            if (dadosAtualizados) {
                todasContas = JSON.parse(dadosAtualizados);
                adicionarLog(`   üì• Dados recarregados do localStorage`, 'info');
            }
            
            atualizarVisualizacao();
            adicionarLog(`‚úÖ Visualiza√ß√£o atualizada`, 'success');
        }
        
        function avancarMes() {
            // Salvar estado atual antes de avan√ßar
            const chaveAtual = getChaveMes();
            if (contas.length > 0) {
                todasContas[chaveAtual] = JSON.parse(JSON.stringify(contas));
                localStorage.setItem('todasContas', JSON.stringify(todasContas));
            }
            
            mesAtual.setMonth(mesAtual.getMonth() + 1);
            
            // Salvar o novo m√™s atual
            localStorage.setItem('mesAtualSalvo', JSON.stringify({
                ano: mesAtual.getFullYear(),
                mes: mesAtual.getMonth()
            }));
            
            // FOR√áAR recarga completa do localStorage
            const dadosAtualizados = localStorage.getItem('todasContas');
            if (dadosAtualizados) {
                todasContas = JSON.parse(dadosAtualizados);
            }
            
            atualizarVisualizacao();
        }

// ========================================
        // SISTEMA DE PAGAMENTOS ALTERADOS (RECEBIMENTOS)
        // ========================================
        
        function abrirModalPagamentoCustom(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            const nomePessoa = pessoa.nome;
            const valorNormal = pessoa.valor;
            
            // Se j√° existe valor alterado, mostrar no campo automaticamente
            if (pessoa._valorPagoReal !== undefined) {
                setTimeout(() => {
                    const campo = document.getElementById('valorPagoAlterado');
                    if (campo) campo.value = pessoa._valorPagoReal;
                }, 50);
            }
            
            document.getElementById('modalMenuTitulo').textContent = `üí∞ Pagamento - ${nomePessoa}`;
            
            let conteudo = '<div class="menu-opcoes">';
            conteudo += `<button class="menu-btn menu-btn-adicionar" onclick="fecharModalMenu(); confirmarPagamentoNormalCustom(${contaId}, ${pessoaIndex})">‚úÖ Valor Normal (R$ ${valorNormal.toFixed(2)})</button>`;
            conteudo += `<button class="menu-btn" style="background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white;" onclick="fecharModalMenu(); abrirModalValorAlteradoCustom(${contaId}, ${pessoaIndex})">üí∞ Valor Alterado</button>`;
            conteudo += '<button class="menu-btn menu-btn-cancelar" onclick="fecharModalMenu()">‚úï Cancelar</button>';
            conteudo += '</div>';
            
            document.getElementById('modalMenuConteudo').innerHTML = conteudo;
            document.getElementById('modalMenu').classList.add('ativo');
        }
        
        function confirmarPagamentoNormalCustom(contaId, pessoaIndex) {
            togglePagoPessoaDireto(contaId, pessoaIndex);
        }
        
        function togglePagoPessoaDireto(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            const pessoa = conta.pessoas[pessoaIndex];
            
            if (pessoa.pago) {
                const nomePessoa = pessoa.nome;
                const confirmar = confirm(`‚ö†Ô∏è Reverter Pagamento\n\nDesmarcar "${nomePessoa}" como pago?\n\nValor: R$ ${pessoa.valor.toFixed(2)}`);
                if (!confirmar) {
                    return;
                }
            }
            
            // Alternar status de pago
            conta.pessoas[pessoaIndex].pago = !conta.pessoas[pessoaIndex].pago;
            
            // Atualizar valor no m√™s atual se houver valor alterado
            if (conta.pessoas[pessoaIndex]._valorPagoReal !== undefined) {
                const chaveAtual = getChaveMes();
                if (todasContas[chaveAtual]) {
                    const contaMesAtual = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                    if (contaMesAtual && contaMesAtual.pessoas[pessoaIndex]) {
                        contaMesAtual.pessoas[pessoaIndex]._valorPagoReal = conta.pessoas[pessoaIndex]._valorPagoReal;
                        contaMesAtual.pessoas[pessoaIndex].pago = conta.pessoas[pessoaIndex].pago;
                    }
                }
            }
            
            // Recalcular status da conta
            const todasPagas = conta.pessoas.every(p => p.pago);
            conta.pago = todasPagas;
            
            salvarNoStorage();
            carregarContasMesAtual();
            renderizarContas();
        }
        
        function abrirModalValorAlteradoCustom(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            const nomePessoa = pessoa.nome;
            const valorNormal = pessoa.valor;
            
            document.getElementById('modalFormTitulo').textContent = `üí∞ Pagamento Alterado - ${nomePessoa}`;
            
            let conteudo = '<form id="formPagamentoAlteradoCustom" onsubmit="processarPagamentoAlteradoCustom(event, ' + contaId + ', ' + pessoaIndex + ')">';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Normal da Parcela:</label>';
            conteudo += `<input type="text" value="R$ ${valorNormal.toFixed(2)}" readonly style="background: #f0f0f0; font-weight: bold; color: #667eea;">`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Efetivamente Pago:</label>';
            conteudo += `<input type="number" id="valorPagoAlteradoCustom" step="0.01" min="0" placeholder="0.00" required autofocus>`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Como tratar o excedente/falta?</label>';
            conteudo += '<select id="tipoAbatimentoCustom" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">';
            conteudo += '<option value="proximo">üîÑ Abater no Pr√≥ximo Per√≠odo</option>';
            conteudo += '<option value="reduzir">üìâ Reduzir N√∫mero de Parcelas</option>';
            conteudo += '<option value="redistribuir">üìä Redistribuir Igualmente</option>';
            conteudo += '</select>';
            conteudo += '</div>';
            
            conteudo += '<div style="background: #e7f3ff; border-left: 4px solid #2196F3; padding: 12px; border-radius: 6px; margin-top: 16px; font-size: 12px; color: #1976D2;">';
            conteudo += '<strong>üí° Explica√ß√£o:</strong><br>';
            conteudo += '‚Ä¢ <strong>Abater no Pr√≥ximo</strong>: Excedente cobre pr√≥ximas parcelas<br>';
            conteudo += '‚Ä¢ <strong>Reduzir Parcelas</strong>: Mant√©m valor, diminui quantidade<br>';
            conteudo += '‚Ä¢ <strong>Redistribuir</strong>: Mant√©m parcelas, ajusta valores';
            conteudo += '</div>';
            
            conteudo += '<div class="form-acoes-modal">';
            conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">‚úï Cancelar</button>';
            conteudo += '<button type="submit" class="btn-salvar-modal">üí∞ Confirmar Pagamento</button>';
            conteudo += '</div>';
            conteudo += '</form>';
            
            document.getElementById('modalFormConteudo').innerHTML = conteudo;
            document.getElementById('modalForm').classList.add('ativo');
        }
        
        function processarPagamentoAlteradoCustom(e, contaId, pessoaIndex) {
            e.preventDefault();
            
            const valorPago = parseFloat(document.getElementById('valorPagoAlteradoCustom').value);
            const tipoAbatimento = document.getElementById('tipoAbatimentoCustom').value;
            
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            const valorNormal = pessoa.valor;
            
            // NOVO: Detectar se √© uma REEDI√á√ÉO (valor alterado j√° existia)
            const ehReedicao = pessoa._valorPagoReal !== undefined && pessoa._valorPagoReal !== valorNormal;
            const valorAnterior = pessoa._valorPagoReal || valorNormal;
            const diferenca = valorPago - valorAnterior;
            
            adicionarLog(`   üîç Tipo de opera√ß√£o: ${ehReedicao ? 'REEDI√á√ÉO' : 'NOVO PAGAMENTO'}`, 'importante');
            if (ehReedicao) {
                adicionarLog(`   üìä Valor anterior: R$ ${valorAnterior.toFixed(2)}`, 'info');
                adicionarLog(`   üìä Valor novo: R$ ${valorPago.toFixed(2)}`, 'info');
                adicionarLog(`   üìä Diferen√ßa a ajustar: R$ ${diferenca.toFixed(2)}`, 'info');
            }
            
            adicionarLog(`üí∞ PAGAMENTO ALTERADO DETECTADO`, 'importante');
            adicionarLog(`   Valor normal: R$ ${valorNormal.toFixed(2)}`, 'info');
            adicionarLog(`   Valor pago: R$ ${valorPago.toFixed(2)}`, 'info');
            adicionarLog(`   Diferen√ßa em rela√ß√£o ao ${ehReedicao ? 'valor anterior' : 'valor normal'}: R$ ${diferenca.toFixed(2)}`, diferenca >= 0 ? 'success' : 'warning');
            adicionarLog(`   Tipo de abatimento: ${tipoAbatimento}`, 'info');
            
            // Marcar como pago com valor alterado NO M√äS ATUAL
            pessoa.pago = true;
            pessoa._valorPagoReal = valorPago;
            
            // CR√çTICO: ATUALIZAR tamb√©m no array contas (usado para renderizar a tela)
            const contaAtual = contas.find(c => c.id === contaId);
            if (contaAtual && contaAtual.pessoas[pessoaIndex]) {
                contaAtual.pessoas[pessoaIndex].pago = true;
                contaAtual.pessoas[pessoaIndex]._valorPagoReal = valorPago;
                adicionarLog(`   ‚úÖ Valor alterado no array contas: R$ ${valorPago.toFixed(2)}`, 'success');
            }
            
            // ATUALIZAR tamb√©m no todasContas do m√™s atual
            const chaveAtual = getChaveMes();
            if (todasContas[chaveAtual]) {
                const contaMesAtual = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaMesAtual) {
                    const pessoaMesAtual = contaMesAtual.pessoas.find(p => p.nome === pessoa.nome);
                    if (pessoaMesAtual) {
                        pessoaMesAtual.pago = true;
                        pessoaMesAtual._valorPagoReal = valorPago;
                        adicionarLog(`   ‚úÖ Valor alterado salvo no todasContas: R$ ${valorPago.toFixed(2)}`, 'success');
                    }
                }
            }
            
            // Aplicar l√≥gica de abatimento
            // CORRE√á√ÉO: Sempre aplicar quando for redistribuir (mesmo se diferen√ßa for 0 devido a reedi√ß√£o)
            if (diferenca !== 0 || (ehReedicao && tipoAbatimento === 'redistribuir')) {
                aplicarAbatimentoRecebimento(conta, pessoa, diferenca, tipoAbatimento);
            } else if (diferenca === 0) {
                adicionarLog(`   ‚ÑπÔ∏è Nenhuma diferen√ßa detectada, apenas atualizando valor pago`, 'info');
            }
            
            // FOR√áAR recalculo do status da conta
            const todasPagas = conta.pessoas.every(p => p.pago);
            conta.pago = todasPagas;
            
            // IMPORTANTE: Atualizar todasContas novamente ap√≥s aplicar abatimento
            if (todasContas[chaveAtual]) {
                const contaMesAtualFinal = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaMesAtualFinal) {
                    const pessoaMesAtualFinal = contaMesAtualFinal.pessoas.find(p => p.nome === pessoa.nome);
                    if (pessoaMesAtualFinal) {
                        pessoaMesAtualFinal.pago = true;
                        pessoaMesAtualFinal._valorPagoReal = valorPago;
                    }
                }
            }
            
            // CR√çTICO: For√ßar recarga COMPLETA do localStorage ap√≥s aplicar abatimento
            const dadosAtualizadosAgora = localStorage.getItem('todasContas');
            if (dadosAtualizadosAgora) {
                todasContas = JSON.parse(dadosAtualizadosAgora);
                adicionarLog(`   ‚úÖ todasContas recarregado ap√≥s abatimento`, 'success');
            }
            
            // Recarregar o m√™s atual COM OS DADOS RECRIADOS
            carregarContasMesAtual();
            
            // NOVO: FOR√áAR atualiza√ß√£o do status PAGO ap√≥s recarregar
            const contaRecarregada = contas.find(c => c.id === contaId);
            if (contaRecarregada && contaRecarregada.pessoas[pessoaIndex]) {
                contaRecarregada.pessoas[pessoaIndex].pago = true;
                contaRecarregada.pessoas[pessoaIndex]._valorPagoReal = valorPago;
                
                // Recalcular status da conta
                const todasPagasRecarregada = contaRecarregada.pessoas.every(p => p.pago);
                contaRecarregada.pago = todasPagasRecarregada;
                
                adicionarLog(`   ‚úÖ Status PAGO for√ßado ap√≥s recarregar`, 'success');
            }
            
            // Salvar novamente ap√≥s for√ßar o status
            salvarNoStorage();
            
            // Renderizar interface
            renderizarContas();
            fecharModalForm();
            
            alert(`‚úÖ Pagamento registrado!\n\nüí∞ Valor: R$ ${valorPago.toFixed(2)}\nüìä Abatimento: ${tipoAbatimento === 'proximo' ? 'Pr√≥ximo Per√≠odo' : tipoAbatimento === 'reduzir' ? 'Reduzir Parcelas' : 'Redistribuir'}`);
        }
        
        function abrirModalPagamentoRecebimento(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu') {
                nomePessoa = 'Devedor';
            }
            
            const valorNormal = pessoa.valor;
            
            // Se j√° existe valor alterado, mostrar no campo automaticamente
            if (pessoa._valorPagoReal !== undefined) {
                setTimeout(() => {
                    document.getElementById('valorPagoAlterado').value = pessoa._valorPagoReal;
                }, 50);
            }
            
            document.getElementById('modalMenuTitulo').textContent = `üí∞ Pagamento - ${nomePessoa}`;
            
            let conteudo = '<div class="menu-opcoes">';
            conteudo += `<button class="menu-btn menu-btn-adicionar" onclick="fecharModalMenu(); confirmarPagamentoNormal(${contaId}, ${pessoaIndex})">‚úÖ Valor Normal (R$ ${valorNormal.toFixed(2)})</button>`;
            conteudo += `<button class="menu-btn" style="background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white;" onclick="fecharModalMenu(); abrirModalValorAlterado(${contaId}, ${pessoaIndex})">üí∞ Valor Alterado</button>`;
            conteudo += '<button class="menu-btn menu-btn-cancelar" onclick="fecharModalMenu()">‚úï Cancelar</button>';
            conteudo += '</div>';
            
            document.getElementById('modalMenuConteudo').innerHTML = conteudo;
            document.getElementById('modalMenu').classList.add('ativo');
        }
        
        function confirmarPagamentoNormal(contaId, pessoaIndex) {
            togglePagoPessoa(contaId, pessoaIndex);
        }
        
        function abrirModalValorAlterado(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu') {
                nomePessoa = 'Devedor';
            }
            
            const valorNormal = pessoa.valor;
            
            document.getElementById('modalFormTitulo').textContent = `üí∞ Pagamento Alterado - ${nomePessoa}`;
            
            let conteudo = '<form id="formPagamentoAlterado" onsubmit="processarPagamentoAlterado(event, ' + contaId + ', ' + pessoaIndex + ')">';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Normal da Parcela:</label>';
            conteudo += `<input type="text" value="R$ ${valorNormal.toFixed(2)}" readonly style="background: #f0f0f0; font-weight: bold; color: #667eea;">`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Efetivamente Pago:</label>';
            conteudo += `<input type="number" id="valorPagoAlterado" step="0.01" min="0" placeholder="0.00" required autofocus>`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Como tratar o excedente/falta?</label>';
            conteudo += '<select id="tipoAbatimento" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">';
            conteudo += '<option value="proximo">üîÑ Abater no Pr√≥ximo Per√≠odo</option>';
            conteudo += '<option value="reduzir">üìâ Reduzir N√∫mero de Parcelas</option>';
            conteudo += '<option value="redistribuir">üìä Redistribuir Igualmente</option>';
            conteudo += '</select>';
            conteudo += '</div>';
            
            conteudo += '<div style="background: #e7f3ff; border-left: 4px solid #2196F3; padding: 12px; border-radius: 6px; margin-top: 16px; font-size: 12px; color: #1976D2;">';
            conteudo += '<strong>üí° Explica√ß√£o:</strong><br>';
            conteudo += '‚Ä¢ <strong>Abater no Pr√≥ximo</strong>: Excedente cobre pr√≥ximas parcelas<br>';
            conteudo += '‚Ä¢ <strong>Reduzir Parcelas</strong>: Mant√©m valor, diminui quantidade<br>';
            conteudo += '‚Ä¢ <strong>Redistribuir</strong>: Mant√©m parcelas, ajusta valores';
            conteudo += '</div>';
            
            conteudo += '<div class="form-acoes-modal">';
            conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">‚úï Cancelar</button>';
            conteudo += '<button type="submit" class="btn-salvar-modal">üí∞ Confirmar Pagamento</button>';
            conteudo += '</div>';
            conteudo += '</form>';
            
            document.getElementById('modalFormConteudo').innerHTML = conteudo;
            document.getElementById('modalForm').classList.add('ativo');
        }
        
        function processarPagamentoAlterado(e, contaId, pessoaIndex) {
            e.preventDefault();
            
            const valorPago = parseFloat(document.getElementById('valorPagoAlterado').value);
            const tipoAbatimento = document.getElementById('tipoAbatimento').value;
            
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            const valorNormal = pessoa.valor;
            // NOVO: Detectar se √© uma REEDI√á√ÉO (valor alterado j√° existia)
            const ehReedicao = pessoa._valorPagoReal !== undefined && pessoa._valorPagoReal !== valorNormal;
            const valorAnterior = pessoa._valorPagoReal || valorNormal;
            const diferenca = valorPago - valorAnterior; // Diferen√ßa em rela√ß√£o ao valor ANTERIOR (n√£o ao normal)
            
            adicionarLog(`   üîç Tipo de opera√ß√£o: ${ehReedicao ? 'REEDI√á√ÉO' : 'NOVO PAGAMENTO'}`, 'importante');
            if (ehReedicao) {
                adicionarLog(`   üìä Valor anterior: R$ ${valorAnterior.toFixed(2)}`, 'info');
                adicionarLog(`   üìä Valor novo: R$ ${valorPago.toFixed(2)}`, 'info');
                adicionarLog(`   üìä Diferen√ßa a ajustar: R$ ${diferenca.toFixed(2)}`, 'info');
            }
            
            adicionarLog(`üí∞ PAGAMENTO ALTERADO DETECTADO`, 'importante');
            adicionarLog(`   Valor normal: R$ ${valorNormal.toFixed(2)}`, 'info');
            adicionarLog(`   Valor pago: R$ ${valorPago.toFixed(2)}`, 'info');
            adicionarLog(`   Diferen√ßa em rela√ß√£o ao ${ehReedicao ? 'valor anterior' : 'valor normal'}: R$ ${diferenca.toFixed(2)}`, diferenca >= 0 ? 'success' : 'warning');
            adicionarLog(`   Tipo de abatimento: ${tipoAbatimento}`, 'info');
            
            // Marcar como pago com valor alterado NO M√äS ATUAL
            pessoa.pago = true;
            pessoa._valorPagoReal = valorPago;
            
            // CR√çTICO: ATUALIZAR tamb√©m no array contas (usado para renderizar a tela)
            const contaAtual = contas.find(c => c.id === contaId);
            if (contaAtual && contaAtual.pessoas[pessoaIndex]) {
                contaAtual.pessoas[pessoaIndex].pago = true;
                contaAtual.pessoas[pessoaIndex]._valorPagoReal = valorPago;
                adicionarLog(`   ‚úÖ Valor alterado no array contas: R$ ${valorPago.toFixed(2)}`, 'success');
            }
            
            // ATUALIZAR tamb√©m no todasContas do m√™s atual
            const chaveAtual = getChaveMes();
            if (todasContas[chaveAtual]) {
                const contaMesAtual = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaMesAtual) {
                    const pessoaMesAtual = contaMesAtual.pessoas.find(p => p.nome === pessoa.nome);
                    if (pessoaMesAtual) {
                        pessoaMesAtual.pago = true;
                        pessoaMesAtual._valorPagoReal = valorPago;
                        adicionarLog(`   ‚úÖ Valor alterado salvo no todasContas: R$ ${valorPago.toFixed(2)}`, 'success');
                    }
                }
            }
            
            // Aplicar l√≥gica de abatimento
            // CORRE√á√ÉO: Sempre aplicar quando for redistribuir (mesmo se diferen√ßa for 0 devido a reedi√ß√£o)
            if (diferenca !== 0 || (ehReedicao && tipoAbatimento === 'redistribuir')) {
                aplicarAbatimentoRecebimento(conta, pessoa, diferenca, tipoAbatimento);
            } else if (diferenca === 0) {
                adicionarLog(`   ‚ÑπÔ∏è Nenhuma diferen√ßa detectada, apenas atualizando valor pago`, 'info');
            }
            
            // FOR√áAR recalculo do status da conta
            const todasPagas = conta.pessoas.every(p => p.pago);
            conta.pago = todasPagas;
            
            // IMPORTANTE: Atualizar todasContas novamente ap√≥s aplicar abatimento
            if (todasContas[chaveAtual]) {
                const contaMesAtualFinal = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaMesAtualFinal) {
                    const pessoaMesAtualFinal = contaMesAtualFinal.pessoas.find(p => p.nome === pessoa.nome);
                    if (pessoaMesAtualFinal) {
                        pessoaMesAtualFinal.pago = true;
                        pessoaMesAtualFinal._valorPagoReal = valorPago;
                    }
                }
            }
            
            // CR√çTICO: For√ßar recarga COMPLETA do localStorage ap√≥s aplicar abatimento
            const dadosAtualizadosAgora = localStorage.getItem('todasContas');
            if (dadosAtualizadosAgora) {
                todasContas = JSON.parse(dadosAtualizadosAgora);
                adicionarLog(`   ‚úÖ todasContas recarregado ap√≥s abatimento`, 'success');
            }
            
            // Recarregar o m√™s atual COM OS DADOS RECRIADOS
            carregarContasMesAtual();
            
            // NOVO: FOR√áAR atualiza√ß√£o do status PAGO ap√≥s recarregar
            const contaRecarregada = contas.find(c => c.id === contaId);
            if (contaRecarregada && contaRecarregada.pessoas[pessoaIndex]) {
                contaRecarregada.pessoas[pessoaIndex].pago = true;
                contaRecarregada.pessoas[pessoaIndex]._valorPagoReal = valorPago;
                
                // Recalcular status da conta
                const todasPagasRecarregada = contaRecarregada.pessoas.every(p => p.pago);
                contaRecarregada.pago = todasPagasRecarregada;
                
                adicionarLog(`   ‚úÖ Status PAGO for√ßado ap√≥s recarregar`, 'success');
            }
            
            // Salvar novamente ap√≥s for√ßar o status
            salvarNoStorage();
            
            // Renderizar interface
            renderizarContas();
            fecharModalForm();
            
            alert(`‚úÖ Pagamento registrado!\n\nüí∞ Valor: R$ ${valorPago.toFixed(2)}\nüìä Abatimento: ${tipoAbatimento === 'proximo' ? 'Pr√≥ximo Per√≠odo' : tipoAbatimento === 'reduzir' ? 'Reduzir Parcelas' : 'Redistribuir'}`);
        }
        
        function aplicarAbatimentoRecebimento(conta, pessoa, diferenca, tipoAbatimento) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            adicionarLog(`üîß aplicarAbatimentoRecebimento INICIADA`, 'importante');
            adicionarLog(`   Diferen√ßa: R$ ${diferenca.toFixed(2)}`, 'info');
            adicionarLog(`   Tipo: ${tipoAbatimento}`, 'info');
            
            if (!pessoa.compras || pessoa.compras.length === 0) {
                adicionarLog(`   ‚ö†Ô∏è Pessoa sem compras detalhadas`, 'warning');
                return;
            }
            
            const compra = pessoa.compras[0];
            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
            
            if (!match) {
                adicionarLog(`   ‚ö†Ô∏è Recebimento sem parcelas`, 'warning');
                return;
            }
            
            let parcelaAtual = parseInt(match[1]);
            let totalParcelas = parseInt(match[2]);
            
            // NOVO: VERIFICAR SE J√Å HOUVE ABATIMENTOS ANTERIORES
            // Procurar o total de parcelas REAL mais recente em todos os meses
            let maiorTotalEncontrado = totalParcelas;
            let maiorParcelaEncontrada = parcelaAtual;
            
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(p => {
                        if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                            p.compras.forEach(c => {
                                if (c.idUnico === compra.idUnico) {
                                    const matchEncontrado = c.parcelas ? c.parcelas.match(/(\d+)\/(\d+)/) : null;
                                    if (matchEncontrado) {
                                        const parcelaEncontrada = parseInt(matchEncontrado[1]);
                                        const totalEncontrado = parseInt(matchEncontrado[2]);
                                        
                                        // Pegar o maior total encontrado (pode ter sido reduzido antes)
                                        if (totalEncontrado < maiorTotalEncontrado || 
                                            (totalEncontrado <= totalParcelas && totalEncontrado > 0)) {
                                            maiorTotalEncontrado = totalEncontrado;
                                        }
                                        
                                        // Pegar a maior parcela vista
                                        if (parcelaEncontrada > maiorParcelaEncontrada) {
                                            maiorParcelaEncontrada = parcelaEncontrada;
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            // ATUALIZAR para usar os valores REAIS mais recentes
            if (maiorTotalEncontrado < totalParcelas) {
                adicionarLog(`   üîÑ DETECTADO abatimento anterior: ${totalParcelas} ‚Üí ${maiorTotalEncontrado} parcelas`, 'warning');
                totalParcelas = maiorTotalEncontrado;
            }
            
            // A parcela atual √© a do m√™s atual (n√£o necessariamente a maior encontrada)
            // Mas precisamos ajustar baseado no total correto
            if (parcelaAtual > totalParcelas) {
                parcelaAtual = totalParcelas;
                adicionarLog(`   üîÑ Parcela atual ajustada para: ${parcelaAtual}/${totalParcelas}`, 'warning');
            }
            
            adicionarLog(`   üìä Parcela atual (ap√≥s verifica√ß√£o): ${parcelaAtual}/${totalParcelas}`, 'info');
            
            if (tipoAbatimento === 'proximo') {
                aplicarAbatimentoProximo(conta.nome, pessoa, compra, diferenca, parcelaAtual, totalParcelas);
            } else if (tipoAbatimento === 'reduzir') {
                aplicarAbatimentoReduzir(conta.nome, pessoa, compra, diferenca, parcelaAtual, totalParcelas);
            } else if (tipoAbatimento === 'redistribuir') {
                aplicarAbatimentoRedistribuir(conta.nome, pessoa, compra, diferenca, parcelaAtual, totalParcelas);
            }
            
            adicionarLog(`‚úÖ aplicarAbatimentoRecebimento CONCLU√çDA`, 'success');
        }
        
        function aplicarAbatimentoProximo(nomeConta, pessoa, compra, diferenca, parcelaAtual, totalParcelas) {
            adicionarLog(`   üîÑ Modo: ABATER NO PR√ìXIMO`, 'warning');
            adicionarLog(`   üìä Diferen√ßa: R$ ${diferenca.toFixed(2)} (${diferenca > 0 ? 'EXCEDENTE' : 'FALTA'})`, 'info');
            
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            
            let saldoRestante = Math.abs(diferenca); // Usar valor absoluto
            const ehExcedente = diferenca > 0; // true = pagou a mais, false = pagou a menos
            
            adicionarLog(`   üéØ Tipo de ajuste: ${ehExcedente ? 'ABATER excedente' : 'AUMENTAR pr√≥ximas parcelas'}`, 'warning');
            
            // Processar meses futuros
            for (let i = 1; i <= totalParcelas - parcelaAtual && saldoRestante > 0.01; i++) {
                const dataFutura = new Date(anoAtual, mesAtualNum - 1 + i, 1);
                const anoFuturo = dataFutura.getFullYear();
                const mesFuturo = dataFutura.getMonth() + 1;
                const chaveFutura = `${anoFuturo}-${String(mesFuturo).padStart(2, '0')}`;
                
                // Criar m√™s se n√£o existir
                if (!todasContas[chaveFutura]) {
                    todasContas[chaveFutura] = [];
                }
                
                let contasMes = todasContas[chaveFutura];
                let contaFutura = contasMes.find(c => c.nome === nomeConta);
                
                // Criar conta se n√£o existir
                if (!contaFutura) {
                    const contaOriginal = contas.find(c => c.nome === nomeConta);
                    if (contaOriginal) {
                        contaFutura = {
                            ...contaOriginal,
                            id: Date.now() + Math.random(),
                            pessoas: [],
                            pago: false
                        };
                        contasMes.push(contaFutura);
                    }
                }
                
                if (contaFutura) {
                    let pessoaFutura = contaFutura.pessoas.find(p => p.nome === pessoa.nome);
                    
                    // Criar pessoa se n√£o existir
                    if (!pessoaFutura && pessoa.compras && pessoa.compras.length > 0) {
                        const proximaParcelaNum = parcelaAtual + i;
                        if (proximaParcelaNum <= totalParcelas) {
                            pessoaFutura = {
                                nome: pessoa.nome,
                                valor: compra.valorParcela,
                                valorTotal: compra.valorTotal,
                                parcelas: `${proximaParcelaNum}/${totalParcelas}`,
                                compras: [{
                                    ...compra,
                                    parcelas: `${proximaParcelaNum}/${totalParcelas}`
                                }],
                                pago: false
                            };
                            contaFutura.pessoas.push(pessoaFutura);
                        }
                    }
                    
                    if (pessoaFutura && pessoaFutura.compras && pessoaFutura.compras.length > 0) {
                        const compraFutura = pessoaFutura.compras[0];
                        const valorOriginal = compraFutura.valorParcela;
                        
                        if (ehExcedente) {
                            // ===== PAGOU A MAIS: ABATER =====
                            if (saldoRestante >= valorOriginal) {
                                // Zerar completamente E marcar como pago
                                pessoaFutura.valor = 0;
                                pessoaFutura.pago = true;
                                pessoaFutura._valorPagoReal = 0;
                                compraFutura.valorParcela = 0;
                                saldoRestante -= valorOriginal;
                                
                                const todasPagasNestaConta = contaFutura.pessoas.every(p => p.pago);
                                contaFutura.pago = todasPagasNestaConta;
                                
                                adicionarLog(`      M√™s ${chaveFutura}: Zerado e marcado como PAGO ‚úÖ`, 'success');
                            } else if (saldoRestante > 0) {
                                // Abater parcialmente
                                const novoValor = valorOriginal - saldoRestante;
                                pessoaFutura.valor = novoValor;
                                compraFutura.valorParcela = novoValor;
                                saldoRestante = 0;
                                
                                adicionarLog(`      M√™s ${chaveFutura}: Reduzido para R$ ${novoValor.toFixed(2)}`, 'success');
                            }
                        } else {
                            // ===== PAGOU A MENOS: AUMENTAR =====
                            const novoValor = valorOriginal + saldoRestante;
                            pessoaFutura.valor = novoValor;
                            compraFutura.valorParcela = novoValor;
                            
                            adicionarLog(`      M√™s ${chaveFutura}: Aumentado para R$ ${novoValor.toFixed(2)}`, 'warning');
                            
                            // Todo o saldo foi adicionado √† pr√≥xima parcela
                            saldoRestante = 0;
                        }
                    }
                }
            }
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }
        
        function aplicarAbatimentoReduzir(nomeConta, pessoa, compra, diferenca, parcelaAtual, totalParcelas) {
            adicionarLog(`   üìâ Modo: REDUZIR PARCELAS`, 'warning');
            
            const valorParcela = compra.valorParcela;
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            
            // *** CORRE√á√ÉO CR√çTICA: DESCOBRIR O TOTAL REAL ATUAL ***
            let totalParcelasReal = totalParcelas;
            
            adicionarLog(`   üîç Descobrindo total REAL de parcelas ap√≥s redu√ß√µes anteriores...`, 'info');
            
            // Verificar em TODOS os meses qual √© o MENOR total de parcelas que existe
            // (o menor total indica que houve redu√ß√£o)
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(p => {
                        if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                            p.compras.forEach(c => {
                                if (c.idUnico === compra.idUnico) {
                                    const match = c.parcelas ? c.parcelas.match(/(\d+)\/(\d+)/) : null;
                                    if (match) {
                                        const totalDessaCompra = parseInt(match[2]);
                                        
                                        // Atualizar o total real (MENOR valor = redu√ß√£o anterior)
                                        if (totalDessaCompra < totalParcelasReal) {
                                            totalParcelasReal = totalDessaCompra;
                                            adicionarLog(`      üìä Total reduzido detectado no m√™s ${chaveMes}: ${totalDessaCompra} parcelas`, 'warning');
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            adicionarLog(`   üìä Total ORIGINAL: ${totalParcelas}, Total REAL atual: ${totalParcelasReal}`, 'importante');
            adicionarLog(`   üìä Parcela atual: ${parcelaAtual}/${totalParcelasReal}`, 'info');
            
            // *** CALCULAR BASEADO NO TOTAL REAL ***
            const parcelasRestantes = totalParcelasReal - parcelaAtual;
            
            // IMPORTANTE: Usar o valor real de cada parcela restante
            let valorRestanteTotal = 0;
            
            // Somar apenas parcelas que REALMENTE existem nos meses futuros
            for (let i = 1; i <= parcelasRestantes; i++) {
                const dataFutura = new Date(anoAtual, mesAtualNum - 1 + i, 1);
                const anoFuturo = dataFutura.getFullYear();
                const mesFuturo = dataFutura.getMonth() + 1;
                const chaveFutura = `${anoFuturo}-${String(mesFuturo).padStart(2, '0')}`;
                
                if (todasContas[chaveFutura]) {
                    const contasMes = todasContas[chaveFutura];
                    const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas.forEach(p => {
                            if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                                p.compras.forEach(c => {
                                    if (c.idUnico === compra.idUnico) {
                                        valorRestanteTotal += c.valorParcela;
                                        adicionarLog(`      üìå M√™s ${chaveFutura}: Parcela de R$ ${c.valorParcela.toFixed(2)} encontrada`, 'info');
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Se n√£o encontrou parcelas futuras, usar c√°lculo te√≥rico
            if (valorRestanteTotal === 0) {
                valorRestanteTotal = parcelasRestantes * valorParcela;
                adicionarLog(`      ‚ö†Ô∏è Nenhuma parcela futura encontrada, usando c√°lculo te√≥rico`, 'warning');
            }
            
            adicionarLog(`      üí∞ Valor restante REAL encontrado: R$ ${valorRestanteTotal.toFixed(2)}`, 'info');
            const valorAposAbatimento = valorRestanteTotal - diferenca;
            const parcelasNecessarias = valorAposAbatimento > 0 ? Math.ceil(valorAposAbatimento / valorParcela) : 0;
            const novoTotalParcelas = parcelaAtual + parcelasNecessarias;
            
            adicionarLog(`   üìä An√°lise detalhada:`, 'info');
            adicionarLog(`      Parcela atual: ${parcelaAtual}/${totalParcelasReal}`, 'info');
            adicionarLog(`      Valor da parcela: R$ ${valorParcela.toFixed(2)}`, 'info');
            adicionarLog(`      Parcelas restantes: ${parcelasRestantes}`, 'info');
            adicionarLog(`      Valor restante total: R$ ${valorRestanteTotal.toFixed(2)}`, 'info');
            adicionarLog(`      Abatimento aplicado: R$ ${diferenca.toFixed(2)}`, 'info');
            adicionarLog(`      Valor ap√≥s abatimento: R$ ${valorAposAbatimento.toFixed(2)}`, 'info');
            adicionarLog(`      Parcelas necess√°rias: ${parcelasNecessarias}`, 'info');
            adicionarLog(`   üéØ Resultado: ${totalParcelasReal} parcelas ‚Üí ${novoTotalParcelas} parcelas`, 'importante');
            
            // PASSO 1: COLETAR valores alterados ANTES de remover
            adicionarLog(`   üì¶ COLETANDO valores alterados antes de remover`, 'warning');
            const valoresAlterados = new Map(); // chaveMes -> { valorPago, pago }
            
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(p => {
                        if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                            p.compras.forEach(c => {
                                if (c.idUnico === compra.idUnico) {
                                    // Se tem valor alterado, guardar
                                    if (p._valorPagoReal !== undefined || p.pago) {
                                        valoresAlterados.set(chaveMes, {
                                            valorPago: p._valorPagoReal,
                                            pago: p.pago,
                                            parcelas: c.parcelas
                                        });
                                        adicionarLog(`      üì¶ M√™s ${chaveMes}: Salvo valor alterado R$ ${(p._valorPagoReal || 0).toFixed(2)} (PAGO: ${p.pago})`, 'info');
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            // PASSO 2: REMOVER todas as parcelas ANTIGAS
            adicionarLog(`   üóëÔ∏è REMOVENDO TODAS parcelas antigas de TODOS os meses`, 'warning');
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                        if (p.nome !== pessoa.nome) return true;
                        
                        if (p.compras && p.compras.length > 0) {
                            p.compras = p.compras.filter(c => c.idUnico !== compra.idUnico);
                            
                            if (p.compras.length > 0) {
                                p.valor = p.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                return true;
                            }
                            return false;
                        }
                        return true;
                    });
                    
                    adicionarLog(`      ‚úÇÔ∏è M√™s ${chaveMes}: Limpo`, 'info');
                }
            });
            
            // PASSO 3: DESCOBRIR o m√™s inicial (onde est√° a parcela 1 original)
            let anoInicial = anoAtual;
            let mesInicial = mesAtualNum - (parcelaAtual - 1);
            
            while (mesInicial < 1) {
                mesInicial += 12;
                anoInicial--;
            }
            
            // PASSO 4: REMOVER meses AP√ìS o novo total de parcelas
            const mesUltimaParcela = new Date(anoInicial, mesInicial - 1 + (novoTotalParcelas - 1), 1);
            const anoUltimaParcela = mesUltimaParcela.getFullYear();
            const mesNumUltimaParcela = mesUltimaParcela.getMonth() + 1;
            
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                if (dataMes > mesUltimaParcela) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                            if (p.nome !== pessoa.nome) return true;
                            
                            if (p.compras && p.compras.length > 0) {
                                p.compras = p.compras.filter(c => c.idUnico !== compra.idUnico);
                                return p.compras.length > 0;
                            }
                            return false;
                        });
                        adicionarLog(`      üóëÔ∏è M√™s ${chaveMes}: Removido (al√©m do novo total)`, 'warning');
                    }
                }
            });
            
            // PASSO 5: RECRIAR todas as parcelas de 1 at√© o novo total
            adicionarLog(`   ‚úèÔ∏è RECRIANDO parcelas 1 at√© ${novoTotalParcelas}`, 'success');
            
            // CALCULAR o valor da √∫ltima parcela (pode ser diferente)
            const valorParcelasCompletas = Math.floor(valorAposAbatimento / valorParcela) * valorParcela;
            const valorUltimaParcela = valorAposAbatimento - valorParcelasCompletas;
            
            adicionarLog(`   üí∞ C√°lculo de valores:`, 'info');
            adicionarLog(`      Valor parcelas completas: R$ ${valorParcelasCompletas.toFixed(2)}`, 'info');
            adicionarLog(`      Valor √∫ltima parcela: R$ ${valorUltimaParcela.toFixed(2)}`, 'info');
            
            for (let numParcela = 1; numParcela <= novoTotalParcelas; numParcela++) {
                const mesesAFrente = numParcela - 1;
                const dataFutura = new Date(anoInicial, mesInicial - 1 + mesesAFrente, 1);
                const anoFuturo = dataFutura.getFullYear();
                const mesFuturo = dataFutura.getMonth() + 1;
                const chaveFutura = `${anoFuturo}-${String(mesFuturo).padStart(2, '0')}`;
                
                if (!todasContas[chaveFutura]) {
                    todasContas[chaveFutura] = [];
                }
                
                let contasMes = todasContas[chaveFutura];
                let contaFutura = contasMes.find(c => c.nome === nomeConta);
                
                if (!contaFutura) {
                    const contaOriginal = contas.find(c => c.nome === nomeConta);
                    if (contaOriginal) {
                        contaFutura = {
                            ...contaOriginal,
                            id: Date.now() + Math.random(),
                            pessoas: [],
                            pago: false
                        };
                        contasMes.push(contaFutura);
                    }
                }
                
                if (contaFutura) {
                    let pessoaFutura = contaFutura.pessoas.find(p => p.nome === pessoa.nome);
                    
                    if (!pessoaFutura) {
                        // Determinar se esta parcela est√° paga ou n√£o
                        const estaPago = (numParcela < parcelaAtual) || 
                                        (numParcela === parcelaAtual && chaveFutura === chaveAtual);
                        
                        // Determinar o valor desta parcela
                        let valorDestaParcela = valorParcela;
                        if (numParcela === novoTotalParcelas && valorUltimaParcela > 0) {
                            valorDestaParcela = valorUltimaParcela;
                        }
                        
                        pessoaFutura = {
                            nome: pessoa.nome,
                            valor: valorDestaParcela,
                            valorTotal: compra.valorTotal,
                            parcelas: `${numParcela}/${novoTotalParcelas}`,
                            compras: [{
                                ...compra,
                                valorParcela: valorDestaParcela,
                                parcelas: `${numParcela}/${novoTotalParcelas}`,
                                _sequenciaRecriada: true,
                                _parcelaSequencial: numParcela,
                                _totalParcelasRecriado: novoTotalParcelas
                            }],
                            pago: estaPago
                        };
                        
                        // RESTAURAR valores alterados salvos anteriormente
                        if (valoresAlterados.has(chaveFutura)) {
                            const valorSalvo = valoresAlterados.get(chaveFutura);
                            pessoaFutura._valorPagoReal = valorSalvo.valorPago;
                            pessoaFutura.pago = valorSalvo.pago;
                            adicionarLog(`      üîÑ M√™s ${chaveFutura}: RESTAURADO valor alterado R$ ${(valorSalvo.valorPago || 0).toFixed(2)}`, 'success');
                        }
                        
                        // Se for o m√™s atual E parcela atual, garantir preserva√ß√£o
                        if (numParcela === parcelaAtual && chaveFutura === chaveAtual) {
                            if (pessoa._valorPagoReal !== undefined) {
                                pessoaFutura._valorPagoReal = pessoa._valorPagoReal;
                            }
                        }
                        
                        contaFutura.pessoas.push(pessoaFutura);
                        adicionarLog(`      ‚ú® M√™s ${chaveFutura}: Criada parcela ${numParcela}/${novoTotalParcelas} ${estaPago ? '(PAGA)' : ''} - Valor: R$ ${valorDestaParcela.toFixed(2)}`, 'success');
                    }
                }
            }
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }
        
        function aplicarAbatimentoRedistribuir(nomeConta, pessoa, compra, diferenca, parcelaAtual, totalParcelas) {
            adicionarLog(`   üìä Modo: REDISTRIBUIR IGUALMENTE`, 'warning');
            
            const valorParcela = compra.valorParcela;
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            
            // CORRE√á√ÉO: Descobrir o REAL total de parcelas ap√≥s poss√≠veis redu√ß√µes anteriores
            let totalParcelasReal = totalParcelas;
            let maiorParcelaEncontrada = parcelaAtual;
            
            adicionarLog(`   üîç Descobrindo total REAL de parcelas...`, 'info');
            
            // Verificar em TODOS os meses qual √© a maior parcela que existe
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(p => {
                        if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                            p.compras.forEach(c => {
                                if (c.idUnico === compra.idUnico) {
                                    const match = c.parcelas ? c.parcelas.match(/(\d+)\/(\d+)/) : null;
                                    if (match) {
                                        const numParcela = parseInt(match[1]);
                                        const totalDessaCompra = parseInt(match[2]);
                                        
                                        // Atualizar o total real (menor valor encontrado)
                                        if (totalDessaCompra < totalParcelasReal || totalDessaCompra < totalParcelas) {
                                            totalParcelasReal = totalDessaCompra;
                                        }
                                        
                                        // Atualizar a maior parcela encontrada
                                        if (numParcela > maiorParcelaEncontrada) {
                                            maiorParcelaEncontrada = numParcela;
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            adicionarLog(`   üìä Total original: ${totalParcelas}, Total REAL ap√≥s redu√ß√µes: ${totalParcelasReal}`, 'info');
            adicionarLog(`   üìä Parcela atual: ${parcelaAtual}, Maior parcela encontrada: ${maiorParcelaEncontrada}`, 'info');
            
            // CORRE√á√ÉO CR√çTICA: Se n√£o encontrou parcelas futuras, usar o total de parcelas original
            const totalParcelasParaUsar = maiorParcelaEncontrada > parcelaAtual ? Math.min(totalParcelasReal, maiorParcelaEncontrada) : totalParcelas;
            const parcelasRestantes = totalParcelasParaUsar - parcelaAtual;
            
            adicionarLog(`   üìä Parcelas restantes para redistribuir: ${parcelasRestantes}`, 'info');
            
            // NOVA L√ìGICA: Se n√£o encontrou valor restante, calcular baseado no valor da parcela original
            let valorRestanteTotal = 0;
            let encontrouParcelasFuturas = false;
            
            // Primeiro, tentar somar valores de parcelas que J√Å EXISTEM
            for (let i = 1; i <= parcelasRestantes; i++) {
                const dataFutura = new Date(anoAtual, mesAtualNum - 1 + i, 1);
                const anoFuturo = dataFutura.getFullYear();
                const mesFuturo = dataFutura.getMonth() + 1;
                const chaveFutura = `${anoFuturo}-${String(mesFuturo).padStart(2, '0')}`;
                
                if (todasContas[chaveFutura]) {
                    const contasMes = todasContas[chaveFutura];
                    const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas.forEach(p => {
                            if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                                p.compras.forEach(c => {
                                    if (c.idUnico === compra.idUnico) {
                                        valorRestanteTotal += c.valorParcela;
                                        encontrouParcelasFuturas = true;
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Se N√ÉO encontrou parcelas futuras (primeira vez usando redistribuir), calcular teoricamente
            if (!encontrouParcelasFuturas || valorRestanteTotal === 0) {
                valorRestanteTotal = valorParcela * parcelasRestantes;
                adicionarLog(`   ‚ö†Ô∏è Parcelas futuras n√£o existem ainda, calculando teoricamente`, 'warning');
            }
            
            adicionarLog(`   üí∞ Valor restante ${encontrouParcelasFuturas ? 'REAL' : 'TE√ìRICO'}: R$ ${valorRestanteTotal.toFixed(2)}`, 'info');
            
            // Aplicar a diferen√ßa
            const valorRestanteAposAjuste = valorRestanteTotal - diferenca;
            const novoValorParcela = Math.max(0, valorRestanteAposAjuste / parcelasRestantes);
            
            adicionarLog(`   üí∞ Valor restante ap√≥s ajuste: R$ ${valorRestanteAposAjuste.toFixed(2)}`, 'info');
            adicionarLog(`   üí∞ Novo valor por parcela (${parcelasRestantes} parcelas): R$ ${novoValorParcela.toFixed(2)}`, 'info');
            
            // CRIAR OU ATUALIZAR todas as parcelas futuras
            for (let i = 1; i <= parcelasRestantes; i++) {
                const dataFutura = new Date(anoAtual, mesAtualNum - 1 + i, 1);
                const anoFuturo = dataFutura.getFullYear();
                const mesFuturo = dataFutura.getMonth() + 1;
                const chaveFutura = `${anoFuturo}-${String(mesFuturo).padStart(2, '0')}`;
                const numParcelaFutura = parcelaAtual + i;
                
                // Criar m√™s se n√£o existir
                if (!todasContas[chaveFutura]) {
                    todasContas[chaveFutura] = [];
                }
                
                let contasMes = todasContas[chaveFutura];
                let contaFutura = contasMes.find(c => c.nome === nomeConta);
                
                // Criar conta se n√£o existir
                if (!contaFutura) {
                    const contaOriginal = contas.find(c => c.nome === nomeConta);
                    if (contaOriginal) {
                        contaFutura = {
                            ...contaOriginal,
                            id: Date.now() + Math.random(),
                            pessoas: [],
                            pago: false
                        };
                        contasMes.push(contaFutura);
                    }
                }
                
                if (contaFutura) {
                    let pessoaFutura = contaFutura.pessoas.find(p => p.nome === pessoa.nome);
                    
                    if (pessoaFutura && pessoaFutura.compras && pessoaFutura.compras.length > 0) {
                        // ATUALIZAR compras existentes
                        pessoaFutura.compras.forEach(c => {
                            if (c.idUnico === compra.idUnico) {
                                c.valorParcela = novoValorParcela;
                            }
                        });
                        
                        // Recalcular valor total da pessoa
                        pessoaFutura.valor = pessoaFutura.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                        
                        adicionarLog(`      M√™s ${chaveFutura}: Valor ATUALIZADO para R$ ${novoValorParcela.toFixed(2)}`, 'success');
                    } else {
                        // CRIAR nova pessoa com a compra
                        pessoaFutura = {
                            nome: pessoa.nome,
                            valor: novoValorParcela,
                            valorTotal: compra.valorTotal,
                            parcelas: `${numParcelaFutura}/${totalParcelas}`,
                            compras: [{
                                ...compra,
                                valorParcela: novoValorParcela,
                                parcelas: `${numParcelaFutura}/${totalParcelas}`
                            }],
                            pago: false
                        };
                        contaFutura.pessoas.push(pessoaFutura);
                        
                        adicionarLog(`      M√™s ${chaveFutura}: Parcela CRIADA R$ ${novoValorParcela.toFixed(2)}`, 'success');
                    }
                }
            }
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }

        function inicializar() {
            // Verificar vers√£o e fazer migra√ß√£o se necess√°rio
            verificarEMigrarVersao();
            
            carregarTodasContas();
            const dataArmazenada = localStorage.getItem('dataUltimaAtualizacao');
            if (dataArmazenada) {
                dataUltimaAtualizacao = dataArmazenada;
            }
            
            // Carregar o m√™s salvo anteriormente
            const mesAtualSalvo = localStorage.getItem('mesAtualSalvo');
            if (mesAtualSalvo) {
                try {
                    const dadosMes = JSON.parse(mesAtualSalvo);
                    mesAtual = new Date(dadosMes.ano, dadosMes.mes);
                } catch (e) {
                    // Se houver erro, manter o m√™s atual
                    mesAtual = new Date();
                }
            }
            
            // Mostrar/ocultar bot√£o DEBUG baseado na configura√ß√£o
            const btnDebug = document.getElementById('btnDebug');
            if (btnDebug) {
                btnDebug.style.display = MOSTRAR_DEBUG ? 'block' : 'none';
            }
            
            atualizarVisualizacao();
        }
        
        function atualizarVisualizacao() {
            const meses = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho', 
                          'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
            document.getElementById('mesAtual').textContent = `${meses[mesAtual.getMonth()]} de ${mesAtual.getFullYear()}`;
            
            carregarContasMesAtual();
            renderizarContas();
        }

        function getChaveMes() {
            return `${mesAtual.getFullYear()}-${String(mesAtual.getMonth() + 1).padStart(2, '0')}`;
        }
        
        function carregarTodasContas() {
            const dados = localStorage.getItem('todasContas');
            if (dados) {
                try {
                    const dadosCarregados = JSON.parse(dados);
                    
                    // Validar estrutura b√°sica dos dados
                    if (typeof dadosCarregados === 'object' && dadosCarregados !== null) {
                        todasContas = dadosCarregados;
                        
                        // Limpar dados corrompidos ou inv√°lidos
                        Object.keys(todasContas).forEach(chaveMes => {
                            if (!Array.isArray(todasContas[chaveMes])) {
                                delete todasContas[chaveMes];
                            } else {
                                // Validar cada conta
                                todasContas[chaveMes] = todasContas[chaveMes].filter(conta => {
                                    return conta && 
                                           typeof conta === 'object' && 
                                           conta.nome && 
                                           Array.isArray(conta.pessoas);
                                });
                                
                                // Remover m√™s se ficou vazio
                                if (todasContas[chaveMes].length === 0) {
                                    delete todasContas[chaveMes];
                                }
                            }
                        });
                    } else {
                        todasContas = {};
                    }
                } catch (e) {
                    console.error('Erro ao carregar dados. Iniciando limpo.', e);
                    todasContas = {};
                }
            }
        }
        function calcularValorJaPago(nomeConta) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtual] = chaveAtual.split('-').map(Number);
            
            let totalPago = 0;
            
            // Percorre todos os meses anteriores
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                const dataAtualMes = new Date(anoAtual, mesAtual - 1);
                
                // Se for m√™s anterior
                if (dataMes < dataAtualMes) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas.forEach(pessoa => {
                            if (pessoa.pago) {
                                if (pessoa.compras && pessoa.compras.length > 0) {
                                    // Se tem compras detalhadas, soma o valor das parcelas
                                    pessoa.compras.forEach(compra => {
                                        totalPago += compra.valorParcela || 0;
                                    });
                                } else {
                                    // Se n√£o tem compras, usa o valor direto da pessoa
                                    totalPago += pessoa.valor || 0;
                                }
                            }
                        });
                    }
                }
            });
            
            return totalPago;
        }
        function carregarContasMesAtual() {
            const chave = getChaveMes();
            adicionarLog(`üìÇ carregarContasMesAtual() - M√™s: ${chave}`, 'info');
            const [anoAtual, mesAtualNum] = chave.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            // FOR√áAR RECARGA COMPLETA do localStorage
            const dadosStorage = localStorage.getItem('todasContas');
            if (dadosStorage) {
                try {
                    todasContas = JSON.parse(dadosStorage);
                } catch (e) {
                    console.error('Erro ao carregar dados:', e);
                    todasContas = {};
                }
            }
            
            // SEMPRE verificar status de recebimentos em tempo
            if (todasContas[chave]) {
                // M√™s existe - carregar e CONSOLIDAR
                const dadosSalvos = JSON.parse(JSON.stringify(todasContas[chave]));
                contas = [];
                
                // *** CR√çTICO: ANTES de processar, garantir que TODAS as contas de PAGAMENTO existem ***
                const contasNoMesSalvo = new Set(dadosSalvos.map(c => c.nome));
                
                // Buscar no m√™s anterior por contas de PAGAMENTO que n√£o existem neste m√™s
                const chavesOrdenadas = Object.keys(todasContas).sort();
                const indexAtual = chavesOrdenadas.indexOf(chave);
                
                if (indexAtual > 0) {
                    const chaveMesAnterior = chavesOrdenadas[indexAtual - 1];
                    const contasMesAnterior = todasContas[chaveMesAnterior];
                    
                    contasMesAnterior.forEach(contaAnterior => {
                        // Se √© conta de PAGAMENTO E n√£o existe no m√™s atual
                        if (contaAnterior.tipoTransacao !== 'recebimento' && 
                            contaAnterior.tipoTransacao !== 'pagamento-custom' &&
                            !contasNoMesSalvo.has(contaAnterior.nome)) {
                            
                            // Adicionar conta vazia aos dados salvos
                            dadosSalvos.push({
                                ...contaAnterior,
                                id: Date.now() + Math.random(),
                                pessoas: [],
                                pago: false
                            });
                            
                            adicionarLog(`   ‚ú® Conta de PAGAMENTO "${contaAnterior.nome}" adicionada ao m√™s existente`, 'success');
                        }
                    });
                }
                
                // Reprocessar cada conta COM CONSOLIDA√á√ÉO
                dadosSalvos.forEach(contaSalva => {
                    if (contaSalva.tipoTransacao === 'recebimento') {
                        const pessoasFiltradas = [];
                        
                        contaSalva.pessoas.forEach(pessoaSalva => {
                            // 1. Se est√° pago NESTE M√äS, mant√©m vis√≠vel (Hist√≥rico)
                            if (pessoaSalva.pago) {
                                const pCopia = { ...pessoaSalva };
                                if (pessoaSalva._valorPagoReal !== undefined) pCopia._valorPagoReal = pessoaSalva._valorPagoReal;
                                pessoasFiltradas.push(pCopia);
                                return;
                            }

                            // 2. Se N√ÉO est√° pago, verifica se foi quitado em QUALQUER outro m√™s
                            let idRec = '';
                            if (pessoaSalva.compras && pessoaSalva.compras[0]) {
                                idRec = pessoaSalva.compras[0].idUnico || (pessoaSalva.compras[0].nome + '_' + pessoaSalva.compras[0].dataCompra);
                            } else {
                                idRec = pessoaSalva.nome + '_' + contaSalva.nome + '_' + (pessoaSalva.valorTotal || pessoaSalva.valor);
                            }

                            let quitadoEmOutroMes = false;
                            Object.keys(todasContas).forEach(ch => {
                                if (ch === chave) return; // Ignora o m√™s atual
                                const cCheck = todasContas[ch].find(c => c.nome === contaSalva.nome);
                                if (cCheck) {
                                    cCheck.pessoas.forEach(pCheck => {
                                        let idCheck = pCheck.compras && pCheck.compras[0] ? (pCheck.compras[0].idUnico || (pCheck.compras[0].nome + '_' + pCheck.compras[0].dataCompra)) : (pCheck.nome + '_' + cCheck.nome + '_' + (pCheck.valorTotal || pCheck.valor));
                                        
                                        if (idCheck === idRec && pCheck.pago) {
                                            // Se for parcelado, s√≥ oculta se a parcela do outro m√™s for igual ou superior
                                            if (pessoaSalva.parcelas && pCheck.parcelas && pessoaSalva.parcelas !== 'recorrente') {
                                                const nAtu = parseInt(pessoaSalva.parcelas.split('/')[0]);
                                                const nPas = parseInt(pCheck.parcelas.split('/')[0]);
                                                if (nAtu <= nPas) quitadoEmOutroMes = true;
                                            } else if (pessoaSalva.parcelas !== 'recorrente') {
                                                quitadoEmOutroMes = true;
                                            }
                                        }
                                    });
                                }
                            });

                            if (!quitadoEmOutroMes) {
                                pessoasFiltradas.push({ ...pessoaSalva });
                            }
                        });
                        
                        const pessoasConsolidadas = consolidarPessoasPorNome(pessoasFiltradas);
                        contas.push({ ...contaSalva, pessoas: pessoasConsolidadas });
                    } else {
                        // PAGAMENTOS
                        const pessoasConsolidadas = consolidarPessoasPorNome(contaSalva.pessoas);
                        contas.push({ ...contaSalva, pessoas: pessoasConsolidadas });
                    }
                });
                
                // *** IMPORTANTE: Salvar altera√ß√µes se foram adicionadas contas ***
                if (dadosSalvos.length > todasContas[chave].length) {
                    todasContas[chave] = JSON.parse(JSON.stringify(contas));
                    localStorage.setItem('todasContas', JSON.stringify(todasContas));
                    adicionarLog(`   üíæ M√™s atualizado com novas contas de PAGAMENTO`, 'success');
                }
                
            } else {
                // Criar novo m√™s PRESERVANDO A ORDEM das contas
                contas = [];
                const contasMap = new Map();
                
                // PRIMEIRO: Determinar ordem das contas do m√™s mais recente
                let ordemContas = [];
                const chavesOrdenadas = Object.keys(todasContas).sort().reverse();
                
                for (let chaveMesRef of chavesOrdenadas) {
                    if (todasContas[chaveMesRef] && todasContas[chaveMesRef].length > 0) {
                        ordemContas = todasContas[chaveMesRef].map(c => c.nome);
                        break;
                    }
                }
                
                // *** CR√çTICO: PRIMEIRO copiar TODAS as contas do m√™s anterior (incluindo vazias) ***
                const chaveMesAnterior = chavesOrdenadas.length > 0 ? chavesOrdenadas[0] : null;
                if (chaveMesAnterior && todasContas[chaveMesAnterior]) {
                    todasContas[chaveMesAnterior].forEach(contaAnterior => {
                        // *** CORRE√á√ÉO: Copiar TODAS as contas de PAGAMENTO (mesmo vazias) ***
                        if (contaAnterior.tipoTransacao !== 'recebimento' && 
                            contaAnterior.tipoTransacao !== 'pagamento-custom') {
                            
                            contasMap.set(contaAnterior.nome, {
                                ...contaAnterior,
                                id: Date.now() + Math.random(),
                                pessoas: [], // Come√ßar vazio, ser√° preenchido depois se houver parcelas
                                pago: false
                            });
                            
                            adicionarLog(`   üìã Conta de PAGAMENTO "${contaAnterior.nome}" copiada para o novo m√™s`, 'info');
                        }
                    });
                }
                
                // SEGUNDO: Processar parcelas de meses anteriores
                Object.keys(todasContas).sort().forEach(chaveMes => {
                    const [ano, mes] = chaveMes.split('-').map(Number);
                    const dataMes = new Date(ano, mes - 1);
                    
                    if (dataMes < dataAtualMes) {
                        const contasMes = todasContas[chaveMes];
                        const diffMesesDesdeOrigem = (anoAtual - ano) * 12 + (mesAtualNum - mes);
                        
                        contasMes.forEach(conta => {
                            if (!contasMap.has(conta.nome)) {
                                contasMap.set(conta.nome, {
                                    ...conta,
                                    id: Date.now() + Math.random(),
                                    pago: false,
                                    pessoas: []
                                });
                            }
                            
                            const contaAtual = contasMap.get(conta.nome);
                            
                            conta.pessoas.forEach(pessoa => {
                                // RECEBIMENTOS
                                if (conta.tipoTransacao === 'recebimento') {
                                    let idRecebimento = '';
                                    if (pessoa.compras && pessoa.compras[0]) {
                                        idRecebimento = pessoa.compras[0].idUnico || 
                                            (pessoa.compras[0].nome + '_' + pessoa.compras[0].dataCompra);
                                    } else {
                                        idRecebimento = pessoa.nome + '_' + conta.nome + '_' + (pessoa.valorTotal || pessoa.valor);
                                    }
                                    
                                    if (pessoa.parcelas && pessoa.parcelas !== 'recorrente') {
                                        const match = pessoa.parcelas.match(/(\d+)\/(\d+)/);
                                        if (match) {
                                            const parcelaOriginalDoMes = parseInt(match[1]);
                                            const totalParcelas = parseInt(match[2]);
                                            const parcelaNoMesAtual = parcelaOriginalDoMes + diffMesesDesdeOrigem;
                                            
                                            let totalParcelasPagas = 0;
                                            
                                            Object.keys(todasContas).forEach(chaveMesCheck => {
                                                const contasMesCheck = todasContas[chaveMesCheck];
                                                const contaCheck = contasMesCheck.find(c => c.nome === conta.nome);
                                                
                                                if (contaCheck) {
                                                    contaCheck.pessoas.forEach(pCheck => {
                                                        let idCheck = '';
                                                        if (pCheck.compras && pCheck.compras[0]) {
                                                            idCheck = pCheck.compras[0].idUnico || 
                                                                (pCheck.compras[0].nome + '_' + pCheck.compras[0].dataCompra);
                                                        } else {
                                                            idCheck = pCheck.nome + '_' + conta.nome + '_' + (pCheck.valorTotal || pCheck.valor);
                                                        }
                                                        
                                                        if (idCheck === idRecebimento && pCheck.pago) {
                                                            totalParcelasPagas++;
                                                        }
                                                    });
                                                }
                                            });
                                            
                                            // *** CORRE√á√ÉO: S√≥ adicionar se a parcela atual for <= total ***
                                            if (totalParcelasPagas < totalParcelas && parcelaNoMesAtual <= totalParcelas) {
                                                const parcelaParaMostrar = Math.min(parcelaNoMesAtual, totalParcelas);
                                                
                                                if (pessoa.compras && pessoa.compras.length > 0) {
                                                    pessoa.compras.forEach(compra => {
                                                        contaAtual.pessoas.push({
                                                            nome: pessoa.nome,
                                                            valor: compra.valorParcela,
                                                            valorTotal: compra.valorTotal,
                                                            parcelas: `${parcelaParaMostrar}/${totalParcelas}`,
                                                            compras: [{
                                                                ...compra,
                                                                parcelas: `${parcelaParaMostrar}/${totalParcelas}`
                                                            }],
                                                            pago: false
                                                        });
                                                    });
                                                } else {
                                                    contaAtual.pessoas.push({
                                                        ...pessoa,
                                                        parcelas: `${parcelaParaMostrar}/${totalParcelas}`,
                                                        pago: false
                                                    });
                                                }
                                            }
                                        }
                                    } else {
                                        let foiPagoEmMesAnterior = false;
                                        
                                        Object.keys(todasContas).forEach(chaveMesCheck => {
                                            const [anoCheck, mesCheck] = chaveMesCheck.split('-').map(Number);
                                            const dataMesCheck = new Date(anoCheck, mesCheck - 1);
                                            
                                            if (dataMesCheck < dataAtualMes) {
                                                const contasMesCheck = todasContas[chaveMesCheck];
                                                const contaCheck = contasMesCheck.find(c => c.nome === conta.nome);
                                                
                                                if (contaCheck) {
                                                    contaCheck.pessoas.forEach(pCheck => {
                                                        let idCheck = '';
                                                        if (pCheck.compras && pCheck.compras[0]) {
                                                            idCheck = pCheck.compras[0].idUnico || 
                                                                (pCheck.compras[0].nome + '_' + pCheck.compras[0].dataCompra);
                                                        } else {
                                                            idCheck = pCheck.nome + '_' + conta.nome + '_' + (pCheck.valorTotal || pCheck.valor);
                                                        }
                                                        
                                                        if (idCheck === idRecebimento && pCheck.pago) {
                                                            foiPagoEmMesAnterior = true;
                                                        }
                                                    });
                                                }
                                            }
                                        });
                                        
                                        if (pessoa.parcelas === 'recorrente') {
                                            // RECORRENTE: Verifica se j√° existe para evitar duplicatas e atualiza
                                            const idxExistente = contaAtual.pessoas.findIndex(p => p.nome === pessoa.nome && p.parcelas === 'recorrente');
                                            if (idxExistente !== -1) {
                                                contaAtual.pessoas[idxExistente] = { ...pessoa, pago: false };
                                            } else {
                                                contaAtual.pessoas.push({
                                                    ...pessoa,
                                                    pago: false
                                                });
                                            }
                                        } else if (!foiPagoEmMesAnterior) {
                                            contaAtual.pessoas.push({
                                                ...pessoa,
                                                pago: false
                                            });
                                        }
                                    }
                                } else {
                                    // *** CORRE√á√ÉO CR√çTICA: PAGAMENTOS ***
                                    if (pessoa.parcelas === 'recorrente') {
                                        // Verifica se a pessoa recorrente j√° existe na conta para este m√™s
                                        const idxExistente = contaAtual.pessoas.findIndex(p => p.nome === pessoa.nome && p.parcelas === 'recorrente');
                                        if (idxExistente !== -1) {
                                            // Se j√° existe, substitui pela vers√£o mais recente encontrada no hist√≥rico
                                            contaAtual.pessoas[idxExistente] = { ...pessoa, pago: false };
                                        } else {
                                            // Se n√£o existe, adiciona normalmente
                                            contaAtual.pessoas.push({
                                                ...pessoa,
                                                pago: false
                                            });
                                        }
                                    } else if (pessoa.parcelas && pessoa.parcelas.includes('/')) {
                                        const match = pessoa.parcelas.match(/(\d+)\/(\d+)/);
                                        if (match) {
                                            const parcelaOriginalDoMes = parseInt(match[1]);
                                            const totalParcelas = parseInt(match[2]);
                                            
                                            // *** USAR _parcelaBase SE EXISTIR ***
                                            let parcelaBase = parcelaOriginalDoMes;
                                            let mesBase = chaveMes;
                                            
                                            // CR√çTICO: Verificar TODAS as compras da pessoa
                                            if (pessoa.compras && pessoa.compras.length > 0) {
                                                pessoa.compras.forEach(compra => {
                                                    // Usar parcela base SE existir
                                                    let compraParcelaBase = parcelaOriginalDoMes;
                                                    let compraMesBase = chaveMes;
                                                    
                                                    if (compra._parcelaBase && compra._mesBase) {
                                                        compraParcelaBase = compra._parcelaBase;
                                                        compraMesBase = compra._mesBase;
                                                    }
                                                    
                                                    // Calcular diferen√ßa de meses desde o m√™s base DA COMPRA
                                                    const [anoBase, mesBase_] = compraMesBase.split('-').map(Number);
                                                    const diffMesesDesdeMesBase = (anoAtual - anoBase) * 12 + (mesAtualNum - mesBase_);
                                                    
                                                    const parcelaNoMesAtual = compraParcelaBase + diffMesesDesdeMesBase;
                                                    
                                                    // Verificar total de parcelas DA COMPRA ESPEC√çFICA
                                                    const compraMatch = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                                    const compraTotalParc = compraMatch ? parseInt(compraMatch[2]) : totalParcelas;
                                                    
                                                    // *** CORRE√á√ÉO: S√≥ adicionar se for v√°lida E n√£o ultrapassar total ***
                                                    if (parcelaNoMesAtual <= compraTotalParc && parcelaNoMesAtual > 0) {
                                                        contaAtual.pessoas.push({
                                                            nome: pessoa.nome,
                                                            valor: compra.valorParcela,
                                                            valorTotal: compra.valorTotal,
                                                            parcelas: `${parcelaNoMesAtual}/${compraTotalParc}`,
                                                            compras: [{
                                                                ...compra,
                                                                parcelas: `${parcelaNoMesAtual}/${compraTotalParc}`,
                                                                _parcelaBase: compraParcelaBase,
                                                                _mesBase: compraMesBase
                                                            }],
                                                            pago: false
                                                        });
                                                    }
                                                });
                                            } else {
                                                // Sem compras detalhadas - usar l√≥gica antiga
                                                if (pessoa._parcelaBase && pessoa._mesBase) {
                                                    parcelaBase = pessoa._parcelaBase;
                                                    mesBase = pessoa._mesBase;
                                                }
                                                
                                                const [anoBase, mesBase_] = mesBase.split('-').map(Number);
                                                const diffMesesDesdeMesBase = (anoAtual - anoBase) * 12 + (mesAtualNum - mesBase_);
                                                
                                                const parcelaNoMesAtual = parcelaBase + diffMesesDesdeMesBase;
                                                
                                                // *** CORRE√á√ÉO: Verificar limite do total ***
                                                if (parcelaNoMesAtual <= totalParcelas && parcelaNoMesAtual > 0) {
                                                    contaAtual.pessoas.push({
                                                        ...pessoa,
                                                        parcelas: `${parcelaNoMesAtual}/${totalParcelas}`,
                                                        pago: false
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    // *** REMOVIDO: N√£o adicionar mais pessoas sem parcelas aqui ***
                                    // A conta de PAGAMENTO vazia j√° foi criada no in√≠cio
                                }
                            });
                        });
                    }
                });
                
                // Converter Map para array RESPEITANDO A ORDEM
                if (ordemContas.length > 0) {
                    // Usar ordem do m√™s anterior
                    ordemContas.forEach(nomeConta => {
                        if (contasMap.has(nomeConta)) {
                            const conta = contasMap.get(nomeConta);
                            const pessoasConsolidadas = consolidarPessoasPorNome(conta.pessoas);
                            
                            contas.push({
                                ...conta,
                                pessoas: pessoasConsolidadas
                            });
                            
                            contasMap.delete(nomeConta);
                        }
                    });
                    
                    // Adicionar contas novas que n√£o estavam na ordem
                    contasMap.forEach(conta => {
                        const pessoasConsolidadas = consolidarPessoasPorNome(conta.pessoas);
                        
                        contas.push({
                            ...conta,
                            pessoas: pessoasConsolidadas
                        });
                    });
                } else {
                    // Sem ordem de refer√™ncia, usar ordem do Map
                    contasMap.forEach(conta => {
                        const pessoasConsolidadas = consolidarPessoasPorNome(conta.pessoas);
                        
                        contas.push({
                            ...conta,
                            pessoas: pessoasConsolidadas
                        });
                    });
                }
                
                // CR√çTICO: Salvar o novo m√™s criado
                todasContas[chave] = JSON.parse(JSON.stringify(contas));
                localStorage.setItem('todasContas', JSON.stringify(todasContas));
                
                if (contas.length > 0) {
                    adicionarLog(`   ‚úÖ Novo m√™s ${chave} criado e salvo com ${contas.length} contas`, 'success');
                } else {
                    adicionarLog(`   ‚ÑπÔ∏è Novo m√™s ${chave} criado vazio`, 'info');
                }
            }
            
            // *** VERIFICAR CONTAS FINALIZADAS ***
            contas.forEach(conta => {
                const statusConta = verificarContaFinalizada(conta);
                if (statusConta.finalizada) {
                    adicionarLog(`   ‚ö†Ô∏è Conta "${conta.nome}" FINALIZADA detectada (pend√™ncias: ${statusConta.temPendencias})`, 'warning');
                }
            });
            
            adicionarLog(`‚úÖ carregarContasMesAtual() CONCLU√çDA - ${contas.length} contas carregadas`, 'success');
        }
function consolidarPessoasPorNome(pessoas) {
            adicionarLog(`üîÑ consolidarPessoasPorNome() - Entrada: ${pessoas.length} pessoas`, 'info');
            pessoas.forEach((p, i) => {
                adicionarLog(`   ${i+1}. ${p.nome} - Compras: ${p.compras ? p.compras.length : 0}`, 'info');
                if (p.compras) {
                    p.compras.forEach(c => {
                        adicionarLog(`      - ${c.nome} (${c.valorParcela}) - Parceria: ${c._parceria ? 'SIM' : 'N√ÉO'}`, 'info');
                    });
                }
            });
            
            // *** CORRE√á√ÉO: Criar chave √∫nica considerando se √© parceria ou n√£o ***
            const pessoasMap = new Map();
            
            pessoas.forEach(pessoa => {
                // Verificar se tem compras em parceria
                const temCompraParceria = pessoa.compras && pessoa.compras.some(c => c._parceria);
                const temCompraIndividual = pessoa.compras && pessoa.compras.some(c => !c._parceria);
                
                // *** NOVA L√ìGICA: Separar pessoa em parceria da pessoa individual ***
                if (temCompraParceria && temCompraIndividual) {
                    // Tem AMBAS - criar duas entradas separadas
                    
                    // 1. Entrada para compras individuais
                    const chaveIndividual = pessoa.nome + '_individual';
                    if (!pessoasMap.has(chaveIndividual)) {
                        pessoasMap.set(chaveIndividual, {
                            nome: pessoa.nome,
                            valor: 0,
                            valorTotal: 0,
                            parcelas: pessoa.parcelas,
                            compras: [],
                            pago: false,
                            _valorPagoReal: pessoa._valorPagoReal,
                            _tipoEntrada: 'individual',
                            _indiceOriginal: pessoasMap.size // Preservar √≠ndice para identifica√ß√£o
                        });
                    }
                    
                    // 2. Entrada(s) para parceria(s)
                    pessoa.compras.forEach(compra => {
                        if (compra._parceria) {
                            const idBaseParceria = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                            const chaveParceria = pessoa.nome + '_parceria_' + idBaseParceria;
                            
                            if (!pessoasMap.has(chaveParceria)) {
                                pessoasMap.set(chaveParceria, {
                                    nome: pessoa.nome,
                                    valor: 0,
                                    valorTotal: 0,
                                    parcelas: compra.parcelas,
                                    compras: [],
                                    pago: false,
                                    _tipoEntrada: 'parceria',
                                    _idBaseParceria: idBaseParceria,
                                    _indiceOriginal: pessoasMap.size // Preservar √≠ndice
                                });
                            }
                            
                            const pessoaParceria = pessoasMap.get(chaveParceria);
                            pessoaParceria.compras.push({...compra});
                            pessoaParceria.pago = pessoa.pago;
                        } else {
                            // Compra individual
                            const pessoaIndividual = pessoasMap.get(chaveIndividual);
                            pessoaIndividual.compras.push({...compra});
                            pessoaIndividual.pago = pessoa.pago;
                        }
                    });
                    
                } else {
                    // *** CORRE√á√ÉO: Criar chaves √∫nicas para evitar consolida√ß√£o errada ***
                    let chave = pessoa.nome;
                    
                    // Se tem compras, verificar o tipo
                    if (pessoa.compras && pessoa.compras.length > 0) {
                        const ehParceria = pessoa.compras[0]._parceria;
                        
                        if (ehParceria) {
                            // Compra em parceria - usar ID base como parte da chave
                            const idBase = pessoa.compras[0].idUnico.substring(0, pessoa.compras[0].idUnico.lastIndexOf('_'));
                            chave = pessoa.nome + '_parceria_' + idBase;
                        } else {
                            // Compra individual - usar chave diferente
                            chave = pessoa.nome + '_individual';
                        }
                    }
                    
                    if (!pessoasMap.has(chave)) {
                        pessoasMap.set(chave, {
                            nome: pessoa.nome,
                            valor: 0,
                            valorTotal: 0,
                            parcelas: pessoa.parcelas,
                            compras: [],
                            pago: pessoa.pago,
                            _valorPagoReal: pessoa._valorPagoReal,
                            _indiceOriginal: pessoasMap.size
                        });
                    }
                    
                    const pessoaConsolidada = pessoasMap.get(chave);
                    
                    if (pessoa._valorPagoReal !== undefined) {
                        pessoaConsolidada._valorPagoReal = pessoa._valorPagoReal;
                    }
                    
                    if (pessoa.compras && pessoa.compras.length > 0) {
                        pessoa.compras.forEach(compra => {
                            const idCompra = compra.idUnico || (compra.nome + '_' + compra.dataCompra);
                            const jaExiste = pessoaConsolidada.compras.some(c => {
                                const idC = c.idUnico || (c.nome + '_' + c.dataCompra);
                                return idC === idCompra;
                            });
                            
                            if (!jaExiste) {
                                pessoaConsolidada.compras.push({...compra});
                            }
                        });
                    } else {
                        if (pessoa.valor > 0) {
                            const idGenerico = pessoa.nome + '_' + pessoa.valor + '_' + (pessoa.parcelas || 'unico');
                            const jaExiste = pessoaConsolidada.compras.some(c => {
                                const idC = c.idUnico || (c.nome + '_' + c.dataCompra);
                                return idC === idGenerico;
                            });
                            
                            if (!jaExiste) {
                                pessoaConsolidada.compras.push({
                                    nome: 'Valor direto',
                                    valorTotal: pessoa.valorTotal || pessoa.valor,
                                    valorParcela: pessoa.valor,
                                    parcelas: pessoa.parcelas,
                                    dataCompra: new Date().toLocaleDateString('pt-BR'),
                                    idUnico: idGenerico
                                });
                            }
                        }
                    }
                    
                    if (pessoa.pago) {
                        pessoaConsolidada.pago = true;
                    }
                }
            });
            
            // Recalcular valores para todas as entradas
            pessoasMap.forEach(pessoaConsolidada => {
                pessoaConsolidada.valor = pessoaConsolidada.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                pessoaConsolidada.valorTotal = pessoaConsolidada.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
            });
            
            return Array.from(pessoasMap.values());
        }
        
        function verificarRecebimentoPagoTotalmente(nomeConta, pessoa, mesOrigemChave) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            // Criar identificador √∫nico do recebimento
            let idRecebimento = '';
            if (pessoa.compras && pessoa.compras[0]) {
                idRecebimento = pessoa.compras[0].idUnico || 
                    (pessoa.compras[0].nome + '_' + pessoa.compras[0].dataCompra);
            } else {
                idRecebimento = pessoa.nome + '_' + (pessoa.valorTotal || pessoa.valor);
            }
            
            // Para recebimentos parcelados
            if (pessoa.parcelas && pessoa.parcelas !== 'recorrente') {
                const match = pessoa.parcelas.match(/(\d+)\/(\d+)/);
                if (match) {
                    const totalParcelas = parseInt(match[2]);
                    let parcelasPagas = 0;
                    
                    // Verificar em TODOS os meses quantas parcelas foram pagas
                    Object.keys(todasContas).forEach(chaveMes => {
                        const contasMes = todasContas[chaveMes];
                        const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                        
                        if (contaEncontrada) {
                            contaEncontrada.pessoas.forEach(p => {
                                let idAtual = '';
                                if (p.compras && p.compras[0]) {
                                    idAtual = p.compras[0].idUnico || 
                                        (p.compras[0].nome + '_' + p.compras[0].dataCompra);
                                } else {
                                    idAtual = p.nome + '_' + (p.valorTotal || p.valor);
                                }
                                
                                // Se √© o mesmo recebimento E foi marcado como pago
                                if (idAtual === idRecebimento && p.pago) {
                                    parcelasPagas++;
                                }
                            });
                        }
                    });
                    
                    // Considerado totalmente pago se n√∫mero de parcelas pagas >= total
                    return parcelasPagas >= totalParcelas;
                }
            }
            
            // Para recebimentos √∫nicos (sem parcelas)
            let foiPago = false;
            
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(p => {
                        let idAtual = '';
                        if (p.compras && p.compras[0]) {
                            idAtual = p.compras[0].idUnico || 
                                (p.compras[0].nome + '_' + p.compras[0].dataCompra);
                        } else {
                            idAtual = p.nome + '_' + (p.valorTotal || p.valor);
                        }
                        
                        if (idAtual === idRecebimento && p.pago) {
                            foiPago = true;
                        }
                    });
                }
            });
            
            return foiPago;
        }


        function salvarNoStorage() {
            const chave = getChaveMes();
            
            adicionarLog(`üíæ salvarNoStorage() INICIADA - M√™s: ${chave}`, 'info');
            adicionarLog(`   Contas a salvar: ${contas.length}`, 'info');
            
            // *** CORRE√á√ÉO: Preservar pessoas separadas (individual vs parceria) ***
            const contasParaSalvar = contas.map(conta => {
                const contaCopia = {...conta};
                
                // Separar pessoas que foram consolidadas
                const pessoasSeparadas = [];
                
                conta.pessoas.forEach(pessoa => {
                    // Verificar se pessoa tem compras em parceria E individuais
                    const comprasParceria = pessoa.compras ? pessoa.compras.filter(c => c._parceria) : [];
                    const comprasIndividuais = pessoa.compras ? pessoa.compras.filter(c => !c._parceria) : [];
                    
                    if (comprasParceria.length > 0 && comprasIndividuais.length > 0) {
                        // Tem AMBAS - criar entrada separada para cada tipo
                        
                        // 1. Compras individuais
                        pessoasSeparadas.push({
                            nome: pessoa.nome,
                            valor: comprasIndividuais.reduce((sum, c) => sum + (c.valorParcela || 0), 0),
                            valorTotal: comprasIndividuais.reduce((sum, c) => sum + (c.valorTotal || 0), 0),
                            parcelas: comprasIndividuais[0].parcelas,
                            compras: comprasIndividuais,
                            pago: pessoa.pago,
                            _valorPagoReal: pessoa._valorPagoReal,
                            parcelasJaPagas: pessoa.parcelasJaPagas
                        });
                        
                        // 2. Compras em parceria (agrupar por ID base)
                        const parceriasMap = new Map();
                        comprasParceria.forEach(compra => {
                            const idBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                            if (!parceriasMap.has(idBase)) {
                                parceriasMap.set(idBase, []);
                            }
                            parceriasMap.get(idBase).push(compra);
                        });
                        
                        parceriasMap.forEach(comprasGrupo => {
                            pessoasSeparadas.push({
                                nome: pessoa.nome,
                                valor: comprasGrupo.reduce((sum, c) => sum + (c.valorParcela || 0), 0),
                                valorTotal: comprasGrupo.reduce((sum, c) => sum + (c.valorTotal || 0), 0),
                                parcelas: comprasGrupo[0].parcelas,
                                compras: comprasGrupo,
                                pago: pessoa.pago,
                                parcelasJaPagas: pessoa.parcelasJaPagas
                            });
                        });
                        
                    } else {
                        // Apenas um tipo ou sem separa√ß√£o - manter como est√°
                        pessoasSeparadas.push({...pessoa});
                    }
                });
                
                contaCopia.pessoas = pessoasSeparadas;
                
                adicionarLog(`   Conta: ${conta.nome} - Pessoas: ${conta.pessoas.length} ‚Üí Salvas: ${pessoasSeparadas.length}`, 'info');
                
                return contaCopia;
            });
            
            todasContas[chave] = contasParaSalvar;
            dataUltimaAtualizacao = new Date().toISOString();
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
            localStorage.setItem('dataUltimaAtualizacao', dataUltimaAtualizacao);
            localStorage.setItem('mesAtualSalvo', JSON.stringify({
                ano: mesAtual.getFullYear(),
                mes: mesAtual.getMonth()
            }));
            
            adicionarLog(`‚úÖ salvarNoStorage() CONCLU√çDA`, 'success');
        }
        function iniciarLongPress(contaId, pessoaIndex, event) {
            if (event && event.type === 'touchstart') {
                longPressTimer = setTimeout(() => {
                    menuComprasPessoa(contaId, pessoaIndex);
                    longPressTimer = 'ativo';
                }, 700);
            }
        }

        function cancelarLongPress() {
            if (longPressTimer && longPressTimer !== 'ativo') {
                clearTimeout(longPressTimer);
            }
            setTimeout(() => {
                longPressTimer = null;
            }, 100);
        }

        function menuComprasPessoa(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            // Sincroniza o estado para que o clique longo atue como o modo de edi√ß√£o
            contaEditando = conta;
            pessoasTemp = JSON.parse(JSON.stringify(conta.pessoas));
            
            // Identifica o √≠ndice correto no array de pessoas (geralmente √© o mesmo)
            const indexNoTemp = pessoaIndex;

            // Chama a fun√ß√£o mestra de menu que j√° cont√©m toda a l√≥gica de Parcerias e Compras
            abrirMenuPessoaTemp(indexNoTemp);
        }

        function fecharModalMenu() {
            document.getElementById('modalMenu').classList.remove('ativo');
        }
        
        function abrirMenuPessoaTemp(indexTemp) {
            if (!contaEditando) {
                alert('‚ùå Erro: Conta n√£o encontrada!');
                return;
            }
            
            const pessoa = pessoasTemp[indexTemp];
            if (!pessoa) {
                alert('‚ùå Erro: Pessoa n√£o encontrada!');
                return;
            }
            
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && contaEditando.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const tipoTransacao = contaEditando.tipoTransacao === 'recebimento' ? 'entrada' : 'compra';
            const temCompras = pessoa.compras && pessoa.compras.length > 0;
            
            // *** NOVO: Verificar se √© parceria ***
            const ehParceria = temCompras && pessoa.compras[0]._parceria;
            
            document.getElementById('modalMenuTitulo').textContent = `${nomePessoa} - ${contaEditando.nome}`;
            
            let conteudo = '<div class="menu-opcoes">';
            
            // *** CORRE√á√ÉO: S√≥ mostrar "Adicionar Nova Compra" se N√ÉO for parceria ***
            if (!ehParceria) {
                conteudo += `<button class="menu-btn menu-btn-adicionar" onclick="fecharModalMenu(); adicionarCompraParaPessoaTemp(${indexTemp})">‚ûï Adicionar Nova ${tipoTransacao === 'entrada' ? 'Entrada' : 'Compra'}</button>`;
            }
            
            if (temCompras) {
                conteudo += `<button class="menu-btn menu-btn-editar" onclick="fecharModalMenu(); setTimeout(function(){ editarComprasPessoaTemp(${indexTemp}); }, 100);">‚úèÔ∏è Ver/Editar ${tipoTransacao === 'entrada' ? 'Entradas' : 'Compras'}</button>`;
            }
            
            // *** CORRE√á√ÉO: Alterar texto do bot√£o se for parceria ***
            if (ehParceria) {
                conteudo += `<button class="menu-btn" style="background: #dc3545; color: white;" onclick="fecharModalMenu(); excluirParceriaCompletaTemp(${indexTemp})">üóëÔ∏è Excluir Parceria</button>`;
            } else {
                conteudo += `<button class="menu-btn" style="background: #dc3545; color: white;" onclick="fecharModalMenu(); excluirPessoaCompletaTemp(${indexTemp})">üóëÔ∏è Excluir Pessoa</button>`;
            }
            
            conteudo += '<button class="menu-btn menu-btn-cancelar" onclick="fecharModalMenu()">‚úï Cancelar</button>';
            conteudo += '</div>';
            
            document.getElementById('modalMenuConteudo').innerHTML = conteudo;
            document.getElementById('modalMenu').classList.add('ativo');
        }
        
        function adicionarCompraParaPessoaTemp(indexTemp) {
            if (!contaEditando) {
                alert('‚ùå Erro: Conta n√£o encontrada!');
                return;
            }
            
            const pessoaTemp = pessoasTemp[indexTemp];
            if (!pessoaTemp) {
                alert('‚ùå Erro: Pessoa n√£o encontrada!');
                return;
            }
            
            const tipoTransacao = contaEditando.tipoTransacao;
            const tipoLabel = tipoTransacao === 'recebimento' ? 'Entrada' : 'Compra';
            
            let nomePessoa = pessoaTemp.nome;
            if (pessoaTemp.nome === 'Eu' && tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            document.getElementById('modalFormTitulo').textContent = `Adicionar ${tipoLabel} - ${nomePessoa}`;
            
            let conteudo = '<form id="formAdicionarCompraTemp" onsubmit="salvarNovaCompraTemp(event, ' + indexTemp + ')">';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Nome da pessoa/descri√ß√£o:</label>';
            conteudo += `<input type="text" id="nomePessoaTempAddForm" value="${nomePessoa}" readonly style="background: #f0f0f0;">`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += `<label>Nome da ${tipoLabel.toLowerCase()}:</label>`;
            conteudo += '<input type="text" id="nomeCompraTempAddForm" required>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Total:</label>';
            conteudo += '<input type="number" id="valorTotalTempAddForm" step="0.01" required>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>N√∫mero de Parcelas:</label>';
            conteudo += '<input type="number" id="numParcelasTempAddForm" min="1" value="1" required>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="compraEmAndamentoTempAddForm" onchange="toggleParcelasEmAndamentoTempAddForm()">';
            conteudo += '<label for="compraEmAndamentoTempAddForm" style="font-size: 12px;">Compra em andamento</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal" id="grupoParcelasAndamentoTempAddForm" style="display: none;">';
            conteudo += '<label>J√° pagas:</label>';
            conteudo += '<input type="number" id="parcelasJaPagasTempAddForm" min="0" placeholder="0">';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="contaRecorrenteTempAddForm" onchange="toggleContaRecorrenteTempAddForm()">';
            conteudo += '<label for="contaRecorrenteTempAddForm" style="font-size: 12px;">Conta recorrente (√°gua, luz, plano...)</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal" id="grupoPagamentoVariavelTempAddForm" style="display: none;">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="pagamentoVariavelTempAddForm">';
            conteudo += '<label for="pagamentoVariavelTempAddForm" style="font-size: 12px;">üí∞ Pagamento vari√°vel</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Observa√ß√µes:</label>';
            conteudo += '<textarea id="observacoesTempAddForm" placeholder="Ex: Pagamento quinzenal, PIX, etc...&#10;Pressione Enter para nova linha" rows="3" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: \'Segoe UI\', Tahoma, Geneva, Verdana, sans-serif; resize: vertical; transition: border 0.3s;"></textarea>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-acoes-modal">';
            conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">Cancelar</button>';
            conteudo += '<button type="submit" class="btn-salvar-modal">Salvar</button>';
            conteudo += '</div>';
            conteudo += '</form>';
            
            document.getElementById('modalFormConteudo').innerHTML = conteudo;
            document.getElementById('modalForm').classList.add('ativo');
        }
        
        function toggleParcelasEmAndamentoTempAddForm() {
            const checkbox = document.getElementById('compraEmAndamentoTempAddForm');
            const grupoAndamento = document.getElementById('grupoParcelasAndamentoTempAddForm');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }
        
        function toggleContaRecorrenteTempAddForm() {
            const checkbox = document.getElementById('contaRecorrenteTempAddForm');
            const camposParcelas = document.getElementById('numParcelasTempAddForm');
            const checkboxAndamento = document.getElementById('compraEmAndamentoTempAddForm');
            const grupoPagamentoVariavel = document.getElementById('grupoPagamentoVariavelTempAddForm');
            const checkboxPagamentoVariavel = document.getElementById('pagamentoVariavelTempAddForm');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamentoTempAddForm();
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'block';
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'none';
                if (checkboxPagamentoVariavel) checkboxPagamentoVariavel.checked = false;
            }
        }
        
        function salvarNovaCompraTemp(e, indexTemp) {
            e.preventDefault();
            
            if (!contaEditando) {
                alert('‚ùå Erro: Conta n√£o encontrada!');
                return;
            }
            
            const pessoaTemp = pessoasTemp[indexTemp];
            if (!pessoaTemp) {
                alert('‚ùå Erro: Pessoa n√£o encontrada!');
                return;
            }
            
            const nomeCompra = document.getElementById('nomeCompraTempAddForm').value;
            const valorTotal = parseFloat(document.getElementById('valorTotalTempAddForm').value);
            const ehRecorrente = document.getElementById('contaRecorrenteTempAddForm').checked;
            const observacoes = document.getElementById('observacoesTempAddForm').value;
            
            let numParcelas, parcelaAtual, parcelasTexto, valorParcela, jaPagas;
            let parcelaBase = 1;
            const mesBase = getChaveMes();
            
            if (ehRecorrente) {
                numParcelas = 1;
                valorParcela = valorTotal;
                parcelasTexto = 'recorrente';
                jaPagas = 0;
            } else if (document.getElementById('compraEmAndamentoTempAddForm').checked) {
                jaPagas = parseInt(document.getElementById('parcelasJaPagasTempAddForm').value) || 0;
                numParcelas = parseInt(document.getElementById('numParcelasTempAddForm').value) || 1;
                parcelaAtual = jaPagas + 1;
                valorParcela = valorTotal / numParcelas;
                parcelasTexto = numParcelas > 1 ? `${parcelaAtual}/${numParcelas}` : '';
                parcelaBase = parcelaAtual;
            } else {
                numParcelas = parseInt(document.getElementById('numParcelasTempAddForm').value) || 1;
                valorParcela = valorTotal / numParcelas;
                parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                jaPagas = 0;
                parcelaBase = 1;
            }
            
            const dataCompraAtual = new Date().toISOString();
            const idUnicoBase = dataCompraAtual + '_' + nomeCompra;
            const ehPagamentoVariavel = document.getElementById('pagamentoVariavelTempAddForm').checked;
            
            const novaCompra = {
                nome: nomeCompra,
                valorTotal: valorTotal,
                valorParcela: valorParcela,
                parcelas: parcelasTexto,
                dataCompra: new Date().toLocaleDateString('pt-BR'),
                idUnico: idUnicoBase,
                observacoes: observacoes,
                _parcelaBase: parcelaBase,
                _mesBase: mesBase,
                _pagamentoVariavel: ehPagamentoVariavel
            };
            
            // Adicionar a nova compra √† pessoa em pessoasTemp
            if (!pessoaTemp.compras) {
                pessoaTemp.compras = [];
            }
            pessoaTemp.compras.push(novaCompra);
            
            // Recalcular o valor total da pessoa
            pessoaTemp.valor = pessoaTemp.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
            pessoaTemp.valorTotal = pessoaTemp.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
            pessoaTemp.parcelasJaPagas = jaPagas;
            
            renderizarPessoasForm();
            fecharModalForm();

            // Sincroniza e salva apenas se N√ÉO estivermos no modal principal (Clique Longo)
            if (contaEditando && !document.getElementById('modal').classList.contains('ativo')) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
                salvarNoStorage();
                carregarContasMesAtual();
                renderizarContas();
                contaEditando = null;
                pessoasTemp = [];
            } else if (contaEditando) {
                // Se estiver no modal, apenas atualiza a conta em edi√ß√£o
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
            }

            alert('‚úÖ Compra adicionada com sucesso!');
        }
        
        function editarComprasPessoaTemp(indexTemp) {
            if (!contaEditando) return;
            
            const pessoa = pessoasTemp[indexTemp];
            if (!pessoa || !pessoa.compras || pessoa.compras.length === 0) {
                alert('‚ùå Nenhuma compra registrada.');
                return;
            }
            
            // Verifica se √© uma parceria
            const primeiraCompra = pessoa.compras[0];
            const ehParceria = primeiraCompra._parceria;
            
            if (ehParceria) {
                const idBase = primeiraCompra.idUnico.substring(0, primeiraCompra.idUnico.lastIndexOf('_'));
                editarPessoa(indexTemp);
                return;
            }
            
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && contaEditando.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const tipoLabel = contaEditando.tipoTransacao === 'recebimento' ? 'Entrada' : 'Compra';
            document.getElementById('modalMenuTitulo').textContent = `${tipoLabel}s de ${nomePessoa}`;
            
            let conteudo = '<div class="lista-compras">';
            pessoa.compras.forEach((compra, idx) => {
                conteudo += `
                    <div class="compra-item">
                        <div class="compra-item-header">
                            <span class="compra-nome">${compra.nome || 'Sem nome'}</span>
                            <span class="compra-valor">R$ ${compra.valorParcela.toFixed(2)}</span>
                        </div>
                        <div class="compra-info">
                            üìÖ ${compra.dataCompra || 'Data n√£o registrada'}
                            ${compra.parcelas ? ` ‚Ä¢ ${compra.parcelas}` : ''}
                            <br>üí∞ Total: R$ ${compra.valorTotal.toFixed(2)}
                        </div>
                        <div class="compra-acoes">
                            <button class="btn-pequeno btn-editar" onclick="editarCompraEspecificaTemp(${indexTemp}, ${idx})">‚úèÔ∏è Editar</button>
                            <button class="btn-pequeno btn-excluir" onclick="excluirCompraEspecificaTemp(${indexTemp}, ${idx})">üóëÔ∏è Excluir</button>
                        </div>
                    </div>
                `;
            });
            
            conteudo += '</div><div class="menu-opcoes" style="margin-top: 16px;">';
            conteudo += '<button class="menu-btn menu-btn-cancelar" onclick="fecharModalMenu()">‚úï Fechar</button></div>';
            
            document.getElementById('modalMenuConteudo').innerHTML = conteudo;
            document.getElementById('modalMenu').classList.add('ativo');
        }
        
        function editarCompraEspecificaTemp(indexTemp, compraIndex) {
            fecharModalMenu();
            
            if (!contaEditando) return;
            
            const pessoa = pessoasTemp[indexTemp];
            if (!pessoa || !pessoa.compras || !pessoa.compras[compraIndex]) {
                alert('‚ùå Erro: Compra n√£o encontrada!');
                return;
            }
            
            const compra = pessoa.compras[compraIndex];
            
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && contaEditando.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const tipoLabel = contaEditando.tipoTransacao === 'recebimento' ? 'Entrada' : 'Compra';
            const ehRecorrente = compra.parcelas === 'recorrente';
            
            document.getElementById('modalFormTitulo').textContent = `Editar ${tipoLabel} - ${nomePessoa}`;
            
            let conteudo = '<form id="formEditarCompraTemp" onsubmit="salvarEdicaoCompraTemp(event, ' + indexTemp + ', ' + compraIndex + ')">';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Nome da pessoa/descri√ß√£o:</label>';
            conteudo += `<input type="text" value="${nomePessoa}" readonly style="background: #f0f0f0;">`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += `<label>Nome da ${tipoLabel.toLowerCase()}:</label>`;
            conteudo += `<input type="text" id="nomeCompraEditTempForm" value="${compra.nome}" required>`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Total:</label>';
            conteudo += `<input type="number" id="valorTotalEditTempForm" step="0.01" value="${compra.valorTotal}" required>`;
            conteudo += '</div>';
            
            // S√≥ mostrar campo de parcelas se N√ÉO for recorrente
            if (!ehRecorrente) {
                const match = compra.parcelas ? compra.parcelas.match(/\/(\d+)/) : null;
                const numParcelas = match ? match[1] : '1';
                
                conteudo += '<div class="form-grupo-modal" id="campoNumParcelasEditTemp">';
                conteudo += '<label>N√∫mero de Parcelas:</label>';
                conteudo += `<input type="number" id="numParcelasEditTempForm" min="1" value="${numParcelas}" required>`;
                conteudo += '</div>';
            }
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<div class="checkbox-group">';
            conteudo += `<input type="checkbox" id="contaRecorrenteEditTempForm" ${ehRecorrente ? 'checked' : ''} onchange="toggleContaRecorrenteEditTempFormNovo()">`;
            conteudo += '<label for="contaRecorrenteEditTempForm" style="font-size: 12px;">Conta recorrente</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            const ehPagamentoVariavel = compra._pagamentoVariavel || false;
            
            conteudo += `<div class="form-grupo-modal" id="grupoPagamentoVariavelEditTempForm" style="display: ${ehRecorrente ? 'block' : 'none'};">`;
            conteudo += '<div class="checkbox-group">';
            conteudo += `<input type="checkbox" id="pagamentoVariavelEditTempForm" ${ehPagamentoVariavel ? 'checked' : ''}>`;
            conteudo += '<label for="pagamentoVariavelEditTempForm" style="font-size: 12px;">üí∞ Pagamento vari√°vel</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            // Aviso sobre contas recorrentes
            if (ehRecorrente) {
                conteudo += '<div style="background: #e7f3ff; border-left: 4px solid #2196F3; padding: 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; color: #1976D2;">';
                conteudo += '<strong>üí° Conta Recorrente:</strong><br>';
                conteudo += 'Ao alterar o valor, ele ser√° aplicado para este m√™s e todos os meses futuros, mantendo o hist√≥rico dos valores anteriores.';
                conteudo += '</div>';
            }
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Observa√ß√µes:</label>';
            conteudo += `<textarea id="observacoesEditTempForm" rows="3" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; resize: vertical;">${compra.observacoes || ''}</textarea>`;
            conteudo += '</div>';
            
            conteudo += '<div class="form-acoes-modal">';
            conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">Cancelar</button>';
            conteudo += '<button type="submit" class="btn-salvar-modal">Salvar</button>';
            conteudo += '</div>';
            conteudo += '</form>';
            
            document.getElementById('modalFormConteudo').innerHTML = conteudo;
            document.getElementById('modalForm').classList.add('ativo');
        }
        
        function toggleContaRecorrenteEditTempForm() {
            const checkbox = document.getElementById('contaRecorrenteEditTempForm');
            const camposParcelas = document.getElementById('numParcelasEditTempForm');
            const grupoPagamentoVariavel = document.getElementById('grupoPagamentoVariavelEditTempForm');
            const checkboxPagamentoVariavel = document.getElementById('pagamentoVariavelEditTempForm');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'block';
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'none';
                if (checkboxPagamentoVariavel) checkboxPagamentoVariavel.checked = false;
            }
        }
        
        function toggleContaRecorrenteEditTempFormNovo() {
            const checkbox = document.getElementById('contaRecorrenteEditTempForm');
            const campoNumParcelas = document.getElementById('campoNumParcelasEditTemp');
            const grupoPagamentoVariavel = document.getElementById('grupoPagamentoVariavelEditTempForm');
            const checkboxPagamentoVariavel = document.getElementById('pagamentoVariavelEditTempForm');
            
            if (checkbox.checked) {
                // Ocultar campo de parcelas se existir
                if (campoNumParcelas) {
                    campoNumParcelas.style.display = 'none';
                }
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'block';
            } else {
                // Mostrar campo de parcelas se existir
                if (campoNumParcelas) {
                    campoNumParcelas.style.display = 'block';
                }
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'none';
                if (checkboxPagamentoVariavel) checkboxPagamentoVariavel.checked = false;
            }
        }
        
        function salvarEdicaoCompraTemp(e, indexTemp, compraIndex) {
            e.preventDefault();
            
            const pessoa = pessoasTemp[indexTemp];
            if (!pessoa || !pessoa.compras[compraIndex]) return;
            
            const nomeCompra = document.getElementById('nomeCompraEditTempForm').value;
            const valorTotal = parseFloat(document.getElementById('valorTotalEditTempForm').value);
            const ehRecorrente = document.getElementById('contaRecorrenteEditTempForm').checked;
            const observacoes = document.getElementById('observacoesEditTempForm').value;
            const ehPagamentoVariavel = document.getElementById('pagamentoVariavelEditTempForm').checked;
            
            const compraOriginal = pessoa.compras[compraIndex];
            const valorOriginal = compraOriginal.valorTotal;
            const valorMudou = valorOriginal !== valorTotal;
            
            let numParcelas, parcelasTexto, valorParcela;
            
            if (ehRecorrente) {
                numParcelas = 1;
                valorParcela = valorTotal;
                parcelasTexto = 'recorrente';
                
                // *** NOVO SISTEMA: Se √© recorrente E o valor mudou, atualizar apenas meses futuros ***
                if (valorMudou && contaEditando) {
                    adicionarLog(`üí∞ CONTA RECORRENTE - Valor alterado: R$ ${valorOriginal.toFixed(2)} ‚Üí R$ ${valorTotal.toFixed(2)}`, 'importante');
                    
                    const chaveAtual = getChaveMes();
                    const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
                    const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
                    
                    // Atualizar o valor APENAS NO M√äS ATUAL e meses FUTUROS
                    Object.keys(todasContas).forEach(chaveMes => {
                        const [ano, mes] = chaveMes.split('-').map(Number);
                        const dataMes = new Date(ano, mes - 1);
                        
                        // Apenas meses >= ao atual
                        if (dataMes >= dataAtualMes) {
                            const contasMes = todasContas[chaveMes];
                            const contaEncontrada = contasMes.find(c => c.nome === contaEditando.nome);
                            
                            if (contaEncontrada) {
                                contaEncontrada.pessoas.forEach(p => {
                                    if (p.nome === pessoa.nome && p.compras && p.compras.length > 0) {
                                        p.compras.forEach(c => {
                                                // Corrigido: Busca pelo ID ou pelo Nome se for recorrente para garantir a sincronia
                                                if (c.idUnico === compraOriginal.idUnico || (ehRecorrente && c.nome === compraOriginal.nome)) {
                                                    c.valorTotal = valorTotal;
                                                    c.valorParcela = valorTotal;
                                                    c.nome = nomeCompra;
                                                    c.observacoes = observacoes;
                                                    c._pagamentoVariavel = ehPagamentoVariavel;
                                                    
                                                    adicionarLog(`   ‚úÖ M√™s ${chaveMes}: Item "${c.nome}" atualizado para R$ ${valorTotal.toFixed(2)}`, 'success');
                                                }
                                            });
                                        
                                        // Recalcular valor total da pessoa
                                        p.valor = p.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                        p.valorTotal = p.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                                    }
                                });
                            }
                        }
                    });
                    
                    adicionarLog(`‚úÖ Valores atualizados do m√™s ${chaveAtual} em diante`, 'success');
                }
            } else {
                const campoNumParcelas = document.getElementById('numParcelasEditTempForm');
                numParcelas = campoNumParcelas ? parseInt(campoNumParcelas.value) || 1 : 1;
                valorParcela = valorTotal / numParcelas;
                
                // Manter a parcela atual se existir
                if (pessoasTemp[indexTemp].parcelas && pessoasTemp[indexTemp].parcelas !== 'recorrente') {
                    const matchAtual = pessoasTemp[indexTemp].parcelas.match(/(\d+)\/(\d+)/);
                    if (matchAtual) {
                        const parcelaAtualNum = parseInt(matchAtual[1]);
                        parcelasTexto = numParcelas > 1 ? `${parcelaAtualNum}/${numParcelas}` : '';
                        
                        // Preservar parcela base se existir
                        if (!compraOriginal._parcelaBase) {
                            compraOriginal._parcelaBase = parcelaAtualNum;
                            compraOriginal._mesBase = getChaveMes();
                        }
                    } else {
                        parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                    }
                } else {
                    parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                }
            }
            
            // Atualizar a compra no pessoasTemp
            pessoa.compras[compraIndex] = {
                ...compraOriginal,
                nome: nomeCompra,
                valorTotal: valorTotal,
                valorParcela: valorParcela,
                parcelas: parcelasTexto,
                observacoes: observacoes,
                _pagamentoVariavel: ehPagamentoVariavel
            };
            
            // Recalcular valores da pessoa
            pessoa.valor = pessoa.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
            pessoa.valorTotal = pessoa.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
            
            renderizarPessoasForm();
            fecharModalForm();

            // Sincroniza e salva apenas se N√ÉO estivermos no modal principal (Clique Longo)
            if (contaEditando && !document.getElementById('modal').classList.contains('ativo')) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
                salvarNoStorage();
                carregarContasMesAtual();
                renderizarContas();
                contaEditando = null;
                pessoasTemp = [];
            } else if (contaEditando) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
            }
            
            if (ehRecorrente && valorMudou) {
                alert('‚úÖ Valor da conta recorrente atualizado!\n\nüìÖ O novo valor foi aplicado a partir deste m√™s.\nüíæ Os valores anteriores foram mantidos no hist√≥rico.');
            } else {
                alert('‚úÖ Compra editada com sucesso!');
            }
        }
        
        function excluirCompraEspecificaTemp(indexTemp, compraIndex) {
            const pessoa = pessoasTemp[indexTemp];
            if (!pessoa || !pessoa.compras[compraIndex]) return;
            
            const compra = pessoa.compras[compraIndex];
            const confirmar = confirm(`‚ö†Ô∏è Excluir "${compra.nome}"?\n\nEsta a√ß√£o remover√° esta compra de TODOS os meses.\n\nContinuar?`);
            if (!confirmar) return;
            
            fecharModalMenu();
            
            adicionarLog(`üóëÔ∏è EXCLUINDO compra de "Eu" (modo formul√°rio de edi√ß√£o)`, 'importante');
            adicionarLog(`   Pessoa: ${pessoa.nome}`, 'info');
            adicionarLog(`   Compra: ${compra.nome}`, 'info');
            adicionarLog(`   ID √önico: ${compra.idUnico}`, 'info');
            
            // Se estamos editando uma conta, excluir de todos os meses
            if (contaEditando) {
                adicionarLog(`   Conta em edi√ß√£o: ${contaEditando.nome}`, 'info');
                
                // Excluir de todos os meses usando a mesma l√≥gica do clique longo
                excluirCompraDeTodosOsMeses(contaEditando.nome, pessoa.nome, compra.idUnico);
                
                // Atualizar tamb√©m a conta no array contas do m√™s atual
                const indexContaAtual = contas.findIndex(c => c.id === contaEditando.id);
                if (indexContaAtual !== -1) {
                    const pessoaNaContaAtual = contas[indexContaAtual].pessoas.find(p => p.nome === pessoa.nome);
                    if (pessoaNaContaAtual && pessoaNaContaAtual.compras) {
                        pessoaNaContaAtual.compras = pessoaNaContaAtual.compras.filter(c => c.idUnico !== compra.idUnico);
                        
                        // Se n√£o tem mais compras, remover a pessoa da conta
                        if (pessoaNaContaAtual.compras.length === 0) {
                            contas[indexContaAtual].pessoas = contas[indexContaAtual].pessoas.filter(p => p.nome !== pessoa.nome);
                            adicionarLog(`   ‚úÖ Pessoa removida da conta atual (sem compras)`, 'success');
                        } else {
                            // Recalcular valores
                            pessoaNaContaAtual.valor = pessoaNaContaAtual.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                            pessoaNaContaAtual.valorTotal = pessoaNaContaAtual.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                            adicionarLog(`   ‚úÖ Valores recalculados da pessoa na conta atual`, 'success');
                        }
                    }
                }
                
                // Atualizar a conta editando
                const pessoaNaContaEditando = contaEditando.pessoas.find(p => p.nome === pessoa.nome);
                if (pessoaNaContaEditando && pessoaNaContaEditando.compras) {
                    pessoaNaContaEditando.compras = pessoaNaContaEditando.compras.filter(c => c.idUnico !== compra.idUnico);
                    
                    // Se n√£o tem mais compras, remover a pessoa
                    if (pessoaNaContaEditando.compras.length === 0) {
                        contaEditando.pessoas = contaEditando.pessoas.filter(p => p.nome !== pessoa.nome);
                        adicionarLog(`   ‚úÖ Pessoa removida da contaEditando (sem compras)`, 'success');
                    } else {
                        // Recalcular valores
                        pessoaNaContaEditando.valor = pessoaNaContaEditando.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                        pessoaNaContaEditando.valorTotal = pessoaNaContaEditando.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                        adicionarLog(`   ‚úÖ Valores recalculados da pessoa na contaEditando`, 'success');
                    }
                }
            }
            
            // Remover do pessoasTemp
            pessoa.compras.splice(compraIndex, 1);
            
            // Se n√£o tem mais compras, remover a pessoa do temp
            if (pessoa.compras.length === 0) {
                pessoasTemp.splice(indexTemp, 1);
            } else {
                // Recalcular valores no temp
                pessoa.valor = pessoa.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                pessoa.valorTotal = pessoa.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
            }
            
            // Salvar altera√ß√µes IMEDIATAMENTE
            if (contaEditando) {
                adicionarLog(`   üíæ Salvando no storage...`, 'warning');
                salvarNoStorage();
                adicionarLog(`   ‚úÖ Salvo no storage`, 'success');
                
                // Recarregar do storage para garantir consist√™ncia
                const dadosAtualizados = localStorage.getItem('todasContas');
                if (dadosAtualizados) {
                    todasContas = JSON.parse(dadosAtualizados);
                    adicionarLog(`   ‚úÖ todasContas recarregado`, 'success');
                }
                
                // Recarregar o m√™s atual
                carregarContasMesAtual();
                adicionarLog(`   ‚úÖ carregarContasMesAtual() executado`, 'success');
                
                // Renderizar as contas na tela principal
                renderizarContas();
            }
            
            // Renderizar apenas a lista de pessoas do formul√°rio
            renderizarPessoasForm();
            
            adicionarLog(`‚úÖ EXCLUS√ÉO CONCLU√çDA COM SUCESSO!`, 'importante');
            
            alert('‚úÖ Compra exclu√≠da com sucesso de todos os meses!\n\nO formul√°rio permanece aberto para novas edi√ß√µes.');
        }
        
        function excluirPessoaCompletaTemp(indexTemp) {
            if (!contaEditando) {
                // Se n√£o est√° editando conta, apenas remove do temp
                const pessoa = pessoasTemp[indexTemp];
                const confirmar = confirm(`‚ö†Ô∏è Excluir "${pessoa.nome}"?\n\nIsso remover√° a pessoa desta lista tempor√°ria.`);
                if (!confirmar) return;
                
                pessoasTemp.splice(indexTemp, 1);
                renderizarPessoasForm();
                return;
            }
            
            const pessoa = pessoasTemp[indexTemp];
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && contaEditando.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const confirmar = confirm(
                `‚ö†Ô∏è ATEN√á√ÉO!\n\n` +
                `Deseja excluir "${nomePessoa}" completamente?\n\n` +
                `Isso ir√°:\n` +
                `‚úì Remover de todos os meses (presente e futuro)\n` +
                `‚úì Manter pagamentos j√° quitados em meses anteriores\n\n` +
                `Esta a√ß√£o n√£o pode ser desfeita!`
            );
            
            if (!confirmar) return;
            
            adicionarLog(`üóëÔ∏è EXCLUINDO "${nomePessoa}" de TODOS os meses`, 'importante');
            
            // Excluir da conta real em todos os meses
            if (pessoa.compras && pessoa.compras.length > 0) {
                pessoa.compras.forEach(compra => {
                    if (!compra._parceria) {
                        excluirCompraDeTodosOsMeses(contaEditando.nome, pessoa.nome, compra.idUnico);
                    }
                });
            } else {
                removerPessoaDeTodosOsMeses(contaEditando.nome, pessoa.nome);
            }
            
            // Atualizar tamb√©m a conta no array contas do m√™s atual
            const indexContaAtual = contas.findIndex(c => c.id === contaEditando.id);
            if (indexContaAtual !== -1) {
                contas[indexContaAtual].pessoas = contas[indexContaAtual].pessoas.filter(p => p.nome !== pessoa.nome);
            }
            
            // Remover do temp
            pessoasTemp.splice(indexTemp, 1);
            
            // Salvar e atualizar
            salvarNoStorage();
            
            const dadosAtualizados = localStorage.getItem('todasContas');
            if (dadosAtualizados) {
                todasContas = JSON.parse(dadosAtualizados);
            }
            
            carregarContasMesAtual();
            renderizarPessoasForm();
            renderizarContas();
            
            alert(`‚úÖ "${nomePessoa}" exclu√≠do com sucesso!`);
        }
        
        function excluirParceriaCompletaTemp(indexTemp) {
            if (!contaEditando) {
                alert('‚ùå Erro: Conta n√£o encontrada!');
                return;
            }
            
            const pessoaTemp = pessoasTemp[indexTemp];
            if (!pessoaTemp) {
                alert('‚ùå Erro: Pessoa n√£o encontrada!');
                return;
            }
            
            // Verificar se √© realmente uma parceria
            const ehParceria = pessoaTemp.compras && pessoaTemp.compras.length > 0 && pessoaTemp.compras[0]._parceria;
            
            if (!ehParceria) {
                alert('‚ùå Esta pessoa n√£o faz parte de uma parceria!');
                return;
            }
            
            const compra = pessoaTemp.compras[0];
            const nomeCompra = compra.nome;
            const idBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
            
            const confirmar = confirm(
                `‚ö†Ô∏è ATEN√á√ÉO! EXCLUIR PARCERIA COMPLETA\n\n` +
                `Deseja excluir TODA a parceria "${nomeCompra}"?\n\n` +
                `Isso ir√°:\n` +
                `‚úì Remover TODAS as pessoas desta parceria de TODOS os meses\n` +
                `‚úì Manter pagamentos j√° quitados em meses anteriores\n\n` +
                `Esta a√ß√£o n√£o pode ser desfeita!`
            );
            
            if (!confirmar) return;
            
            adicionarLog(`üóëÔ∏è EXCLUINDO PARCERIA COMPLETA: ${nomeCompra}`, 'importante');
            adicionarLog(`   ID Base: ${idBase}`, 'info');
            
            // Encontrar TODAS as pessoas desta parceria em pessoasTemp
            const indicesParaRemover = [];
            pessoasTemp.forEach((p, idx) => {
                if (p.compras && p.compras.length > 0 && p.compras[0]._parceria) {
                    const compraIdBase = p.compras[0].idUnico.substring(0, p.compras[0].idUnico.lastIndexOf('_'));
                    if (compraIdBase === idBase) {
                        indicesParaRemover.push(idx);
                    }
                }
            });
            
            adicionarLog(`   üìä Total de pessoas na parceria: ${indicesParaRemover.length}`, 'info');
            
            // Excluir de TODOS os meses (todasContas)
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            let mesesProcessados = 0;
            let pessoasRemovidas = 0;
            
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === contaEditando.nome);
                
                if (contaEncontrada) {
                    mesesProcessados++;
                    const qtdAntes = contaEncontrada.pessoas.length;
                    
                    // Remover TODAS as pessoas desta parceria
                    contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                        // Se n√£o √© a parceria, manter
                        if (!p.compras || p.compras.length === 0 || !p.compras[0]._parceria) return true;
                        
                        // Verificar se √© desta parceria espec√≠fica
                        const compraIdBase = p.compras[0].idUnico.substring(0, p.compras[0].idUnico.lastIndexOf('_'));
                        
                        // Se N√ÉO √© desta parceria, manter
                        if (compraIdBase !== idBase) return true;
                        
                        // Se √© m√™s ANTERIOR e est√° PAGO, MANTER
                        if (dataMes < dataAtualMes && p.pago) {
                            adicionarLog(`   ‚úì M√™s ${chaveMes}: "${p.nome}" mantido (j√° pago)`, 'success');
                            return true;
                        }
                        
                        // Caso contr√°rio, REMOVER
                        adicionarLog(`   ‚úó M√™s ${chaveMes}: "${p.nome}" removido`, 'warning');
                        pessoasRemovidas++;
                        return false;
                    });
                    
                    if (contaEncontrada.pessoas.length < qtdAntes) {
                        adicionarLog(`   üìä M√™s ${chaveMes}: ${qtdAntes - contaEncontrada.pessoas.length} pessoa(s) removida(s)`, 'warning');
                    }
                    
                    // Recalcular status da conta
                    if (contaEncontrada.pessoas.length === 0) {
                        contaEncontrada.pago = false;
                    } else {
                        const todasPagas = contaEncontrada.pessoas.every(p => p.pago);
                        contaEncontrada.pago = todasPagas;
                    }
                }
            });
            
            adicionarLog(`   üìä Estat√≠sticas:`, 'info');
            adicionarLog(`      Meses processados: ${mesesProcessados}`, 'info');
            adicionarLog(`      Pessoas removidas: ${pessoasRemovidas}`, 'info');
            
            // Atualizar tamb√©m a conta no array contas do m√™s atual
            const indexContaAtual = contas.findIndex(c => c.id === contaEditando.id);
            if (indexContaAtual !== -1) {
                contas[indexContaAtual].pessoas = contas[indexContaAtual].pessoas.filter(p => {
                    if (!p.compras || p.compras.length === 0 || !p.compras[0]._parceria) return true;
                    const compraIdBase = p.compras[0].idUnico.substring(0, p.compras[0].idUnico.lastIndexOf('_'));
                    return compraIdBase !== idBase;
                });
                adicionarLog(`   ‚úÖ Pessoas removidas do array contas`, 'success');
            }
            
            // Atualizar contaEditando
            contaEditando.pessoas = contaEditando.pessoas.filter(p => {
                if (!p.compras || p.compras.length === 0 || !p.compras[0]._parceria) return true;
                const compraIdBase = p.compras[0].idUnico.substring(0, p.compras[0].idUnico.lastIndexOf('_'));
                return compraIdBase !== idBase;
            });
            adicionarLog(`   ‚úÖ contaEditando atualizada`, 'success');
            
            // Remover de pessoasTemp (de tr√°s para frente para n√£o afetar √≠ndices)
            indicesParaRemover.sort((a, b) => b - a).forEach(idx => {
                pessoasTemp.splice(idx, 1);
            });
            adicionarLog(`   ‚úÖ ${indicesParaRemover.length} pessoa(s) removida(s) do pessoasTemp`, 'success');
            
            // Salvar altera√ß√µes IMEDIATAMENTE
            salvarNoStorage();
            adicionarLog(`   ‚úÖ Salvo no storage`, 'success');
            
            // Recarregar do storage
            const dadosAtualizados = localStorage.getItem('todasContas');
            if (dadosAtualizados) {
                todasContas = JSON.parse(dadosAtualizados);
                adicionarLog(`   ‚úÖ todasContas recarregado`, 'success');
            }
            
            // Recarregar o m√™s atual
            carregarContasMesAtual();
            adicionarLog(`   ‚úÖ carregarContasMesAtual() executado`, 'success');
            
            // Renderizar
            renderizarPessoasForm();
            renderizarContas();
            
            adicionarLog(`‚úÖ PARCERIA EXCLU√çDA COM SUCESSO!`, 'importante');
            
            alert(
                `‚úÖ Parceria "${nomeCompra}" exclu√≠da com sucesso!\n\n` +
                `üìä Estat√≠sticas:\n` +
                `‚úó Removidos: ${pessoasRemovidas} registros\n\n` +
                `O formul√°rio permanece aberto para novas edi√ß√µes.`
            );
        }
        
        function excluirPessoaDeTodosOsMesesTemp(nomeConta, nomePessoa) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                        if (p.nome !== nomePessoa) return true;
                        
                        // Manter apenas se for m√™s anterior E estiver pago
                        if (dataMes < dataAtualMes && p.pago) {
                            return true;
                        }
                        
                        return false;
                    });
                    
                    // Recalcular status da conta
                    if (contaEncontrada.pessoas.length === 0) {
                        contaEncontrada.pago = false;
                    } else {
                        const todasPagas = contaEncontrada.pessoas.every(p => p.pago);
                        contaEncontrada.pago = todasPagas;
                    }
                }
            });
            
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }
        
        function confirmarExclusaoPessoa(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && conta.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const confirmar = confirm(
                `‚ö†Ô∏è ATEN√á√ÉO!\n\n` +
                `Deseja excluir "${nomePessoa}" completamente?\n\n` +
                `Isso ir√°:\n` +
                `‚úì Remover todas as compras/pend√™ncias FUTURAS e PRESENTES\n` +
                `‚úì Manter o registro de pagamentos J√Å QUITADOS em meses anteriores\n\n` +
                `Esta a√ß√£o n√£o pode ser desfeita!`
            );
            
            if (!confirmar) return;
            
            adicionarLog(`üóëÔ∏è EXCLUINDO PESSOA: ${nomePessoa} da conta ${conta.nome}`, 'importante');
            
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            let pessoasRemovidas = 0;
            let pessoasMantidas = 0;
            
            // Percorrer TODOS os meses
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                
                if (contaEncontrada) {
                    const qtdAntes = contaEncontrada.pessoas.length;
                    
                    // Remover pessoa SE: n√£o estiver paga OU se for o m√™s atual ou futuro
                    contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                        // Se n√£o √© a pessoa que queremos excluir, manter
                        if (p.nome !== pessoa.nome) return true;
                        
                        // Se √© m√™s ANTERIOR e est√° PAGO, MANTER
                        if (dataMes < dataAtualMes && p.pago) {
                            adicionarLog(`   ‚úì M√™s ${chaveMes}: "${p.nome}" mantido (j√° pago)`, 'success');
                            pessoasMantidas++;
                            return true;
                        }
                        
                        // Caso contr√°rio, REMOVER
                        adicionarLog(`   ‚úó M√™s ${chaveMes}: "${p.nome}" removido`, 'warning');
                        pessoasRemovidas++;
                        return false;
                    });
                    
                    // Se a conta ficou sem pessoas, recalcular status
                    if (contaEncontrada.pessoas.length === 0) {
                        contaEncontrada.pago = false;
                    } else {
                        // Recalcular se todas est√£o pagas
                        const todasPagas = contaEncontrada.pessoas.every(p => p.pago);
                        contaEncontrada.pago = todasPagas;
                    }
                }
            });
            
            adicionarLog(`üìä Resultado: ${pessoasRemovidas} registros removidos, ${pessoasMantidas} mantidos`, 'importante');
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
            
            // Recarregar dados atualizados
            const dadosAtualizados = localStorage.getItem('todasContas');
            if (dadosAtualizados) {
                todasContas = JSON.parse(dadosAtualizados);
            }
            
            carregarContasMesAtual();
            renderizarContas();
            
            alert(
                `‚úÖ "${nomePessoa}" exclu√≠do com sucesso!\n\n` +
                `üìä Estat√≠sticas:\n` +
                `‚úó Removidos: ${pessoasRemovidas} registros\n` +
                `‚úì Mantidos: ${pessoasMantidas} pagamentos quitados`
            );
        }
        
        function fecharModalPendencias() {
            document.getElementById('modalPendencias').classList.remove('ativo');
        }
        function fecharModalDetalhes() {
            document.getElementById('modalDetalhes').classList.remove('ativo');
        }
        function fecharModalResumoDetalhado() {
            document.getElementById('modalResumoDetalhado').classList.remove('ativo');
        }
        function fecharModalValor() {
            document.getElementById('modalValor').classList.remove('ativo');
        }
        function fecharModalResumo() {
            document.getElementById('modalResumo').classList.remove('ativo');
        }
        function iniciarLongPressLimpar(event) {
            if (event.type === 'touchstart' || event.type === 'mousedown') {
                longPressTimerLimpar = setTimeout(() => {
                    abrirModalLimpar();
                    longPressTimerLimpar = 'ativo';
                }, 2000); // 2 segundos de press√£o
            }
        }

        function cancelarLongPressLimpar() {
            if (longPressTimerLimpar && longPressTimerLimpar !== 'ativo') {
                clearTimeout(longPressTimerLimpar);
            }
            setTimeout(() => {
                longPressTimerLimpar = null;
            }, 100);
        }

        function abrirModalLimpar() {
            document.getElementById('modalLimpar').classList.add('ativo');
        }

        function fecharModalLimpar() {
            document.getElementById('modalLimpar').classList.remove('ativo');
        }
function verificarEMigrarVersao() {
            const versaoSalva = localStorage.getItem('versaoGestorFinanceiro');
            
            // Se n√£o tem vers√£o salva ou √© diferente da atual
            if (!versaoSalva) {
                // Primeira vez usando o sistema de vers√£o
                console.log('Inicializando sistema de versionamento...');
                localStorage.setItem('versaoGestorFinanceiro', VERSAO_ATUAL);
                return;
            }
            
            if (versaoSalva !== VERSAO_ATUAL) {
                console.log(`Migra√ß√£o detectada: ${versaoSalva} ‚Üí ${VERSAO_ATUAL}`);
                
                // Fazer backup autom√°tico antes da migra√ß√£o
                fazerBackupAutomatico();
                
                // Executar migra√ß√£o
                migrarDados(versaoSalva, VERSAO_ATUAL);
                
                // Atualizar vers√£o
                localStorage.setItem('versaoGestorFinanceiro', VERSAO_ATUAL);
                
                alert(`‚úÖ Sistema atualizado!\n\nVers√£o anterior: ${versaoSalva}\nVers√£o atual: ${VERSAO_ATUAL}\n\nüíæ Um backup autom√°tico foi criado.`);
            }
        }
        
        function migrarDados(versaoAntiga, versaoNova) {
            console.log('Iniciando migra√ß√£o de dados...');
            
            // Limpar cache e configura√ß√µes antigas (N√ÉO toca nos dados financeiros)
            limparCacheAntigo();
            
            // Aqui voc√™ pode adicionar migra√ß√µes espec√≠ficas para cada vers√£o
            // Exemplo:
            // if (versaoAntiga === '1.0' && versaoNova === '2.0') {
            //     migrarDe1Para2();
            // }
            
            console.log('Migra√ß√£o conclu√≠da com sucesso!');
        }
        
        function limparCacheAntigo() {
            // Lista de chaves que podem ser limpas (cache, configura√ß√µes, etc)
            const chavesParaLimpar = [
                'configInterface',
                'preferenciasVisualizacao',
                'cacheTemporario',
                'ultimaBusca',
                'filtrosAtivos'
                // Adicione aqui outras chaves de cache/configura√ß√£o que voc√™ criar no futuro
            ];
            
            chavesParaLimpar.forEach(chave => {
                if (localStorage.getItem(chave)) {
                    localStorage.removeItem(chave);
                    console.log(`Cache removido: ${chave}`);
                }
            });
        }
        
        function fazerBackupAutomatico() {
            try {
                const agora = new Date();
                const dia = String(agora.getDate()).padStart(2, '0');
                const mes = String(agora.getMonth() + 1).padStart(2, '0');
                const ano = agora.getFullYear();
                const hora = String(agora.getHours()).padStart(2, '0');
                const minuto = String(agora.getMinutes()).padStart(2, '0');
                
                const nomeArquivo = `GF_BACKUP_AUTO_${dia}-${mes}-${ano}_${hora}-${minuto}h.json`;
                
                const dadosBackup = {
                    todasContas: todasContas,
                    mesAtualSalvo: {
                        ano: mesAtual.getFullYear(),
                        mes: mesAtual.getMonth()
                    },
                    dataBackup: agora.toISOString(),
                    versao: localStorage.getItem('versaoGestorFinanceiro') || 'desconhecida',
                    tipo: 'backup_automatico'
                };
                
                const blob = new Blob([JSON.stringify(dadosBackup, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = nomeArquivo;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                console.log('Backup autom√°tico criado:', nomeArquivo);
            } catch (erro) {
                console.error('Erro ao criar backup autom√°tico:', erro);
            }
        }
        function limparApenasCache() {
            const confirmar = confirm(
                'üßπ Limpar Cache e Configura√ß√µes?\n\n' +
                'Isso ir√° remover:\n' +
                '‚Ä¢ Cache antigo\n' +
                '‚Ä¢ Configura√ß√µes de interface\n' +
                '‚Ä¢ Prefer√™ncias antigas\n\n' +
                '‚úÖ SEUS DADOS FINANCEIROS SER√ÉO MANTIDOS!\n\n' +
                'Deseja continuar?'
            );
            
            if (!confirmar) return;
            
            // Limpar apenas cache e configura√ß√µes
            limparCacheAntigo();
            
            // For√ßar atualiza√ß√£o da vers√£o
            localStorage.setItem('versaoGestorFinanceiro', VERSAO_ATUAL);
            
            // Fechar modal
            fecharModalLimpar();
            
            // Confirmar limpeza
            alert('‚úÖ Cache limpo com sucesso!\n\nüßπ Cache e configura√ß√µes antigas foram removidos.\nüíæ Seus dados financeiros est√£o intactos!');
            
            // Recarregar p√°gina para aplicar mudan√ßas
            location.reload();
        }
        
        function confirmarLimpezaTotal() {
            const confirmar = confirm(
                '‚ö†Ô∏è ATEN√á√ÉO! LIMPEZA TOTAL\n\n' +
                'Isso ir√° APAGAR:\n' +
                '‚ùå Todas as contas\n' +
                '‚ùå Todos os meses\n' +
                '‚ùå Todo o hist√≥rico\n' +
                '‚ùå Todas as configura√ß√µes\n\n' +
                'üö® ESTA A√á√ÉO N√ÉO PODE SER DESFEITA!\n\n' +
                'Deseja continuar?'
            );
            
            if (!confirmar) {
                fecharModalLimpar();
                return;
            }
            
            // Limpar TUDO do Gestor Financeiro
            localStorage.removeItem('todasContas');
            localStorage.removeItem('dataUltimaAtualizacao');
            localStorage.removeItem('mesAtualSalvo');
            localStorage.removeItem('versaoGestorFinanceiro');
            limparCacheAntigo();
            
            // Resetar vari√°veis
            todasContas = {};
            contas = [];
            mesAtual = new Date();
            dataUltimaAtualizacao = null;
            
            // Fechar modal
            fecharModalLimpar();
            
            // Atualizar visualiza√ß√£o
            atualizarVisualizacao();
            
            // Confirmar limpeza
            alert('‚úÖ Limpeza total conclu√≠da!\n\nüóëÔ∏è Todos os dados do Gestor Financeiro foram apagados.');
}

        function adicionarCompraEmAndamentoRetroativa(nomeConta, pessoasAtualizadas, parcelasJaPagas) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            adicionarLog(`üì• INICIANDO adicionarCompraEmAndamentoRetroativa()`, 'importante');
            adicionarLog(`   Conta: ${nomeConta}`, 'info');
            adicionarLog(`   Parcelas j√° pagas: ${parcelasJaPagas}`, 'info');
            adicionarLog(`   Pessoas recebidas: ${pessoasAtualizadas.map(p => p.nome).join(', ')}`, 'info');
            
            // PRIMEIRO: Limpar TODOS os meses anteriores ao atual (at√© 12 meses atr√°s)
            pessoasAtualizadas.forEach(pessoaAtualizada => {
                if (pessoaAtualizada.compras && pessoaAtualizada.compras.length > 0) {
                    pessoaAtualizada.compras.forEach(compra => {
                        // Limpar at√© 12 meses anteriores para garantir limpeza total
                        for (let i = 1; i <= 12; i++) {
                            const dataRetroativa = new Date(anoAtual, mesAtualNum - 1 - i, 1);
                            const anoRetro = dataRetroativa.getFullYear();
                            const mesRetro = dataRetroativa.getMonth() + 1;
                            const chaveRetro = `${anoRetro}-${String(mesRetro).padStart(2, '0')}`;
                            
                            if (todasContas[chaveRetro]) {
                                const contasMesRetro = todasContas[chaveRetro];
                                const contaRetro = contasMesRetro.find(c => c.nome === nomeConta);
                                
                                if (contaRetro) {
                                    const qtdAntes = contaRetro.pessoas.length;
                                    
                                    // Remover esta compra espec√≠fica de todas as pessoas com este nome
                                    contaRetro.pessoas = contaRetro.pessoas.filter(p => {
                                        if (p.nome !== pessoaAtualizada.nome) return true;
                                        
                                        // Se tem compras, filtrar apenas a compra espec√≠fica
                                        if (p.compras && p.compras.length > 0) {
                                            p.compras = p.compras.filter(c => c.idUnico !== compra.idUnico);
                                            
                                            // Se ainda tem compras, recalcular valores e manter
                                            if (p.compras.length > 0) {
                                                p.valor = p.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                                p.valorTotal = p.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                                                return true;
                                            }
                                        }
                                        
                                        // Se n√£o tem compras ou ficou vazio, remover
                                        return false;
                                    });
                                    
                                    if (contaRetro.pessoas.length < qtdAntes) {
                                        adicionarLog(`   üóëÔ∏è M√™s ${chaveRetro}: ${qtdAntes - contaRetro.pessoas.length} pessoa(s) removida(s)`, 'warning');
                                    }
                                    
                                    // Se a conta ficou sem pessoas, remover a conta tamb√©m
                                    if (contaRetro.pessoas.length === 0) {
                                        const indexConta = contasMesRetro.findIndex(c => c.nome === nomeConta);
                                        if (indexConta !== -1) {
                                            contasMesRetro.splice(indexConta, 1);
                                            adicionarLog(`   üóëÔ∏è M√™s ${chaveRetro}: Conta removida (sem pessoas)`, 'warning');
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            });
            
            adicionarLog(`   ‚úÖ Limpeza completa de TODOS os meses retroativos conclu√≠da`, 'success');
            
            // SEGUNDO: Adicionar parcelas retroativas APENAS nos meses necess√°rios
            for (let i = 1; i <= parcelasJaPagas; i++) {
                const dataRetroativa = new Date(anoAtual, mesAtualNum - 1 - i, 1);
                const anoRetro = dataRetroativa.getFullYear();
                const mesRetro = dataRetroativa.getMonth() + 1;
                const chaveRetro = `${anoRetro}-${String(mesRetro).padStart(2, '0')}`;
                
                // Criar estrutura do m√™s se n√£o existir
                if (!todasContas[chaveRetro]) {
                    todasContas[chaveRetro] = [];
                }
                
                adicionarLog(`üìÖ Processando m√™s retroativo: ${chaveRetro}`, 'info');
                
                const contasMesRetro = todasContas[chaveRetro];
                let contaRetro = contasMesRetro.find(c => c.nome === nomeConta);
                
                // Se a conta n√£o existe no m√™s retroativo, criar
                if (!contaRetro) {
                    const contaOriginal = contas.find(c => c.nome === nomeConta);
                    if (contaOriginal) {
                        contaRetro = {
                            ...contaOriginal,
                            id: Date.now() + Math.random(),
                            pessoas: [],
                            pago: false
                        };
                        contasMesRetro.push(contaRetro);
                        adicionarLog(`   ‚ú® Conta criada no m√™s ${chaveRetro}`, 'success');
                    }
                }
                
                if (contaRetro) {
                    pessoasAtualizadas.forEach(pessoaAtualizada => {
                        adicionarLog(`   üë§ Processando pessoa: ${pessoaAtualizada.nome}`, 'info');
                        
                        if (pessoaAtualizada.compras && pessoaAtualizada.compras.length > 0) {
                            pessoaAtualizada.compras.forEach(compra => {
                                const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                
                                if (match) {
                                    const parcelaBase = compra._parcelaBase || parseInt(match[1]);
                                    const totalParcelas = parseInt(match[2]);
                                    
                                    // Calcular qual parcela seria neste m√™s retroativo
                                    const parcelaRetro = parcelaBase - i;
                                    
                                    adicionarLog(`      üìä Parcela calculada: ${parcelaRetro}/${totalParcelas} (base: ${parcelaBase}, retroativo: ${i})`, 'info');
                                    
                                    // Se a parcela retroativa √© v√°lida (maior que 0 e menor/igual ao total)
                                    if (parcelaRetro > 0 && parcelaRetro <= totalParcelas) {
                                        // Verificar se j√° existe EXATAMENTE esta compra neste m√™s
                                        const pessoaJaExiste = contaRetro.pessoas.find(p => p.nome === pessoaAtualizada.nome);
                                        
                                        let compraJaExiste = false;
                                        if (pessoaJaExiste && pessoaJaExiste.compras) {
                                            compraJaExiste = pessoaJaExiste.compras.some(c => 
                                                c.idUnico === compra.idUnico && c.parcelas === `${parcelaRetro}/${totalParcelas}`
                                            );
                                        }
                                        
                                        if (!compraJaExiste) {
                                            if (pessoaJaExiste) {
                                                // Pessoa existe - adicionar compra
                                                pessoaJaExiste.compras.push({
                                                    ...compra,
                                                    parcelas: `${parcelaRetro}/${totalParcelas}`,
                                                    _parcelaBase: parcelaBase,
                                                    _mesBase: compra._mesBase || chaveAtual
                                                });
                                                
                                                // Recalcular valores
                                                pessoaJaExiste.valor = pessoaJaExiste.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                                pessoaJaExiste.valorTotal = pessoaJaExiste.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                                                
                                                adicionarLog(`      ‚ûï Compra adicionada √† pessoa existente - Parcela ${parcelaRetro}/${totalParcelas}`, 'success');
                                            } else {
                                                // Pessoa n√£o existe - criar nova
                                                contaRetro.pessoas.push({
                                                    nome: pessoaAtualizada.nome,
                                                    valor: compra.valorParcela,
                                                    valorTotal: compra.valorTotal,
                                                    parcelas: `${parcelaRetro}/${totalParcelas}`,
                                                    compras: [{
                                                        ...compra,
                                                        parcelas: `${parcelaRetro}/${totalParcelas}`,
                                                        _parcelaBase: parcelaBase,
                                                        _mesBase: compra._mesBase || chaveAtual
                                                    }],
                                                    pago: true // Marcar como pago pois s√£o parcelas J√Å PAGAS
                                                });
                                                
                                                adicionarLog(`      ‚ú® Nova pessoa criada - Parcela ${parcelaRetro}/${totalParcelas} MARCADA COMO PAGA`, 'success');
                                            }
                                        } else {
                                            adicionarLog(`      ‚è≠Ô∏è Compra j√° existe neste m√™s, pulando...`, 'info');
                                        }
                                    } else {
                                        adicionarLog(`      ‚ö†Ô∏è Parcela ${parcelaRetro} fora do intervalo v√°lido (1-${totalParcelas})`, 'warning');
                                    }
                                }
                            });
                        }
                    });
                    
                    // Verificar se todas as pessoas est√£o pagas para marcar a conta como paga
                    const todasPagas = contaRetro.pessoas.length > 0 && contaRetro.pessoas.every(p => p.pago);
                    if (todasPagas) {
                        contaRetro.pago = true;
                        adicionarLog(`   ‚úÖ Conta ${nomeConta} marcada como paga no m√™s ${chaveRetro}`, 'success');
                    }
                }
            }
            
            adicionarLog(`‚úÖ adicionarCompraEmAndamentoRetroativa() CONCLU√çDA`, 'importante');
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }
        function propagarEdicaoCompraParaTodosMeses(nomeConta, nomePessoa, compraEditada, parcelaBaseOriginal, mesBaseOriginal) {
            const chaveAtual = getChaveMes();
            
            adicionarLog(`üîÑ propagarEdicaoCompraParaTodosMeses INICIADA`, 'importante');
            adicionarLog(`   Conta: ${nomeConta}, Pessoa: ${nomePessoa}`, 'info');
            adicionarLog(`   Parcela Base: ${parcelaBaseOriginal}, M√™s Base: ${mesBaseOriginal}`, 'info');
            adicionarLog(`   ID da compra: ${compraEditada.idUnico}`, 'info');
            
            // GARANTIR que temos parcela base e m√™s base
            if (!parcelaBaseOriginal || !mesBaseOriginal) {
                adicionarLog(`   ‚ùå ERRO: Faltam informa√ß√µes de parcela base!`, 'error');
                parcelaBaseOriginal = 1;
                mesBaseOriginal = chaveAtual;
            }
            
            // Calcular m√™s base como refer√™ncia
            const [anoBase, mesBase] = mesBaseOriginal.split('-').map(Number);
            
            // DETERMINAR quantos meses precisamos criar
            let mesesNecessarios = 0;
            const match = compraEditada.parcelas ? compraEditada.parcelas.match(/(\d+)\/(\d+)/) : null;
            
            if (match) {
                const totalParcelas = parseInt(match[2]);
                // Quantos meses faltam desde a parcela base at√© o total?
                mesesNecessarios = totalParcelas - parcelaBaseOriginal;
                adicionarLog(`   üìä Total de parcelas: ${totalParcelas}, Parcela base: ${parcelaBaseOriginal}`, 'info');
                adicionarLog(`   üìÖ Meses necess√°rios: ${mesesNecessarios}`, 'info');
            } else if (compraEditada.parcelas === 'recorrente') {
                // Recorrente: criar at√© 12 meses no futuro
                mesesNecessarios = 12;
            }
            
            // CRIAR meses futuros se necess√°rio
            if (mesesNecessarios > 0) {
                for (let i = 0; i <= mesesNecessarios; i++) {
                    const dataFutura = new Date(anoBase, mesBase - 1 + i, 1);
                    const anoFuturo = dataFutura.getFullYear();
                    const mesFuturo = dataFutura.getMonth() + 1;
                    const chaveFutura = `${anoFuturo}-${String(mesFuturo).padStart(2, '0')}`;
                    
                    if (!todasContas[chaveFutura]) {
                        todasContas[chaveFutura] = [];
                        adicionarLog(`   ‚ú® M√™s futuro criado: ${chaveFutura}`, 'success');
                    }
                    
                    // Verificar se a conta existe neste m√™s
                    let contaNoMes = todasContas[chaveFutura].find(c => c.nome === nomeConta);
                    if (!contaNoMes) {
                        // Buscar refer√™ncia da conta no m√™s atual
                        const contaReferencia = contas.find(c => c.nome === nomeConta);
                        if (contaReferencia) {
                            contaNoMes = {
                                ...contaReferencia,
                                id: Date.now() + Math.random(),
                                pessoas: [],
                                pago: false
                            };
                            todasContas[chaveFutura].push(contaNoMes);
                            adicionarLog(`   ‚ú® Conta criada no m√™s ${chaveFutura}`, 'success');
                        }
                    }
                }
            }
            
            adicionarLog(`   üóëÔ∏è FASE 1: Removendo compras antigas de todos os meses`, 'warning');
            
            // Limpar TODAS as ocorr√™ncias antigas desta compra em TODOS os meses primeiro
            let mesesLimpos = 0;
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(pessoaItem => {
                        if (pessoaItem.nome === nomePessoa && pessoaItem.compras) {
                            const qtdAntes = pessoaItem.compras.length;
                            pessoaItem.compras = pessoaItem.compras.filter(c => 
                                c.idUnico !== compraEditada.idUnico
                            );
                            if (qtdAntes !== pessoaItem.compras.length) {
                                mesesLimpos++;
                                adicionarLog(`      M√™s ${chaveMes}: Removida`, 'info');
                            }
                        }
                    });
                }
            });
            
            adicionarLog(`   ‚úÖ ${mesesLimpos} meses limpos`, 'success');
            adicionarLog(`   ‚ûï FASE 2: Adicionando compra editada em todos os meses`, 'warning');
            
            // Agora adicionar a compra editada em todos os meses apropriados
            let mesesAdicionados = 0;
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const diffMesesDesdeBase = (ano - anoBase) * 12 + (mes - mesBase);
                
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    let pessoaEncontrada = contaEncontrada.pessoas.find(p => p.nome === nomePessoa);
                    
                    // Se a pessoa n√£o existe neste m√™s, criar
                    if (!pessoaEncontrada) {
                        pessoaEncontrada = {
                            nome: nomePessoa,
                            valor: 0,
                            valorTotal: 0,
                            compras: [],
                            pago: false
                        };
                        contaEncontrada.pessoas.push(pessoaEncontrada);
                        adicionarLog(`      M√™s ${chaveMes}: Pessoa criada`, 'info');
                    }
                    
                    if (!pessoaEncontrada.compras) {
                        pessoaEncontrada.compras = [];
                    }
                    
                    // Adicionar a compra editada com a parcela correta para este m√™s
                    const match = compraEditada.parcelas ? compraEditada.parcelas.match(/(\d+)\/(\d+)/) : null;
                    
                    if (match) {
                        // Compra parcelada
                        const totalParcelas = parseInt(match[2]);
                        const parcelaParaEsteMes = parcelaBaseOriginal + diffMesesDesdeBase;
                        
                        // S√≥ adicionar se a parcela for v√°lida
                        if (parcelaParaEsteMes > 0 && parcelaParaEsteMes <= totalParcelas) {
                            pessoaEncontrada.compras.push({
                                ...compraEditada,
                                parcelas: `${parcelaParaEsteMes}/${totalParcelas}`,
                                _parcelaBase: parcelaBaseOriginal,
                                _mesBase: mesBaseOriginal
                            });
                            mesesAdicionados++;
                            adicionarLog(`      M√™s ${chaveMes}: Adicionada parcela ${parcelaParaEsteMes}/${totalParcelas}`, 'success');
                        }
                    } else if (compraEditada.parcelas === 'recorrente') {
                        // Compra recorrente
                        pessoaEncontrada.compras.push({
                            ...compraEditada,
                            _parcelaBase: parcelaBaseOriginal,
                            _mesBase: mesBaseOriginal
                        });
                        mesesAdicionados++;
                        adicionarLog(`      M√™s ${chaveMes}: Adicionada (recorrente)`, 'success');
                    } else {
                        // Compra √∫nica - s√≥ no m√™s base
                        if (chaveMes === mesBaseOriginal) {
                            pessoaEncontrada.compras.push({
                                ...compraEditada,
                                _parcelaBase: parcelaBaseOriginal,
                                _mesBase: mesBaseOriginal
                            });
                            mesesAdicionados++;
                            adicionarLog(`      M√™s ${chaveMes}: Adicionada (√∫nica)`, 'success');
                        }
                    }
                    
                    // Recalcular valores da pessoa
                    if (pessoaEncontrada.compras.length > 0) {
                        pessoaEncontrada.valor = pessoaEncontrada.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                        pessoaEncontrada.valorTotal = pessoaEncontrada.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                    } else {
                        // Se n√£o tem mais compras, verificar se pode remover a pessoa
                        const temOutrasCompras = pessoaEncontrada.compras && pessoaEncontrada.compras.length > 0;
                        if (!temOutrasCompras) {
                            contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => p.nome !== nomePessoa);
                        }
                    }
                }
            });
            
            adicionarLog(`   ‚úÖ ${mesesAdicionados} meses adicionados`, 'success');
            
            // FASE 3: Limpar apenas recebimentos quitados (preserva conteiners de pagamento vazios)
            adicionarLog(`   üßπ FASE 3: Verificando limpeza de registros`, 'warning');
            let pessoasRemovidas = 0;
            
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    const qtdAntes = contaEncontrada.pessoas.length;
                    
                    contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                        // Se n√£o √© a pessoa sendo editada, mant√©m
                        if (p.nome !== nomePessoa) return true;
                        
                        // Se for conta de PAGAMENTO, sempre mant√©m o conteiner (mesmo vazio)
                        if (contaEncontrada.tipoTransacao !== 'recebimento') return true;
                        
                        // Para RECEBIMENTOS, remove se n√£o houver mais parcelas/valor
                        const temCompras = p.compras && p.compras.length > 0;
                        const valorTotal = p.compras ? p.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0) : p.valor;
                        
                        return temCompras && valorTotal > 0;
                    });
                    
                    if (contaEncontrada.pessoas.length < qtdAntes) {
                        pessoasRemovidas++;
                        adicionarLog(`      M√™s ${chaveMes}: ‚ùå Recebimento removido (quitado)`, 'warning');
                    }
                }
            });
            
            if (pessoasRemovidas > 0) {
                adicionarLog(`   ‚úÖ ${pessoasRemovidas} pessoas com valor zero removidas`, 'success');
            } else {
                adicionarLog(`   ‚ÑπÔ∏è Nenhuma pessoa com valor zero encontrada`, 'info');
            }
            
            adicionarLog(`‚úÖ propagarEdicaoCompraParaTodosMeses CONCLU√çDA`, 'importante');
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }
        function removerPessoaDeTodosOsMeses(nomeConta, nomePessoa) {
            adicionarLog(`üóëÔ∏è removerPessoaDeTodosOsMeses INICIADA`, 'importante');
            adicionarLog(`   Conta: ${nomeConta}, Pessoa: ${nomePessoa}`, 'info');
            
            let mesesProcessados = 0;
            let pessoasRemovidas = 0;
            
            // M√™s que o usu√°rio est√° visualizando/editando no momento
            const chaveMesAtualReferencia = getChaveMes();
            
            // Percorrer TODOS os meses
            Object.keys(todasContas).forEach(chaveMes => {

                // NOVO: Se o m√™s for anterior ao m√™s que estamos editando, n√£o remove a pessoa (Preserva Hist√≥rico)
                if (chaveMes < chaveMesAtualReferencia) {
                    return;
                }

                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    mesesProcessados++;
                    const qtdAntes = contaEncontrada.pessoas.length;
                    
                    // Remover a pessoa
                    contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => p.nome !== nomePessoa);
                    
                    if (contaEncontrada.pessoas.length < qtdAntes) {
                        pessoasRemovidas++;
                        adicionarLog(`      M√™s ${chaveMes}: Pessoa removida`, 'info');
                    }
                    
                    // Recalcular se a conta est√° totalmente paga
                    if (contaEncontrada.pessoas.length === 0) {
                        contaEncontrada.pago = false;
                    } else {
                        const todasPagas = contaEncontrada.pessoas.every(p => p.pago);
                        contaEncontrada.pago = todasPagas;
                    }
                }
            });
            
            adicionarLog(`   üìä Estat√≠sticas:`, 'info');
            adicionarLog(`      Meses processados: ${mesesProcessados}`, 'info');
            adicionarLog(`      Pessoas removidas: ${pessoasRemovidas}`, 'info');
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
            adicionarLog(`   ‚úÖ Altera√ß√µes salvas no localStorage`, 'success');
            adicionarLog(`‚úÖ removerPessoaDeTodosOsMeses CONCLU√çDA`, 'importante');
        }
        function excluirCompraDeTodosOsMeses(nomeConta, nomePessoa, idUnicoCompra) {
            adicionarLog(`üóëÔ∏è excluirCompraDeTodosOsMeses INICIADA`, 'importante');
            adicionarLog(`   Conta: ${nomeConta}, Pessoa: ${nomePessoa}`, 'info');
            adicionarLog(`   ID da compra: ${idUnicoCompra}`, 'info');
            
            let mesesProcessados = 0;
            let comprasRemovidas = 0;
            let pessoasRemovidas = 0;
            
            // M√™s que o usu√°rio est√° visualizando/editando no momento
            const chaveMesAtualReferencia = getChaveMes();

            // Percorrer TODOS os meses
            Object.keys(todasContas).forEach(chaveMes => {
                
                // NOVO: Se o m√™s for anterior ao m√™s que estamos editando, n√£o apaga nada (Preserva Hist√≥rico)
                if (chaveMes < chaveMesAtualReferencia) {
                    return;
                }

                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                
                if (contaEncontrada) {
                    mesesProcessados++;
                    
                    // Usar um array para armazenar √≠ndices a remover (de tr√°s para frente)
                    const pessoasParaRemover = [];
                    
                    contaEncontrada.pessoas.forEach((pessoa, pessoaIdx) => {
                        if (pessoa.nome === nomePessoa && pessoa.compras) {
                            const qtdComprasAntes = pessoa.compras.length;
                            
                            // Filtrar removendo a compra
                            pessoa.compras = pessoa.compras.filter(c => c.idUnico !== idUnicoCompra);
                            
                            if (pessoa.compras.length < qtdComprasAntes) {
                                comprasRemovidas++;
                                adicionarLog(`      M√™s ${chaveMes}: Compra removida`, 'info');
                            }
                            
                            // Recalcular valor da pessoa
                            if (pessoa.compras.length > 0) {
                                pessoa.valor = pessoa.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                pessoa.valorTotal = pessoa.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                            } else {
                                // Se n√£o tem mais compras, marcar para remover
                                pessoasParaRemover.push(pessoaIdx);
                            }
                        }
                    });
                    
                    // Remover pessoas sem compras (de tr√°s para frente para n√£o afetar √≠ndices)
                    for (let i = pessoasParaRemover.length - 1; i >= 0; i--) {
                        contaEncontrada.pessoas.splice(pessoasParaRemover[i], 1);
                        pessoasRemovidas++;
                        adicionarLog(`      M√™s ${chaveMes}: Pessoa removida (sem compras)`, 'warning');
                    }
                    
                    // Se a conta ficou sem pessoas, recalcular status de pagamento
                    if (contaEncontrada.pessoas.length === 0) {
                        contaEncontrada.pago = false;
                    } else {
                        // Recalcular se a conta est√° totalmente paga
                        const todasPagas = contaEncontrada.pessoas.every(p => p.pago);
                        contaEncontrada.pago = todasPagas;
                    }
                }
            });
            
            adicionarLog(`   üìä Estat√≠sticas:`, 'info');
            adicionarLog(`      Meses processados: ${mesesProcessados}`, 'info');
            adicionarLog(`      Compras removidas: ${comprasRemovidas}`, 'info');
            adicionarLog(`      Pessoas removidas: ${pessoasRemovidas}`, 'info');
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
            adicionarLog(`   ‚úÖ Altera√ß√µes salvas no localStorage`, 'success');
            adicionarLog(`‚úÖ excluirCompraDeTodosOsMeses CONCLU√çDA`, 'importante');
        }
        function propagarComprasParaTodosMeses(nomeConta, pessoasAtualizadas) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            // Descobrir se √© recebimento ou pagamento
            const contaOriginal = contas.find(c => c.nome === nomeConta);
            const ehRecebimento = contaOriginal && contaOriginal.tipoTransacao === 'recebimento';
            
            // *** NOVO: Filtrar apenas pessoas/compras que N√ÉO s√£o pagamento vari√°vel ***
            const pessoasParaPropagar = pessoasAtualizadas.map(pessoa => {
                if (pessoa.compras && pessoa.compras.length > 0) {
                    const comprasNaoVariaveis = pessoa.compras.filter(c => !c._pagamentoVariavel);
                    
                    if (comprasNaoVariaveis.length === 0) {
                        return null; // N√£o propagar esta pessoa
                    }
                    
                    return {
                        ...pessoa,
                        compras: comprasNaoVariaveis
                    };
                }
                return pessoa;
            }).filter(p => p !== null);
            
            // Se n√£o h√° nada para propagar, sair
            if (pessoasParaPropagar.length === 0) {
                return;
            }
            
            // Percorrer todos os meses (futuros E j√° existentes)
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                // Se for m√™s futuro OU atual (mas n√£o o mesmo processamento)
                if (dataMes >= dataAtualMes) {
                    const contasMes = todasContas[chaveMes];
                    const indexConta = contasMes.findIndex(c => c.nome === nomeConta);
                    const diffMeses = (ano - anoAtual) * 12 + (mes - mesAtualNum);
                    
                    if (indexConta !== -1) {
                        const contaFutura = contasMes[indexConta];
                        
                        // Verificar cada pessoa atualizada
                        pessoasAtualizadas.forEach(pessoaAtualizada => {
                            // Para cada compra da pessoa
                            if (pessoaAtualizada.compras && pessoaAtualizada.compras.length > 0) {
                                pessoaAtualizada.compras.forEach(compra => {
                                    // Localizar se a pessoa e a compra j√° existem no m√™s futuro
                                    let pessoaNoFuturo = contaFutura.pessoas.find(p => p.nome === pessoaAtualizada.nome);
                                    let compraNoFuturo = null;
                                    
                                    if (pessoaNoFuturo && pessoaNoFuturo.compras) {
                                        compraNoFuturo = pessoaNoFuturo.compras.find(c => 
                                            c.idUnico === compra.idUnico || 
                                            (c.nome === compra.nome && c.parcelas === compra.parcelas)
                                        );
                                    }

                                    // Se j√° existe no futuro e √© recorrente ou pagamento vari√°vel, ATUALIZA o valor
                                    if (compraNoFuturo && (compra.parcelas === 'recorrente' || compra._pagamentoVariavel)) {
                                        compraNoFuturo.valorParcela = compra.valorParcela;
                                        compraNoFuturo.valorTotal = compra.valorTotal;
                                        compraNoFuturo.observacoes = compra.observacoes;
                                        pessoaNoFuturo.valor = pessoaNoFuturo.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                        pessoaNoFuturo.valorTotal = pessoaNoFuturo.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                                    } 
                                    // Se n√£o existe, ADICIONA (L√≥gica original preservada)
                                    else if (!compraNoFuturo) {
                                        if (ehRecebimento) {
                                            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                            if (match) {
                                                const parcelaOriginal = parseInt(match[1]);
                                                const totalParcelas = parseInt(match[2]);
                                                const parcelaNoMesFuturo = parcelaOriginal + diffMeses;
                                                if (parcelaNoMesFuturo <= totalParcelas && parcelaNoMesFuturo > 0) {
                                                    contaFutura.pessoas.push({
                                                        nome: pessoaAtualizada.nome,
                                                        valor: compra.valorParcela,
                                                        valorTotal: compra.valorTotal,
                                                        parcelas: `${parcelaNoMesFuturo}/${totalParcelas}`,
                                                        compras: [{ ...compra, parcelas: `${parcelaNoMesFuturo}/${totalParcelas}` }],
                                                        pago: false
                                                    });
                                                }
                                            } else if (compra.parcelas === 'recorrente') {
                                                contaFutura.pessoas.push({
                                                    nome: pessoaAtualizada.nome,
                                                    valor: compra.valorParcela,
                                                    valorTotal: compra.valorTotal,
                                                    parcelas: 'recorrente',
                                                    compras: [{...compra}],
                                                    pago: false
                                                });
                                            } else {
                                                contaFutura.pessoas.push({
                                                    nome: pessoaAtualizada.nome,
                                                    valor: compra.valorParcela,
                                                    valorTotal: compra.valorTotal,
                                                    parcelas: '',
                                                    compras: [{...compra}],
                                                    pago: false
                                                });
                                            }
                                        } else {
                                            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                            if (match) {
                                                const parcelaOriginal = parseInt(match[1]);
                                                const totalParcelas = parseInt(match[2]);
                                                const parcelaNoMesFuturo = parcelaOriginal + diffMeses;
                                                if (parcelaNoMesFuturo <= totalParcelas && parcelaNoMesFuturo > 0) {
                                                    contaFutura.pessoas.push({
                                                        nome: pessoaAtualizada.nome,
                                                        valor: compra.valorParcela,
                                                        valorTotal: compra.valorTotal,
                                                        parcelas: `${parcelaNoMesFuturo}/${totalParcelas}`,
                                                        compras: [{ ...compra, parcelas: `${parcelaNoMesFuturo}/${totalParcelas}` }],
                                                        pago: false
                                                    });
                                                }
                                            } else if (pessoaAtualizada.parcelas === 'recorrente') {
                                                contaFutura.pessoas.push({
                                                    nome: pessoaAtualizada.nome,
                                                    valor: compra.valorParcela,
                                                    valorTotal: compra.valorTotal,
                                                    parcelas: 'recorrente',
                                                    compras: [{...compra}],
                                                    pago: false
                                                });
                                            }
                                        }
                                    }
                                });
                            }
                        });
                    } else if (diffMeses > 0) {
                        // Conta n√£o existe neste m√™s futuro - criar ela com as parcelas apropriadas
                        if (contaOriginal) {
                            const novaConta = {
                                ...contaOriginal,
                                id: Date.now() + Math.random(),
                                pago: false,
                                pessoas: []
                            };
                            
                            pessoasAtualizadas.forEach(pessoaAtualizada => {
                                if (pessoaAtualizada.compras && pessoaAtualizada.compras.length > 0) {
                                    pessoaAtualizada.compras.forEach(compra => {
                                        if (ehRecebimento) {
                                            // RECEBIMENTO: Propagar para todos os meses futuros
                                            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                            
                                            if (match) {
                                                const parcelaOriginal = parseInt(match[1]);
                                                const totalParcelas = parseInt(match[2]);
                                                const parcelaNoMesFuturo = parcelaOriginal + diffMeses;
                                                
                                                if (parcelaNoMesFuturo <= totalParcelas && parcelaNoMesFuturo > 0) {
                                                    novaConta.pessoas.push({
                                                        nome: pessoaAtualizada.nome,
                                                        valor: compra.valorParcela,
                                                        valorTotal: compra.valorTotal,
                                                        parcelas: `${parcelaNoMesFuturo}/${totalParcelas}`,
                                                        compras: [{
                                                            ...compra,
                                                            parcelas: `${parcelaNoMesFuturo}/${totalParcelas}`
                                                        }],
                                                        pago: false
                                                    });
                                                }
                                            } else if (compra.parcelas === 'recorrente') {
                                            novaConta.pessoas.push({
                                                nome: pessoaAtualizada.nome,
                                                valor: compra.valorParcela,
                                                valorTotal: compra.valorTotal,
                                                parcelas: 'recorrente',
                                                compras: [{...compra}],
                                                pago: false
                                            });
                                        } else {
                                            // Recebimento sem parcelas
                                            novaConta.pessoas.push({
                                                nome: pessoaAtualizada.nome,
                                                valor: compra.valorParcela,
                                                valorTotal: compra.valorTotal,
                                                parcelas: '',
                                                compras: [{...compra}],
                                                pago: false
                                                });
                                            }
                                        } else {
                                            // PAGAMENTO: L√≥gica original
                                            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                            
                                            if (match) {
                                                const parcelaOriginal = parseInt(match[1]);
                                                const totalParcelas = parseInt(match[2]);
                                                const parcelaNoMesFuturo = parcelaOriginal + diffMeses;
                                                
                                                if (parcelaNoMesFuturo <= totalParcelas && parcelaNoMesFuturo > 0) {
                                                    novaConta.pessoas.push({
                                                        nome: pessoaAtualizada.nome,
                                                        valor: compra.valorParcela,
                                                        valorTotal: compra.valorTotal,
                                                        parcelas: `${parcelaNoMesFuturo}/${totalParcelas}`,
                                                        compras: [{
                                                            ...compra,
                                                            parcelas: `${parcelaNoMesFuturo}/${totalParcelas}`
                                                        }],
                                                        pago: false
                                                    });
                                                }
                                            } else if (pessoaAtualizada.parcelas === 'recorrente') {
                                                novaConta.pessoas.push({
                                                    nome: pessoaAtualizada.nome,
                                                    valor: compra.valorParcela,
                                                    valorTotal: compra.valorTotal,
                                                    parcelas: 'recorrente',
                                                    compras: [{...compra}],
                                                    pago: false
                                                });
                                            }
                                        }
                                    });
                                }
                            });
                            
                            // SEMPRE adicionar conta (mesmo sem pessoas)
                            contasMes.push(novaConta);
                        }
                    }
                }
            });
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
        }
        
        // ========================================
        // SISTEMA DE DEBUG
        // ========================================
        
        function toggleDebug() {
            debugAtivo = !debugAtivo;
            const painel = document.getElementById('painelDebug');
            const btn = document.getElementById('btnDebug');
            
            if (debugAtivo) {
                painel.style.display = 'flex';
                btn.textContent = 'üêõ DEBUG ON';
                btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                
                // Renderizar todos os logs acumulados
                renderizarLogsAcumulados();
                
                adicionarLog('üü¢ DEBUG ABERTO', 'success');
            } else {
                painel.style.display = 'none';
                btn.textContent = 'üêõ DEBUG';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
        }
        
        function renderizarLogsAcumulados() {
            const conteudo = document.getElementById('debugConteudo');
            conteudo.innerHTML = ''; // Limpar conte√∫do antigo
            
            if (debugLogs.length === 0) {
                conteudo.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">Nenhum log registrado ainda...</p>';
                return;
            }
            
            // Renderizar todos os logs acumulados
            debugLogs.forEach(log => {
                let cor = '#333';
                let icone = '‚ÑπÔ∏è';
                let background = '#e7f3ff';
                
                switch(log.tipo) {
                    case 'success':
                        cor = '#28a745';
                        icone = '‚úÖ';
                        background = '#d4edda';
                        break;
                    case 'error':
                        cor = '#dc3545';
                        icone = '‚ùå';
                        background = '#f8d7da';
                        break;
                    case 'warning':
                        cor = '#ffc107';
                        icone = '‚ö†Ô∏è';
                        background = '#fff3cd';
                        break;
                    case 'importante':
                        cor = '#764ba2';
                        icone = 'üî•';
                        background = '#e7d4ff';
                        break;
                }
                
                const logDiv = document.createElement('div');
                logDiv.style.cssText = `margin-bottom: 8px; padding: 8px; background: ${background}; border-left: 4px solid ${cor}; border-radius: 4px; word-wrap: break-word;`;
                logDiv.innerHTML = `
                    <div style="color: #666; font-size: 10px; margin-bottom: 4px;">${log.timestamp}</div>
                    <div style="color: ${cor}; font-weight: bold;">${icone} ${log.mensagem}</div>
                `;
                
                conteudo.appendChild(logDiv);
            });
            
            conteudo.scrollTop = conteudo.scrollHeight;
        }
        
        function fecharDebug() {
            debugAtivo = false;
            document.getElementById('painelDebug').style.display = 'none';
            document.getElementById('btnDebug').textContent = 'üêõ DEBUG';
            document.getElementById('btnDebug').style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        }
        
        function adicionarLog(mensagem, tipo = 'info') {
            // SEMPRE capturar logs, mesmo com debug fechado
            
            const timestamp = new Date().toLocaleTimeString('pt-BR');
            const log = {
                timestamp: timestamp,
                mensagem: mensagem,
                tipo: tipo
            };
            
            debugLogs.push(log);
            
            // S√≥ renderizar se o debug estiver aberto
            if (!debugAtivo) return;
            
            const conteudo = document.getElementById('debugConteudo');
            
            if (debugLogs.length === 1) {
                conteudo.innerHTML = '';
            }
            
            let cor = '#333';
            let icone = '‚ÑπÔ∏è';
            let background = '#e7f3ff';
            
            switch(tipo) {
                case 'success':
                    cor = '#28a745';
                    icone = '‚úÖ';
                    background = '#d4edda';
                    break;
                case 'error':
                    cor = '#dc3545';
                    icone = '‚ùå';
                    background = '#f8d7da';
                    break;
                case 'warning':
                    cor = '#ffc107';
                    icone = '‚ö†Ô∏è';
                    background = '#fff3cd';
                    break;
                case 'importante':
                    cor = '#764ba2';
                    icone = 'üî•';
                    background = '#e7d4ff';
                    break;
            }
            
            const logDiv = document.createElement('div');
            logDiv.style.cssText = `margin-bottom: 8px; padding: 8px; background: ${background}; border-left: 4px solid ${cor}; border-radius: 4px; word-wrap: break-word;`;
            logDiv.innerHTML = `
                <div style="color: #666; font-size: 10px; margin-bottom: 4px;">${timestamp}</div>
                <div style="color: ${cor}; font-weight: bold;">${icone} ${mensagem}</div>
            `;
            
            conteudo.appendChild(logDiv);
            conteudo.scrollTop = conteudo.scrollHeight;
        }
        
        function copiarLog() {
            let textoLog = '=== LOG DE DEBUG - GESTOR FINANCEIRO ===\n\n';
            
            debugLogs.forEach(log => {
                textoLog += `[${log.timestamp}] ${log.mensagem}\n`;
            });
            
            textoLog += '\n=== FIM DO LOG ===';
            
            // M√©todo alternativo para copiar (funciona em mais navegadores)
            const textarea = document.createElement('textarea');
            textarea.value = textoLog;
            textarea.style.position = 'fixed';
            textarea.style.top = '-9999px';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            
            try {
                textarea.select();
                textarea.setSelectionRange(0, 99999); // Para mobile
                
                const sucesso = document.execCommand('copy');
                
                if (sucesso) {
                    alert('‚úÖ Log copiado para a √°rea de transfer√™ncia!');
                } else {
                    // Se falhar, mostrar o log em um modal para copiar manualmente
                    mostrarLogParaCopiar(textoLog);
                }
            } catch (err) {
                // Se der erro, mostrar o log em um modal para copiar manualmente
                mostrarLogParaCopiar(textoLog);
            } finally {
                document.body.removeChild(textarea);
            }
        }
        
        function mostrarLogParaCopiar(textoLog) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const conteudo = document.createElement('div');
            conteudo.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 90%;
                max-height: 80vh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            `;
            
            const titulo = document.createElement('h3');
            titulo.textContent = 'üìã Copie o log manualmente';
            titulo.style.cssText = 'margin-bottom: 10px; color: #333;';
            
            const textarea = document.createElement('textarea');
            textarea.value = textoLog;
            textarea.style.cssText = `
                width: 100%;
                height: 400px;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 10px;
                border: 2px solid #667eea;
                border-radius: 6px;
                resize: none;
                margin-bottom: 10px;
            `;
            textarea.readOnly = true;
            
            const btnFechar = document.createElement('button');
            btnFechar.textContent = '‚úï Fechar';
            btnFechar.style.cssText = `
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
            `;
            btnFechar.onclick = () => document.body.removeChild(modal);
            
            conteudo.appendChild(titulo);
            conteudo.appendChild(textarea);
            conteudo.appendChild(btnFechar);
            modal.appendChild(conteudo);
            document.body.appendChild(modal);
            
            // Selecionar todo o texto automaticamente
            textarea.select();
        }
        
        function limparLog() {
            debugLogs = [];
            document.getElementById('debugConteudo').innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">Log limpo. Aguardando novas a√ß√µes...</p>';
            adicionarLog('üßπ Log limpo', 'warning');
        }
        // ========================================
        // TORNAR PAINEL DE DEBUG ARRAST√ÅVEL
        // ========================================
        let debugDragging = false;
        let debugStartX, debugStartY, debugInitialX, debugInitialY;

        document.addEventListener('DOMContentLoaded', function() {
            const debugPanel = document.getElementById('painelDebug');
            const debugHeader = document.getElementById('debugHeader');
            
            if (!debugHeader || !debugPanel) return;
            
            debugHeader.addEventListener('mousedown', startDragDebug);
            debugHeader.addEventListener('touchstart', startDragDebug);
            
            document.addEventListener('mousemove', dragDebug);
            document.addEventListener('touchmove', dragDebug);
            
            document.addEventListener('mouseup', stopDragDebug);
            document.addEventListener('touchend', stopDragDebug);
            
            function startDragDebug(e) {
                debugDragging = true;
                
                const rect = debugPanel.getBoundingClientRect();
                debugInitialX = rect.left;
                debugInitialY = rect.top;
                
                if (e.type === 'touchstart') {
                    debugStartX = e.touches[0].clientX;
                    debugStartY = e.touches[0].clientY;
                } else {
                    debugStartX = e.clientX;
                    debugStartY = e.clientY;
                }
                
                debugHeader.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function dragDebug(e) {
                if (!debugDragging) return;
                
                let currentX, currentY;
                
                if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX;
                    currentY = e.touches[0].clientY;
                } else {
                    currentX = e.clientX;
                    currentY = e.clientY;
                }
                
                const deltaX = currentX - debugStartX;
                const deltaY = currentY - debugStartY;
                
                const newX = debugInitialX + deltaX;
                const newY = debugInitialY + deltaY;
                
                // Limites da tela
                const maxX = window.innerWidth - debugPanel.offsetWidth;
                const maxY = window.innerHeight - debugPanel.offsetHeight;
                
                const boundedX = Math.max(0, Math.min(newX, maxX));
                const boundedY = Math.max(0, Math.min(newY, maxY));
                
                debugPanel.style.left = boundedX + 'px';
                debugPanel.style.top = boundedY + 'px';
                
                e.preventDefault();
            }
            
            function stopDragDebug() {
                if (debugDragging) {
                    debugDragging = false;
                    debugHeader.style.cursor = 'move';
                }
            }
        });
        function toggleMenuBackup() {
            const menu = document.getElementById('menuBackup');
            menu.classList.toggle('ativo');
        }

        function salvarBackup() {
            const agora = new Date();
            const dia = String(agora.getDate()).padStart(2, '0');
            const mes = String(agora.getMonth() + 1).padStart(2, '0');
            const ano = agora.getFullYear();
            const hora = String(agora.getHours()).padStart(2, '0');
            const minuto = String(agora.getMinutes()).padStart(2, '0');
            const segundo = String(agora.getSeconds()).padStart(2, '0');
            
            const nomeArquivo = `GF_${dia}-${mes}-${ano}_${hora}-${minuto}-${segundo}h.json`;
            
            const dadosBackup = {
                todasContas: todasContas,
                mesAtualSalvo: {
                    ano: mesAtual.getFullYear(),
                    mes: mesAtual.getMonth()
                },
                dataBackup: agora.toISOString(),
                versao: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(dadosBackup, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = nomeArquivo;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            toggleMenuBackup();
            alert('‚úÖ Backup salvo com sucesso!\n\nüìÅ Arquivo: ' + nomeArquivo);
        }

        function carregarBackup(event) {
            const arquivo = event.target.files[0];
            if (!arquivo) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const dadosBackup = JSON.parse(e.target.result);
                    
                    // Validar estrutura do backup
                    if (!dadosBackup.todasContas || typeof dadosBackup.todasContas !== 'object') {
                        alert('‚ùå Erro: Arquivo de backup inv√°lido!');
                        return;
                    }
                    
                    // Se j√° existem dados, perguntar antes de substituir
                    if (Object.keys(todasContas).length > 0 && dataUltimaAtualizacao) {
                        const dataAtual = new Date(dataUltimaAtualizacao);
                        const dataFormatada = dataAtual.toLocaleDateString('pt-BR') + ' √†s ' + dataAtual.toLocaleTimeString('pt-BR');
                        
                        const confirmar = confirm(
                            `‚ö†Ô∏è ATEN√á√ÉO!\n\n` +
                            `Voc√™ est√° prestes a SUBSTITUIR os dados atuais.\n\n` +
                            `üìä Dados atuais salvos em:\n${dataFormatada}\n\n` +
                            `Deseja continuar?`
                        );
                        
                        if (!confirmar) {
                            event.target.value = '';
                            toggleMenuBackup();
                            return;
                        }
                    }
                    
                    // Carregar o backup
                    todasContas = dadosBackup.todasContas;
                    localStorage.setItem('todasContas', JSON.stringify(todasContas));
                    
                    // Carregar o m√™s salvo no backup
                    if (dadosBackup.mesAtualSalvo) {
                        mesAtual = new Date(dadosBackup.mesAtualSalvo.ano, dadosBackup.mesAtualSalvo.mes);
                        localStorage.setItem('mesAtualSalvo', JSON.stringify(dadosBackup.mesAtualSalvo));
                    }
                    
                    // Atualizar visualiza√ß√£o
                    atualizarVisualizacao();
                    
                    toggleMenuBackup();
                    event.target.value = '';
                    
                    const dataBackup = new Date(dadosBackup.dataBackup);
                    const dataBackupFormatada = dataBackup.toLocaleDateString('pt-BR') + ' √†s ' + dataBackup.toLocaleTimeString('pt-BR');
                    
                    alert(`‚úÖ Backup carregado com sucesso!\n\nüìÖ Data do backup: ${dataBackupFormatada}`);
                    
                } catch (erro) {
                    alert('‚ùå Erro ao carregar backup: Arquivo corrompido ou inv√°lido!');
                    console.error('Erro:', erro);
                }
            };
            
            reader.readAsText(arquivo);
        }

        // Fechar menu de backup ao clicar fora
        document.addEventListener('click', function(event) {
            const menuBackup = document.getElementById('menuBackup');
            const btnBackup = document.querySelector('.btn-backup');
            
            if (menuBackup && btnBackup && 
                !menuBackup.contains(event.target) && 
                !btnBackup.contains(event.target)) {
                menuBackup.classList.remove('ativo');
            }
        });
function adicionarNovaCompra(contaId) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            contaEditando = conta;
            pessoasTemp = [];
            
            document.getElementById('modalTitulo').textContent = `Adicionar Compra em: ${conta.nome}`;
            document.getElementById('formConta').reset();
            document.getElementById('nomeConta').value = conta.nome;
            document.getElementById('nomeConta').disabled = true;
            document.getElementById('tipoTransacao').value = conta.tipoTransacao;
            document.getElementById('tipoTransacao').disabled = true;
            document.getElementById('tipoConta').value = conta.tipo;
            document.getElementById('tipoConta').disabled = true;
            document.getElementById('limiteTotal').value = conta.limiteTotal || '';
            document.getElementById('limiteTotal').disabled = true;
            document.getElementById('diaFechamento').value = conta.diaFechamento || '';
            document.getElementById('diaFechamento').disabled = true;
            document.getElementById('diaVencimento').value = conta.diaVencimento || '';
            document.getElementById('diaVencimento').disabled = true;
            
            atualizarFormulario();
            atualizarLabelValor();
            renderizarPessoasForm();
            document.getElementById('modal').classList.add('ativo');
        }
        function abrirModal(conta = null) {
            contaEditando = conta;
            pessoasTemp = conta ? JSON.parse(JSON.stringify(conta.pessoas)) : [];
            
            document.getElementById('modalTitulo').textContent = conta ? 'Editar Conta' : 'Adicionar Conta';
            
            if (conta) {
                document.getElementById('nomeConta').value = conta.nome;
                document.getElementById('tipoTransacao').value = conta.tipoTransacao || 'pagamento';
                document.getElementById('tipoConta').value = conta.tipo;
                document.getElementById('limiteTotal').value = conta.limiteTotal || '';
                document.getElementById('diaFechamento').value = conta.diaFechamento ? String(conta.diaFechamento).padStart(2, '0') : '';
                document.getElementById('diaVencimento').value = conta.diaVencimento ? String(conta.diaVencimento).padStart(2, '0') : '';
                document.getElementById('contaPaga').checked = conta.pago;
                document.getElementById('observacoes').value = conta.observacoes || '';
                
                const minhaPessoa = conta.pessoas.find(p => p.nome === 'Eu');
                if (minhaPessoa) {
                    // Limpar campos do "Meu Valor" ao editar (para adicionar apenas outras pessoas)
                    document.getElementById('meuValor').value = '';
                    document.getElementById('nomeCompra').value = '';
                    document.getElementById('numeroParcelas').value = '';
                    document.getElementById('contaRecorrente').checked = false;
                    document.getElementById('compraEmAndamento').checked = false;
                    document.getElementById('numeroParcelas').disabled = false;
                    document.getElementById('compraEmAndamento').disabled = false;
                    toggleParcelasEmAndamento();
                } else {
                    // Se n√£o existir "Eu", campos vazios tamb√©m
                    document.getElementById('meuValor').value = '';
                    document.getElementById('nomeCompra').value = '';
                    document.getElementById('numeroParcelas').value = '';
                }
            } else {
                document.getElementById('formConta').reset();
                pessoasTemp = [];
                document.getElementById('compraEmAndamento').checked = false;
                document.getElementById('contaRecorrente').checked = false;
                document.getElementById('nomeCompra').value = '';
                document.getElementById('numeroParcelas').disabled = false;
                document.getElementById('numeroParcelas').placeholder = '1 ou vazio';
                document.getElementById('compraEmAndamento').disabled = false;
                document.getElementById('contaRecorrente').disabled = false;
                toggleParcelasEmAndamento();
            }
            
            atualizarFormulario();
            renderizarPessoasForm();
            document.getElementById('modal').classList.add('ativo');
        }

        function fecharModal() {
            document.getElementById('modal').classList.remove('ativo');
            document.getElementById('nomeConta').disabled = false;
            document.getElementById('tipoTransacao').disabled = false;
            document.getElementById('tipoConta').disabled = false;
            document.getElementById('limiteTotal').disabled = false;
            document.getElementById('diaFechamento').disabled = false;
            document.getElementById('diaVencimento').disabled = false;
            contaEditando = null;
            pessoasTemp = [];
        }

        function atualizarFormulario() {
            const tipo = document.getElementById('tipoConta').value;
            const tipoTransacao = document.getElementById('tipoTransacao').value;
            const camposCartao = document.getElementById('camposCartao');
            const checkboxAndamento = document.getElementById('compraEmAndamento');
            const checkboxRecorrente = document.getElementById('contaRecorrente');
            const grupoAndamento = document.getElementById('grupoParcelasAndamento');
            const grupoObservacoes = document.getElementById('grupoObservacoes');
            const numeroParcelas = document.getElementById('numeroParcelas');
            
            // Esconder campos de cart√£o se for recebimento/pagamento-custom OU se n√£o for cart√£o
            if (tipoTransacao === 'recebimento' || tipoTransacao === 'pagamento-custom' || tipo !== 'cartao') {
                camposCartao.style.display = 'none';
            } else {
                camposCartao.style.display = 'block';
            }
            
            // Ajuste para exibir op√ß√µes corretamente em Recebimentos e Pagamentos
            if (tipoTransacao === 'recebimento') {
                checkboxAndamento.parentElement.parentElement.style.display = 'none';
                checkboxRecorrente.parentElement.parentElement.style.display = 'block';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                checkboxRecorrente.disabled = false;
            } else {
                checkboxAndamento.parentElement.parentElement.style.display = 'block';
                checkboxRecorrente.parentElement.parentElement.style.display = 'block';
                checkboxAndamento.disabled = false;
                checkboxRecorrente.disabled = false;
            }
            
            // Habilitar campo de parcelas
            numeroParcelas.disabled = false;
            numeroParcelas.placeholder = '1 ou vazio';

            // Ajuste para exibir op√ß√µes corretamente em Recebimentos e Pagamentos
            if (tipoTransacao === 'recebimento') {
                checkboxAndamento.parentElement.parentElement.style.display = 'none';
                checkboxRecorrente.parentElement.parentElement.style.display = 'block';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                checkboxRecorrente.disabled = false;
            } else {
                checkboxAndamento.parentElement.parentElement.style.display = 'block';
                checkboxRecorrente.parentElement.parentElement.style.display = 'block';
                checkboxAndamento.disabled = false;
                checkboxRecorrente.disabled = false;
            }
            
            // Campo de observa√ß√µes sempre vis√≠vel
            grupoObservacoes.style.display = 'block';
        }
        function atualizarLabelValor() {
            const tipoTransacao = document.getElementById('tipoTransacao').value;
            const label = document.getElementById('labelMeuValor');
            
            if (tipoTransacao === 'recebimento') {
                label.textContent = 'Valor Devedor:';
            } else if (tipoTransacao === 'pagamento-custom') {
                label.textContent = 'Meu Valor (custom):';
            } else {
                label.textContent = 'Meu Valor:';
            }
            
            // Chamar atualizarFormulario para ajustar campos de cart√£o
            atualizarFormulario();
        }

        function adicionarPessoa() {
            const tipoTransacao = document.getElementById('tipoTransacao').value;
            const tipoLabel = tipoTransacao === 'recebimento' ? 'Entrada' : 'Compra';
            
            document.getElementById('modalFormTitulo').textContent = `Adicionar Pessoa/${tipoLabel}`;
            
            let conteudo = '<form id="formAdicionarPessoa" onsubmit="salvarNovaPessoa(event)">';
            
            // Checkbox de compra em parceria
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="compraParceriaForm" onchange="toggleCompraParceria()">';
            conteudo += '<label for="compraParceriaForm" style="font-size: 12px;">üë• Compra em parceria</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            // Container para pessoa √∫nica (padr√£o)
            conteudo += '<div id="pessoaUnicaContainer">';
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Nome da pessoa/descri√ß√£o:</label>';
            conteudo += '<input type="text" id="nomePessoaForm" required>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            // Container para parceria (inicialmente oculto)
            conteudo += '<div id="parceriaContainer" style="display: none;">';
            conteudo += '<div class="parceria-container">';
            conteudo += '<div class="parceria-titulo">üë• Pessoas na Parceria</div>';
            conteudo += '<div id="listaPessoasParceria">';
            conteudo += '<div class="parceria-pessoa">';
            conteudo += '<input type="text" placeholder="Nome" value="Eu" required>';
            conteudo += '<input type="number" step="0.01" placeholder="Valor" class="valor-parceria">';
            conteudo += '<span style="width: 40px;"></span>';
            conteudo += '</div>';
            conteudo += '</div>';
            conteudo += '<button type="button" class="btn-adicionar-parceria" onclick="adicionarPessoaParceria()">+ Adicionar Pessoa</button>';
            conteudo += '<div class="parceria-aviso">';
            conteudo += 'üí° <strong>Dica:</strong> Deixe os valores em branco para divis√£o igual. Se preencher, a soma deve ser igual ao valor total da compra.';
            conteudo += '</div>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            conteudo += '<div style="height: 16px;"></div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += `<label>Nome da ${tipoLabel.toLowerCase()}:</label>`;
            conteudo += '<input type="text" id="nomeCompraForm" required>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Valor Total:</label>';
            conteudo += '<input type="number" id="valorTotalForm" step="0.01" required>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>N√∫mero de Parcelas:</label>';
            conteudo += '<input type="number" id="numParcelasForm" min="1" value="1" required>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="compraEmAndamentoForm" onchange="toggleParcelasEmAndamentoForm()">';
            conteudo += '<label for="compraEmAndamentoForm" style="font-size: 12px;">Compra em andamento</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal" id="grupoParcelasAndamentoForm" style="display: none;">';
            conteudo += '<label>J√° pagas:</label>';
            conteudo += '<input type="number" id="parcelasJaPagasForm" min="0" placeholder="0">';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="contaRecorrenteForm" onchange="toggleContaRecorrenteForm()">';
            conteudo += '<label for="contaRecorrenteForm" style="font-size: 12px;">Conta recorrente (√°gua, luz, plano...)</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            conteudo += '<div class="form-grupo-modal" id="grupoPagamentoVariavelForm" style="display: none;">';
            conteudo += '<div class="checkbox-group">';
            conteudo += '<input type="checkbox" id="pagamentoVariavelForm">';
            conteudo += '<label for="pagamentoVariavelForm" style="font-size: 12px;">üí∞ Pagamento vari√°vel</label>';
            conteudo += '</div>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-grupo-modal">';
            conteudo += '<label>Observa√ß√µes:</label>';
            conteudo += '<textarea id="observacoesForm" placeholder="Ex: Pagamento quinzenal, PIX, etc...&#10;Pressione Enter para nova linha" rows="3" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: \'Segoe UI\', Tahoma, Geneva, Verdana, sans-serif; resize: vertical; transition: border 0.3s;"></textarea>';
            conteudo += '</div>';
            
            conteudo += '<div class="form-acoes-modal">';
            conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">Cancelar</button>';
            conteudo += '<button type="submit" class="btn-salvar-modal">Salvar</button>';
            conteudo += '</div>';
            conteudo += '</form>';
            
            document.getElementById('modalFormConteudo').innerHTML = conteudo;
            document.getElementById('modalForm').classList.add('ativo');
        }

        function fecharModalForm() {
            document.getElementById('modalForm').classList.remove('ativo');
        }
        
        function toggleCompraParceria() {
            const checkbox = document.getElementById('compraParceriaForm');
            const pessoaUnica = document.getElementById('pessoaUnicaContainer');
            const parceria = document.getElementById('parceriaContainer');
            
            if (checkbox.checked) {
                pessoaUnica.style.display = 'none';
                parceria.style.display = 'block';
                document.getElementById('nomePessoaForm').removeAttribute('required');
            } else {
                pessoaUnica.style.display = 'block';
                parceria.style.display = 'none';
                document.getElementById('nomePessoaForm').setAttribute('required', 'required');
            }
        }
        
        function adicionarPessoaParceria() {
            const lista = document.getElementById('listaPessoasParceria');
            const novaPessoa = document.createElement('div');
            novaPessoa.className = 'parceria-pessoa';
            novaPessoa.innerHTML = `
                <input type="text" placeholder="Nome" required>
                <input type="number" step="0.01" placeholder="Valor (opcional)" class="valor-parceria">
                <button type="button" class="btn-remover-parceria" onclick="removerPessoaParceria(this)">‚úï</button>
            `;
            lista.appendChild(novaPessoa);
        }
        
        function removerPessoaParceria(btn) {
            btn.parentElement.remove();
        }

        function salvarNovaPessoa(e) {
            e.preventDefault();
            
            const ehParceria = document.getElementById('compraParceriaForm').checked;
            const nomeCompra = document.getElementById('nomeCompraForm').value;
            const valorTotal = parseFloat(document.getElementById('valorTotalForm').value);
            const ehRecorrente = document.getElementById('contaRecorrenteForm').checked;
            const observacoes = document.getElementById('observacoesForm').value;
            
            let numParcelas, parcelaAtual, parcelasTexto, jaPagas;
            let parcelaBase = 1;
            const mesBase = getChaveMes();
            
            if (ehRecorrente) {
                numParcelas = 1;
                parcelasTexto = 'recorrente';
                jaPagas = 0;
            } else if (document.getElementById('compraEmAndamentoForm').checked) {
                jaPagas = parseInt(document.getElementById('parcelasJaPagasForm').value) || 0;
                numParcelas = parseInt(document.getElementById('numParcelasForm').value) || 1;
                parcelaAtual = jaPagas + 1;
                parcelasTexto = numParcelas > 1 ? `${parcelaAtual}/${numParcelas}` : '';
                parcelaBase = parcelaAtual;
            } else {
                numParcelas = parseInt(document.getElementById('numParcelasForm').value) || 1;
                parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                jaPagas = 0;
                parcelaBase = 1;
            }
            
            const dataCompraAtual = new Date().toISOString();
            const idUnicoBase = dataCompraAtual + '_' + nomeCompra;
            
            if (ehParceria) {
                // ===== MODO PARCERIA =====
                const pessoasParceria = [];
                const listaPessoas = document.querySelectorAll('#listaPessoasParceria .parceria-pessoa');
                
                // Coletar dados das pessoas
                listaPessoas.forEach((pessoaEl, idx) => {
                    const inputs = pessoaEl.querySelectorAll('input');
                    const nomePessoa = inputs[0].value.trim();
                    const valorPessoa = inputs[1].value ? parseFloat(inputs[1].value) : null;
                    
                    if (nomePessoa) {
                        pessoasParceria.push({
                            nome: nomePessoa,
                            valorDefinido: valorPessoa
                        });
                    }
                });
                
                if (pessoasParceria.length === 0) {
                    alert('‚ùå Adicione pelo menos uma pessoa na parceria!');
                    return;
                }
                
                // NOVA L√ìGICA: Calcular valores automaticamente
                const valorPorParcela = valorTotal / numParcelas;
                let valores = [];
                
                // Contar quantos valores foram preenchidos
                const valoresPreenchidos = pessoasParceria.filter(p => p.valorDefinido !== null);
                const qtdPreenchidos = valoresPreenchidos.length;
                const qtdVazios = pessoasParceria.length - qtdPreenchidos;
                
                if (qtdPreenchidos === 0) {
                    // Nenhum valor preenchido = divis√£o igual
                    const valorPorPessoa = valorPorParcela / pessoasParceria.length;
                    valores = pessoasParceria.map(() => valorPorPessoa);
                    
                } else if (qtdPreenchidos === pessoasParceria.length) {
                    // Todos preenchidos = validar soma
                    const somaValores = pessoasParceria.reduce((sum, p) => sum + p.valorDefinido, 0);
                    
                    if (Math.abs(somaValores - valorPorParcela) > 0.01) {
                        alert(`‚ùå A soma dos valores (R$ ${somaValores.toFixed(2)}) deve ser igual ao valor da parcela (R$ ${valorPorParcela.toFixed(2)})!`);
                        return;
                    }
                    
                    valores = pessoasParceria.map(p => p.valorDefinido);
                    
                } else {
                    // NOVO: Alguns preenchidos, outros vazios = calcular autom√°tico
                    const somaPreenchidos = valoresPreenchidos.reduce((sum, p) => sum + p.valorDefinido, 0);
                    const valorRestante = valorPorParcela - somaPreenchidos;
                    
                    if (valorRestante < 0) {
                        alert(`‚ùå A soma dos valores preenchidos (R$ ${somaPreenchidos.toFixed(2)}) excede o valor da parcela (R$ ${valorPorParcela.toFixed(2)})!`);
                        return;
                    }
                    
                    // Distribuir o restante igualmente entre os vazios
                    const valorPorVazio = valorRestante / qtdVazios;
                    
                    valores = pessoasParceria.map(p => 
                        p.valorDefinido !== null ? p.valorDefinido : valorPorVazio
                    );
                }
                
                // Criar compra para cada pessoa
                const ehPagamentoVariavelParceria = document.getElementById('pagamentoVariavelForm').checked;
                
                pessoasParceria.forEach((pessoa, idx) => {
                    const valorPessoa = valores[idx];
                    const valorTotalPessoa = valorPessoa * numParcelas;
                    
                    const novaPessoa = {
                        nome: pessoa.nome,
                        valor: valorPessoa,
                        valorTotal: valorTotalPessoa,
                        parcelas: parcelasTexto,
                        observacoes: observacoes,
                        compras: [{
                            nome: nomeCompra,
                            valorTotal: valorTotalPessoa,
                            valorParcela: valorPessoa,
                            parcelas: parcelasTexto,
                            dataCompra: new Date().toLocaleDateString('pt-BR'),
                            idUnico: idUnicoBase + '_' + pessoa.nome,
                            observacoes: observacoes,
                            _parcelaBase: parcelaBase,
                            _mesBase: mesBase,
                            _parceria: true,
                            _pagamentoVariavel: ehPagamentoVariavelParceria
                        }],
                        pago: false,
                        parcelasJaPagas: jaPagas
                    };
                    
                    pessoasTemp.push(novaPessoa);
                });
                
            } else {
                // ===== MODO NORMAL (pessoa √∫nica) =====
                const nome = document.getElementById('nomePessoaForm').value;
                const valorParcela = valorTotal / numParcelas;
                const ehPagamentoVariavel = document.getElementById('pagamentoVariavelForm').checked;
                
                const novaPessoa = {
                    nome,
                    valor: valorParcela,
                    valorTotal: valorTotal,
                    parcelas: parcelasTexto,
                    observacoes: observacoes,
                    compras: [{
                        nome: nomeCompra,
                        valorTotal: valorTotal,
                        valorParcela: valorParcela,
                        parcelas: parcelasTexto,
                        dataCompra: new Date().toLocaleDateString('pt-BR'),
                        idUnico: idUnicoBase,
                        observacoes: observacoes,
                        _parcelaBase: parcelaBase,
                        _mesBase: mesBase,
                        _pagamentoVariavel: ehPagamentoVariavel
                    }],
                    pago: false,
                    parcelasJaPagas: jaPagas
                };
                
                pessoasTemp.push(novaPessoa);
            }
            
            renderizarPessoasForm();
            fecharModalForm();
        }

        function removerPessoa(index) {
            pessoasTemp.splice(index, 1);
            renderizarPessoasForm();
        }
        
        function removerPessoaTemp(index) {
            const pessoaRemovida = pessoasTemp[index];
            
            // Verificar se est√° editando uma conta
            if (contaEditando) {
                // Remover de todos os meses
                removerPessoaDeTodosOsMeses(contaEditando.nome, pessoaRemovida.nome);
            }
            
            pessoasTemp.splice(index, 1);
            renderizarPessoasForm();
        }
        function excluirPessoaECompras(index) {
            const pessoaRemovida = pessoasTemp[index];
            
            adicionarLog(`üóëÔ∏è INICIANDO exclus√£o via modal de edi√ß√£o`, 'importante');
            adicionarLog(`   Pessoa: ${pessoaRemovida.nome}`, 'info');
            
            // Verificar se est√° editando uma conta
            if (contaEditando) {
                // Verificar se tem compras
                if (pessoaRemovida.compras && pessoaRemovida.compras.length > 0) {
                    const compra = pessoaRemovida.compras[0];
                    
                    adicionarLog(`   Compra encontrada: ${compra.nome}`, 'info');
                    adicionarLog(`   ID √önico: ${compra.idUnico}`, 'info');
                    
                    const confirmar = confirm(
                        '‚ö†Ô∏è ATEN√á√ÉO!\n\n' +
                        `Deseja excluir "${compra.nome}" de TODOS OS MESES?\n\n` +
                        'Esta a√ß√£o remover√° todas as parcelas desta compra em todos os meses.\n\n' +
                        'Continuar?'
                    );
                    
                    if (!confirmar) {
                        adicionarLog(`   ‚ùå Exclus√£o cancelada pelo usu√°rio`, 'warning');
                        return;
                    }
                    
                    adicionarLog(`   ‚úÖ Confirmado, iniciando exclus√£o de todos os meses...`, 'success');
                    
                    // Excluir de todos os meses usando a mesma l√≥gica do clique longo
                    excluirCompraDeTodosOsMeses(contaEditando.nome, pessoaRemovida.nome, compra.idUnico);
                    
                    adicionarLog(`   ‚úÖ excluirCompraDeTodosOsMeses() executada`, 'success');
                    
                    // Remover do pessoasTemp
                    pessoasTemp.splice(index, 1);
                    adicionarLog(`   ‚úÖ Removido do pessoasTemp`, 'success');
                    
                    // Atualizar a conta no array contas do m√™s atual
                    const indexContaAtual = contas.findIndex(c => c.id === contaEditando.id);
                    if (indexContaAtual !== -1) {
                        const pessoaNaContaAtual = contas[indexContaAtual].pessoas.find(p => p.nome === pessoaRemovida.nome);
                        if (pessoaNaContaAtual) {
                            pessoaNaContaAtual.compras = pessoaNaContaAtual.compras.filter(c => c.idUnico !== compra.idUnico);
                            
                            // Se n√£o tem mais compras, remover a pessoa da conta
                            if (pessoaNaContaAtual.compras.length === 0) {
                                contas[indexContaAtual].pessoas = contas[indexContaAtual].pessoas.filter(p => p.nome !== pessoaRemovida.nome);
                                adicionarLog(`   ‚úÖ Pessoa removida da conta atual (sem compras)`, 'success');
                            } else {
                                // Recalcular valores
                                pessoaNaContaAtual.valor = pessoaNaContaAtual.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                pessoaNaContaAtual.valorTotal = pessoaNaContaAtual.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                                adicionarLog(`   ‚úÖ Valores recalculados da pessoa na conta atual`, 'success');
                            }
                        }
                    }
                    
                    // Atualizar a conta editando
                    const pessoaNaContaEditando = contaEditando.pessoas.find(p => p.nome === pessoaRemovida.nome);
                    if (pessoaNaContaEditando) {
                        pessoaNaContaEditando.compras = pessoaNaContaEditando.compras.filter(c => c.idUnico !== compra.idUnico);
                        
                        // Se n√£o tem mais compras, remover a pessoa da conta
                        if (pessoaNaContaEditando.compras.length === 0) {
                            contaEditando.pessoas = contaEditando.pessoas.filter(p => p.nome !== pessoaRemovida.nome);
                            adicionarLog(`   ‚úÖ Pessoa removida da contaEditando (sem compras)`, 'success');
                        } else {
                            // Recalcular valores
                            pessoaNaContaEditando.valor = pessoaNaContaEditando.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                            pessoaNaContaEditando.valorTotal = pessoaNaContaEditando.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                            adicionarLog(`   ‚úÖ Valores recalculados da pessoa na contaEditando`, 'success');
                        }
                    }
                    
                    // Salvar altera√ß√µes IMEDIATAMENTE
                    adicionarLog(`   üíæ Salvando no storage...`, 'warning');
                    salvarNoStorage();
                    adicionarLog(`   ‚úÖ Salvo no storage`, 'success');
                    
                    // Recarregar do storage para garantir consist√™ncia
                    const dadosAtualizados = localStorage.getItem('todasContas');
                    if (dadosAtualizados) {
                        todasContas = JSON.parse(dadosAtualizados);
                        adicionarLog(`   ‚úÖ todasContas recarregado`, 'success');
                    }
                    
                    // Recarregar o m√™s atual
                    carregarContasMesAtual();
                    adicionarLog(`   ‚úÖ carregarContasMesAtual() executado`, 'success');
                    
                    // Renderizar apenas a lista de pessoas do formul√°rio
                    renderizarPessoasForm();
                    
                    // Renderizar as contas na tela principal
                    renderizarContas();
                    
                    adicionarLog(`‚úÖ EXCLUS√ÉO CONCLU√çDA COM SUCESSO!`, 'importante');
                    
                    alert('Compra exclu√≠da com sucesso de todos os meses! ‚úÖ\n\nO formul√°rio permanece aberto para novas edi√ß√µes.');
                } else {
                    // Se n√£o tem compras, usar a fun√ß√£o normal
                    adicionarLog(`   ‚ö†Ô∏è Pessoa sem compras detalhadas, usando remo√ß√£o normal`, 'warning');
                    removerPessoaTemp(index);
                }
            } else {
                // Se n√£o est√° editando, apenas remover do temp
                adicionarLog(`   ‚ÑπÔ∏è N√£o est√° editando conta, removendo apenas do temp`, 'info');
                pessoasTemp.splice(index, 1);
                renderizarPessoasForm();
            }
        }

        function editarPessoa(index) {
            const pessoa = pessoasTemp[index];
            const tipoTransacao = document.getElementById('tipoTransacao').value;
            const tipoLabel = tipoTransacao === 'recebimento' ? 'Entrada' : 'Compra';
            
            // Verificar se √© uma parceria
            const ehParceria = pessoa.compras && pessoa.compras.length > 0 && pessoa.compras[0]._parceria;
            
            if (ehParceria) {
                // MODO PARCERIA: Reconstruir o formul√°rio de parceria
                const compra = pessoa.compras[0];
                const partesId = compra.idUnico.split('_');
                const nomeCompraCompleto = partesId.slice(0, -1).join('_');
                
                adicionarLog(`üìù Editando parceria`, 'importante');
                adicionarLog(`   ID completo: ${compra.idUnico}`, 'info');
                adicionarLog(`   Nome compra extra√≠do: ${nomeCompraCompleto}`, 'info');
                adicionarLog(`   Pessoa clicada: ${pessoa.nome}`, 'info');
                
                // Encontrar todas as pessoas dessa parceria
                const pessoasDaParceria = pessoasTemp.filter(p => {
                    if (p.compras && p.compras.length > 0 && p.compras[0]._parceria) {
                        const partesIdP = p.compras[0].idUnico.split('_');
                        const nomeCompraDessaPessoa = partesIdP.slice(0, -1).join('_');
                        const ehMesmaParceria = nomeCompraDessaPessoa === nomeCompraCompleto;
                        
                        if (ehMesmaParceria) {
                            adicionarLog(`   ‚úÖ Encontrada: ${p.nome} - Valor: R$ ${p.valor.toFixed(2)}`, 'success');
                        }
                        return ehMesmaParceria;
                    }
                    return false;
                });
                
                adicionarLog(`   üìä Total de pessoas na parceria: ${pessoasDaParceria.length}`, 'importante');
                
                const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                const totalParcelas = match ? parseInt(match[2]) : 1;
                
                const valorTotalCompra = pessoasDaParceria.reduce((sum, p) => {
                    const valorTotalDessaPessoa = p.valor * totalParcelas;
                    adicionarLog(`   üí∞ ${p.nome}: valor parcela = ${p.valor}, total parcelas = ${totalParcelas}, valor total = ${valorTotalDessaPessoa}`, 'info');
                    return sum + valorTotalDessaPessoa;
                }, 0);
                
                adicionarLog(`   üíµ Valor Total Calculado: R$ ${valorTotalCompra.toFixed(2)}`, 'importante');
                adicionarLog(`   üöÄ INICIANDO CONSTRU√á√ÉO DO MODAL`, 'warning');
                
                try {
                    document.getElementById('modalFormTitulo').textContent = `Editar ${tipoLabel} em Parceria`;
                    
                    let conteudo = '<form id="formEditarParceria" onsubmit="salvarEdicaoParceria(event, ' + index + ', \'' + nomeCompraCompleto.replace(/'/g, "\\'") + '\')">';
                    
                    conteudo += '<div class="form-grupo-modal"><label>Nome da compra:</label>';
                    conteudo += `<input type="text" id="nomeCompraEditParceriaForm" value="${compra.nome}" required></div>`;
                    
                    conteudo += '<div class="form-grupo-modal"><label>Valor Total:</label>';
                    conteudo += `<input type="number" id="valorTotalEditParceriaForm" step="0.01" value="${valorTotalCompra.toFixed(2)}" required></div>`;
                    
                    conteudo += '<div class="form-grupo-modal"><label>N√∫mero de Parcelas:</label>';
                    conteudo += `<input type="number" id="numParcelasEditParceriaForm" min="1" value="${totalParcelas}" required></div>`;
                    
                    const ehRecorrente = compra.parcelas === 'recorrente';
                    const ehEmAndamento = pessoa.parcelasJaPagas && pessoa.parcelasJaPagas > 0;
                    
                    conteudo += '<div class="form-grupo-modal"><div class="checkbox-group">';
                    conteudo += `<input type="checkbox" id="compraEmAndamentoEditParceriaForm" ${ehEmAndamento ? 'checked' : ''} onchange="toggleParcelasEmAndamentoEditParceriaForm()">`;
                    conteudo += '<label for="compraEmAndamentoEditParceriaForm" style="font-size: 12px;">Compra em andamento</label></div></div>';
                    
                    conteudo += `<div class="form-grupo-modal" id="grupoParcelasAndamentoEditParceriaForm" style="display: ${ehEmAndamento ? 'block' : 'none'};">`;
                    conteudo += '<label>J√° pagas:</label>';
                    conteudo += `<input type="number" id="parcelasJaPagasEditParceriaForm" min="0" value="${pessoa.parcelasJaPagas || 0}" placeholder="0"></div>`;
                    
                    conteudo += '<div class="form-grupo-modal"><div class="checkbox-group">';
                    conteudo += `<input type="checkbox" id="contaRecorrenteEditParceriaForm" ${ehRecorrente ? 'checked' : ''} onchange="toggleContaRecorrenteEditParceriaForm()">`;
                    conteudo += '<label for="contaRecorrenteEditParceriaForm" style="font-size: 12px;">Conta recorrente</label></div></div>';
                    
                    const ehPagamentoVariavelParceria = (compra._pagamentoVariavel) || false;
                    conteudo += `<div class="form-grupo-modal" id="grupoPagamentoVariavelEditParceriaForm" style="display: ${ehRecorrente ? 'block' : 'none'};"><div class="checkbox-group">`;
                    conteudo += `<input type="checkbox" id="pagamentoVariavelEditParceriaForm" ${ehPagamentoVariavelParceria ? 'checked' : ''}>`;
                    conteudo += '<label for="pagamentoVariavelEditParceriaForm" style="font-size: 12px;">üí∞ Pagamento vari√°vel</label></div></div>';
                    
                    conteudo += '<div class="form-grupo-modal"><label>Observa√ß√µes:</label>';
                    conteudo += `<textarea id="observacoesEditParceriaForm" placeholder="Observa√ß√µes" rows="3" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; resize: vertical; transition: border 0.3s;">${compra.observacoes || ''}</textarea></div>`;
                    
                    conteudo += '<div class="form-grupo-modal" style="margin-top: 16px;"><div class="checkbox-group">';
                    conteudo += '<input type="checkbox" id="compraParceriaEditForm" checked disabled>';
                    conteudo += '<label style="font-size: 13px; color: #667eea; font-weight: bold;">üë• Compra em parceria</label></div></div>';
                    
                    conteudo += '<div class="form-grupo-modal"><div class="parceria-container" style="margin-top: 0;">';
                    conteudo += '<div class="parceria-titulo">üë• Pessoas na Parceria</div><div id="listaPessoasParceriaEdit">';
                    
                    adicionarLog(`   üî® Construindo lista de ${pessoasDaParceria.length} pessoas`, 'warning');
                    
                    pessoasDaParceria.forEach((p, idx) => {
                        const podeRemover = pessoasDaParceria.length > 1;
                        conteudo += '<div class="parceria-pessoa">';
                        conteudo += `<input type="text" placeholder="Nome" value="${p.nome}" required>`;
                        conteudo += `<input type="number" step="0.01" placeholder="Valor" class="valor-parceria" value="${p.valor.toFixed(2)}">`;
                        conteudo += podeRemover ? '<button type="button" class="btn-remover-parceria" onclick="removerPessoaParceriaEdit(this)">‚úï</button>' : '<span style="width: 40px;"></span>';
                        conteudo += '</div>';
                    });
                    
                    conteudo += '</div>';
                    conteudo += '<button type="button" class="btn-adicionar-parceria" onclick="adicionarPessoaParceriaEdit()">+ Adicionar Pessoa</button>';
                    conteudo += '<div class="parceria-aviso">üí° <strong>Dica:</strong> Deixe os valores em branco para divis√£o igual.</div></div></div>';
                    
                    conteudo += '<div class="form-acoes-modal">';
                    conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">Cancelar</button>';
                    conteudo += '<button type="submit" class="btn-salvar-modal">Salvar</button></div></form>';
                    
                    adicionarLog(`   ‚úÖ HTML COMPLETO CONSTRU√çDO`, 'success');
                    adicionarLog(`   üìè Tamanho do HTML: ${conteudo.length} caracteres`, 'info');
                    
                    console.log('üîç Conte√∫do HTML constru√≠do:', conteudo.substring(0, 200));
                    
                    adicionarLog(`   üîÑ Fechando modalMenu...`, 'info');
                    document.getElementById('modalMenu').classList.remove('ativo');
                    adicionarLog(`   ‚úÖ modalMenu fechado`, 'success');
                    
                    adicionarLog(`   üîÑ Aguardando 150ms...`, 'info');
                    setTimeout(() => {
                        try {
                            adicionarLog(`   üîÑ Inserindo HTML no modalForm...`, 'info');
                            document.getElementById('modalFormConteudo').innerHTML = conteudo;
                            adicionarLog(`   ‚úÖ HTML inserido`, 'success');
                            
                            adicionarLog(`   üîÑ Abrindo modalForm...`, 'info');
                            document.getElementById('modalForm').classList.add('ativo');
                            adicionarLog(`   ‚úÖ MODAL ABERTO COM SUCESSO!`, 'success');
                        } catch (erro) {
                            adicionarLog(`   ‚ùå ERRO ao abrir modal: ${erro.message}`, 'error');
                            console.error('Erro detalhado:', erro);
                        }
                    }, 150);
                    
                } catch (erro) {
                    adicionarLog(`   ‚ùå ERRO ao construir HTML: ${erro.message}`, 'error');
                    console.error('Erro detalhado na constru√ß√£o:', erro);
                    alert('‚ùå Erro ao construir formul√°rio: ' + erro.message);
                }
                
                console.log('üîç Conte√∫do HTML constru√≠do:', conteudo.substring(0, 200));
                
                try {
                    adicionarLog(`   üîÑ Fechando modalMenu...`, 'info');
                    document.getElementById('modalMenu').classList.remove('ativo');
                    adicionarLog(`   ‚úÖ modalMenu fechado`, 'success');
                    
                    adicionarLog(`   üîÑ Aguardando 150ms...`, 'info');
                    setTimeout(() => {
                        try {
                            adicionarLog(`   üîÑ Inserindo HTML no modalForm...`, 'info');
                            document.getElementById('modalFormConteudo').innerHTML = conteudo;
                            adicionarLog(`   ‚úÖ HTML inserido`, 'success');
                            
                            adicionarLog(`   üîÑ Abrindo modalForm...`, 'info');
                            document.getElementById('modalForm').classList.add('ativo');
                            adicionarLog(`   ‚úÖ MODAL ABERTO COM SUCESSO!`, 'success');
                        } catch (erro) {
                            adicionarLog(`   ‚ùå ERRO ao abrir modal: ${erro.message}`, 'error');
                            console.error('Erro detalhado:', erro);
                        }
                    }, 150);
                } catch (erro) {
                    adicionarLog(`   ‚ùå ERRO ao processar modal: ${erro.message}`, 'error');
                    console.error('Erro detalhado:', erro);
                }
                adicionarLog(`   üìè Tamanho do HTML: ${conteudo.length} caracteres`, 'info');
                
                // Garantir que o modal anterior esteja fechado antes de abrir o novo
                document.getElementById('modalMenu').classList.remove('ativo');
                
                // Pequeno delay para garantir que a transi√ß√£o funcione
                setTimeout(() => {
                    document.getElementById('modalFormConteudo').innerHTML = conteudo;
                    document.getElementById('modalForm').classList.add('ativo');
                    adicionarLog(`   ‚úÖ MODAL ABERTO COM SUCESSO!`, 'success');
                }, 150);
                
            } else {
                // MODO NORMAL (c√≥digo original)
                document.getElementById('modalFormTitulo').textContent = `Editar Pessoa/${tipoLabel}`;
                
                let conteudo = '<form id="formEditarPessoaTemp" onsubmit="salvarEdicaoPessoaTemp(event, ' + index + ')">';
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += '<label>Nome da pessoa/descri√ß√£o:</label>';
                conteudo += `<input type="text" id="nomePessoaEditTemp" value="${pessoa.nome}" required>`;
                conteudo += '</div>';
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += `<label>Nome da ${tipoLabel.toLowerCase()}:</label>`;
                const nomeCompra = pessoa.compras && pessoa.compras[0] ? pessoa.compras[0].nome : '';
                conteudo += `<input type="text" id="nomeCompraEditTemp" value="${nomeCompra}" required>`;
                conteudo += '</div>';
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += '<label>Valor Total:</label>';
                const valorTotalReal = pessoa.compras && pessoa.compras[0] ? pessoa.compras[0].valorTotal : (pessoa.valorTotal || pessoa.valor);
                conteudo += `<input type="number" id="valorTotalEditTemp" step="0.01" value="${valorTotalReal}" required>`;
                conteudo += '</div>';
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += '<label>N√∫mero de Parcelas:</label>';
                let parcelas = '1';
                if (pessoa.compras && pessoa.compras[0] && pessoa.compras[0].parcelas && pessoa.compras[0].parcelas !== 'recorrente') {
                    const match = pessoa.compras[0].parcelas.match(/\/(\d+)/);
                    if (match) {
                        parcelas = match[1];
                    }
                } else if (pessoa.parcelas && pessoa.parcelas !== 'recorrente') {
                    const match = pessoa.parcelas.match(/\/(\d+)/);
                    if (match) {
                        parcelas = match[1];
                    }
                }
                conteudo += `<input type="number" id="numParcelasEditTemp" min="1" value="${parcelas}" required>`;
                conteudo += '</div>';
                
                const chaveAtual = getChaveMes();
                let parcelasJaPagasDetectadas = pessoa.parcelasJaPagas || 0;
                
                let parcelaBasePreservada = null;
                let mesBasePreservado = null;
                
                if (pessoa.compras && pessoa.compras[0]) {
                    parcelaBasePreservada = pessoa.compras[0]._parcelaBase;
                    mesBasePreservado = pessoa.compras[0]._mesBase;
                }
                
                if (parcelasJaPagasDetectadas === 0 && pessoa.compras && pessoa.compras[0]) {
                    const compraRef = pessoa.compras[0];
                    
                    Object.keys(todasContas).sort().forEach(chaveMes => {
                        if (chaveMes < chaveAtual && contaEditando) {
                            const contasMes = todasContas[chaveMes];
                            const contaEncontrada = contasMes.find(c => c.nome === contaEditando.nome);
                            
                            if (contaEncontrada) {
                                contaEncontrada.pessoas.forEach(p => {
                                    if (p.nome === pessoa.nome && p.compras && p.pago) {
                                        p.compras.forEach(c => {
                                            if (c.idUnico === compraRef.idUnico || (c.nome === compraRef.nome && c.dataCompra === compraRef.dataCompra)) {
                                                parcelasJaPagasDetectadas++;
                                            }
                                        });
                                    }
                                });
                            }
                        }
                    });
                }
                
                const temParcelasJaPagas = parcelasJaPagasDetectadas > 0;
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += '<div class="checkbox-group">';
                conteudo += `<input type="checkbox" id="compraEmAndamentoEditTemp" ${temParcelasJaPagas ? 'checked' : ''} onchange="toggleParcelasEmAndamentoEditTemp()">`;
                conteudo += '<label for="compraEmAndamentoEditTemp" style="font-size: 12px;">Compra em andamento</label>';
                conteudo += '</div>';
                conteudo += '</div>';
                
                conteudo += `<div class="form-grupo-modal" id="grupoParcelasAndamentoEditTemp" style="display: ${temParcelasJaPagas ? 'block' : 'none'};">`;
                conteudo += '<label>J√° pagas:</label>';
                conteudo += `<input type="number" id="parcelasJaPagasEditTemp" min="0" value="${parcelasJaPagasDetectadas}" placeholder="0">`;
                conteudo += '</div>';
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += '<div class="checkbox-group">';
                let ehRecorrente = false;
                if (pessoa.compras && pessoa.compras[0] && pessoa.compras[0].parcelas === 'recorrente') {
                    ehRecorrente = true;
                } else if (pessoa.parcelas === 'recorrente') {
                    ehRecorrente = true;
                }
                conteudo += `<input type="checkbox" id="contaRecorrenteEditTemp" ${ehRecorrente ? 'checked' : ''} onchange="toggleContaRecorrenteEditTemp()">`;
                conteudo += '<label for="contaRecorrenteEditTemp" style="font-size: 12px;">Conta recorrente (√°gua, luz, plano...)</label>';
                conteudo += '</div>';
                conteudo += '</div>';
                
                conteudo += `<div class="form-grupo-modal" id="grupoPagamentoVariavelEditTemp" style="display: ${ehRecorrente ? 'block' : 'none'};">`;
            conteudo += '<div class="checkbox-group">';
            const ehPagamentoVariavel = (pessoa.compras && pessoa.compras[0] && pessoa.compras[0]._pagamentoVariavel) || pessoa._pagamentoVariavel || false;
            conteudo += `<input type="checkbox" id="pagamentoVariavelEditTemp" ${ehPagamentoVariavel ? 'checked' : ''}>`;
            conteudo += '<label for="pagamentoVariavelEditTemp" style="font-size: 12px;">üí∞ Pagamento vari√°vel</label>';
            conteudo += '</div>';
            conteudo += '</div>';
                
                conteudo += '<div class="form-grupo-modal">';
                conteudo += '<label>Observa√ß√µes:</label>';
                const observacoes = (pessoa.compras && pessoa.compras[0] && pessoa.compras[0].observacoes) ? pessoa.compras[0].observacoes : (pessoa.observacoes || '');
                conteudo += `<textarea id="observacoesEditTemp" placeholder="Ex: Pagamento quinzenal, PIX, etc...&#10;Pressione Enter para nova linha" rows="3" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; resize: vertical; transition: border 0.3s;">${observacoes}</textarea>`;
                conteudo += '</div>';
                
                conteudo += `<input type="hidden" id="parcelaBasePreservadaEditTemp" value="${parcelaBasePreservada || ''}">`;
                conteudo += `<input type="hidden" id="mesBasePreservadoEditTemp" value="${mesBasePreservado || ''}">`;
                
                conteudo += '<div class="form-acoes-modal">';
                conteudo += '<button type="button" class="btn-cancelar-modal" onclick="fecharModalForm()">Cancelar</button>';
                conteudo += '<button type="submit" class="btn-salvar-modal">Salvar</button>';
                conteudo += '</div>';
                conteudo += '</form>';
                
                adicionarLog(`‚úÖ PRESTES A ABRIR MODAL - Conte√∫do tem ${conteudo.length} caracteres`, 'success');
                console.log('HTML do modal:', conteudo);
                
                document.getElementById('modalFormConteudo').innerHTML = conteudo;
                document.getElementById('modalForm').classList.add('ativo');
            }
        }
        
        function toggleParcelasEmAndamentoEditParceriaForm() {
            const checkbox = document.getElementById('compraEmAndamentoEditParceriaForm');
            const grupoAndamento = document.getElementById('grupoParcelasAndamentoEditParceriaForm');
            
            if (checkbox.checked) {
                grupoAndamento.style.display = 'block';
            } else {
                grupoAndamento.style.display = 'none';
            }
        }
        
        function toggleContaRecorrenteEditParceriaForm() {
            const checkbox = document.getElementById('contaRecorrenteEditParceriaForm');
            const camposParcelas = document.getElementById('numParcelasEditParceriaForm');
            const checkboxAndamento = document.getElementById('compraEmAndamentoEditParceriaForm');
            const grupoPagamentoVariavel = document.getElementById('grupoPagamentoVariavelEditParceriaForm');
            const checkboxPagamentoVariavel = document.getElementById('pagamentoVariavelEditParceriaForm');
            
            if (checkbox.checked) {
                camposParcelas.value = '';
                camposParcelas.disabled = true;
                camposParcelas.placeholder = 'Recorrente';
                checkboxAndamento.checked = false;
                checkboxAndamento.disabled = true;
                toggleParcelasEmAndamentoEditParceriaForm();
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'block';
            } else {
                camposParcelas.disabled = false;
                camposParcelas.placeholder = '1 ou vazio';
                checkboxAndamento.disabled = false;
                if (grupoPagamentoVariavel) grupoPagamentoVariavel.style.display = 'none';
                if (checkboxPagamentoVariavel) checkboxPagamentoVariavel.checked = false;
            }
        }
        
        function adicionarPessoaParceriaEdit() {
            const lista = document.getElementById('listaPessoasParceriaEdit');
            const novaPessoa = document.createElement('div');
            novaPessoa.className = 'parceria-pessoa';
            novaPessoa.innerHTML = `
                <input type="text" placeholder="Nome" required>
                <input type="number" step="0.01" placeholder="Valor (opcional)" class="valor-parceria">
                <button type="button" class="btn-remover-parceria" onclick="removerPessoaParceriaEdit(this)">‚úï</button>
            `;
            lista.appendChild(novaPessoa);
        }
        
        function removerPessoaParceriaEdit(btn) {
            btn.parentElement.remove();
        }
        
        function salvarEdicaoParceria(e, indexOriginal, idBase) {
            e.preventDefault();
            
            const nomeCompra = document.getElementById('nomeCompraEditParceriaForm').value;
            const valorTotal = parseFloat(document.getElementById('valorTotalEditParceriaForm').value);
            const ehRecorrente = document.getElementById('contaRecorrenteEditParceriaForm').checked;
            const observacoes = document.getElementById('observacoesEditParceriaForm').value;
            
            let numParcelas, parcelaAtual, parcelasTexto, jaPagas;
            let parcelaBase = 1;
            const mesBase = getChaveMes();
            
            if (ehRecorrente) {
                numParcelas = 1;
                parcelasTexto = 'recorrente';
                jaPagas = 0;
            } else if (document.getElementById('compraEmAndamentoEditParceriaForm').checked) {
                jaPagas = parseInt(document.getElementById('parcelasJaPagasEditParceriaForm').value) || 0;
                numParcelas = parseInt(document.getElementById('numParcelasEditParceriaForm').value) || 1;
                parcelaAtual = jaPagas + 1;
                parcelasTexto = numParcelas > 1 ? `${parcelaAtual}/${numParcelas}` : '';
                parcelaBase = parcelaAtual;
            } else {
                numParcelas = parseInt(document.getElementById('numParcelasEditParceriaForm').value) || 1;
                parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                jaPagas = 0;
                parcelaBase = 1;
            }
            
            // Coletar pessoas
            const pessoasParceria = [];
            const listaPessoas = document.querySelectorAll('#listaPessoasParceriaEdit .parceria-pessoa');
            
            listaPessoas.forEach((pessoaEl, idx) => {
                const inputs = pessoaEl.querySelectorAll('input');
                const nomePessoa = inputs[0].value.trim();
                const valorPessoa = inputs[1].value ? parseFloat(inputs[1].value) : null;
                
                if (nomePessoa) {
                    pessoasParceria.push({
                        nome: nomePessoa,
                        valorDefinido: valorPessoa
                    });
                }
            });
            
            if (pessoasParceria.length === 0) {
                alert('‚ùå Adicione pelo menos uma pessoa na parceria!');
                return;
            }
            
            // Calcular valores (mesma l√≥gica do salvarNovaPessoa)
            const valorPorParcela = valorTotal / numParcelas;
            let valores = [];
            
            const valoresPreenchidos = pessoasParceria.filter(p => p.valorDefinido !== null);
            const qtdPreenchidos = valoresPreenchidos.length;
            const qtdVazios = pessoasParceria.length - qtdPreenchidos;
            
            if (qtdPreenchidos === 0) {
                const valorPorPessoa = valorPorParcela / pessoasParceria.length;
                valores = pessoasParceria.map(() => valorPorPessoa);
            } else if (qtdPreenchidos === pessoasParceria.length) {
                const somaValores = pessoasParceria.reduce((sum, p) => sum + p.valorDefinido, 0);
                
                if (Math.abs(somaValores - valorPorParcela) > 0.01) {
                    alert(`‚ùå A soma dos valores (R$ ${somaValores.toFixed(2)}) deve ser igual ao valor da parcela (R$ ${valorPorParcela.toFixed(2)})!`);
                    return;
                }
                
                valores = pessoasParceria.map(p => p.valorDefinido);
            } else {
                const somaPreenchidos = valoresPreenchidos.reduce((sum, p) => sum + p.valorDefinido, 0);
                const valorRestante = valorPorParcela - somaPreenchidos;
                
                if (valorRestante < 0) {
                    alert(`‚ùå A soma dos valores preenchidos (R$ ${somaPreenchidos.toFixed(2)}) excede o valor da parcela (R$ ${valorPorParcela.toFixed(2)})!`);
                    return;
                }
                
                const valorPorVazio = valorRestante / qtdVazios;
                valores = pessoasParceria.map(p => 
                    p.valorDefinido !== null ? p.valorDefinido : valorPorVazio
                );
            }
            
            const dataCompraAtual = new Date().toISOString();
            const idUnicoBase = dataCompraAtual + '_' + nomeCompra;
            
            // Remover pessoas antigas da parceria
            const indicesRemover = [];
            pessoasTemp.forEach((p, i) => {
                if (p.compras && p.compras.length > 0 && p.compras[0]._parceria) {
                    const compraIdBase = p.compras[0].idUnico.substring(0, p.compras[0].idUnico.lastIndexOf('_'));
                    if (compraIdBase === idBase) {
                        indicesRemover.push(i);
                    }
                }
            });
            
            indicesRemover.sort((a, b) => b - a).forEach(i => pessoasTemp.splice(i, 1));
            
            // Adicionar novas pessoas
            const ehPagamentoVariavelEdicaoParceria = document.getElementById('pagamentoVariavelEditParceriaForm').checked;
            
            pessoasParceria.forEach((pessoa, idx) => {
                const valorPessoa = valores[idx];
                const valorTotalPessoa = valorPessoa * numParcelas;
                
                const novaPessoa = {
                    nome: pessoa.nome,
                    valor: valorPessoa,
                    valorTotal: valorTotalPessoa,
                    parcelas: parcelasTexto,
                    observacoes: observacoes,
                    compras: [{
                        nome: nomeCompra,
                        valorTotal: valorTotalPessoa,
                        valorParcela: valorPessoa,
                        parcelas: parcelasTexto,
                        dataCompra: new Date().toLocaleDateString('pt-BR'),
                        idUnico: idUnicoBase + '_' + pessoa.nome,
                        observacoes: observacoes,
                        _parcelaBase: parcelaBase,
                        _mesBase: mesBase,
                        _parceria: true,
                        _pagamentoVariavel: ehPagamentoVariavelEdicaoParceria
                    }],
                    pago: false,
                    parcelasJaPagas: jaPagas
                };
                
                pessoasTemp.push(novaPessoa);
            });
            
            renderizarPessoasForm();
            fecharModalForm();

            // Sincroniza e salva apenas se N√ÉO estivermos no modal principal (Clique Longo)
            if (contaEditando && !document.getElementById('modal').classList.contains('ativo')) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
                salvarNoStorage();
                carregarContasMesAtual();
                renderizarContas();
                contaEditando = null;
                pessoasTemp = [];
            } else if (contaEditando) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
            }
        }
        
        function salvarEdicaoPessoaTemp(e, index) {
            e.preventDefault();
            
            const nome = document.getElementById('nomePessoaEditTemp').value;
            const nomeCompra = document.getElementById('nomeCompraEditTemp').value;
            const valorTotal = parseFloat(document.getElementById('valorTotalEditTemp').value);
            const ehRecorrente = document.getElementById('contaRecorrenteEditTemp').checked;
            const observacoes = document.getElementById('observacoesEditTemp').value;
            
            let numParcelas, parcelaAtual, parcelasTexto, valorParcela, jaPagas;
            
            // Preservar informa√ß√µes de parcela base original
            const pessoaOriginal = pessoasTemp[index];
            
            // RECUPERAR parcela base e m√™s base dos campos hidden
            const parcelaBaseHidden = document.getElementById('parcelaBasePreservadaEditTemp').value;
            const mesBaseHidden = document.getElementById('mesBasePreservadoEditTemp').value;
            
            let parcelaBaseOriginal = parcelaBaseHidden ? parseInt(parcelaBaseHidden) : null;
            let mesBaseOriginal = mesBaseHidden || null;
            
            // Se n√£o encontrou nos campos hidden, tentar recuperar da pessoa original
            if (!parcelaBaseOriginal && pessoaOriginal.compras && pessoaOriginal.compras[0]) {
                parcelaBaseOriginal = pessoaOriginal.compras[0]._parcelaBase;
                mesBaseOriginal = pessoaOriginal.compras[0]._mesBase;
            }
            
            adicionarLog(`üìù salvarEdicaoPessoaTemp INICIADA`, 'importante');
            adicionarLog(`   Pessoa: ${nome}`, 'info');
            adicionarLog(`   Compra: ${nomeCompra}`, 'info');
            adicionarLog(`   Valor NOVO: R$ ${valorTotal.toFixed(2)}`, 'info');
            adicionarLog(`   Valor ANTIGO: R$ ${pessoaOriginal.valorTotal.toFixed(2)}`, 'info');
            adicionarLog(`   √â Recorrente: ${ehRecorrente}`, 'info');
            adicionarLog(`   üìã Dados preservados - Parcela Base: ${parcelaBaseOriginal}, M√™s Base: ${mesBaseOriginal}`, 'info');
            
            if (ehRecorrente) {
                numParcelas = 1;
                valorParcela = valorTotal;
                parcelasTexto = 'recorrente';
                jaPagas = 0;
            } else if (document.getElementById('compraEmAndamentoEditTemp').checked) {
                jaPagas = parseInt(document.getElementById('parcelasJaPagasEditTemp').value) || 0;
                numParcelas = parseInt(document.getElementById('numParcelasEditTemp').value) || 1;
                parcelaAtual = jaPagas + 1;
                valorParcela = valorTotal / numParcelas;
                parcelasTexto = numParcelas > 1 ? `${parcelaAtual}/${numParcelas}` : '';
                
                // CR√çTICO: Se usu√°rio mudou as parcelas j√° pagas, atualizar parcela base
                const jaPagasOriginais = pessoaOriginal.parcelasJaPagas || 0;
                if (jaPagas !== jaPagasOriginais) {
                    parcelaBaseOriginal = parcelaAtual;
                    mesBaseOriginal = getChaveMes();
                    adicionarLog(`   üîÑ PARCELAS J√Å PAGAS MUDARAM: ${jaPagasOriginais} ‚Üí ${jaPagas}`, 'warning');
                    adicionarLog(`   üîÑ RECALCULANDO Parcela Base: ${parcelaBaseOriginal}`, 'warning');
                }
            } else {
                numParcelas = parseInt(document.getElementById('numParcelasEditTemp').value) || 1;
                valorParcela = valorTotal / numParcelas;
                
                // Manter a parcela atual se existir
                if (pessoasTemp[index].parcelas && pessoasTemp[index].parcelas !== 'recorrente') {
                    const matchAtual = pessoasTemp[index].parcelas.match(/(\d+)\/(\d+)/);
                    if (matchAtual) {
                        const parcelaAtualNum = parseInt(matchAtual[1]);
                        parcelasTexto = numParcelas > 1 ? `${parcelaAtualNum}/${numParcelas}` : '';
                        
                        // Preservar parcela base se existir
                        if (!parcelaBaseOriginal) {
                            parcelaBaseOriginal = parcelaAtualNum;
                            mesBaseOriginal = getChaveMes();
                        }
                    } else {
                        parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                    }
                } else {
                    parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                }
                jaPagas = 0;
            }
            
            // SE AINDA n√£o tem parcela base, criar agora
            if (!parcelaBaseOriginal || !mesBaseOriginal) {
                parcelaBaseOriginal = jaPagas > 0 ? jaPagas + 1 : 1;
                mesBaseOriginal = getChaveMes();
                adicionarLog(`   ‚ö†Ô∏è CRIANDO parcela base: ${parcelaBaseOriginal}, M√™s base: ${mesBaseOriginal}`, 'warning');
            }
            
            const dataCompraAtual = pessoasTemp[index].compras && pessoasTemp[index].compras[0] 
                ? pessoasTemp[index].compras[0].idUnico 
                : (new Date().toISOString() + '_' + nomeCompra);
            
            const ehPagamentoVariavel = document.getElementById('pagamentoVariavelEditTemp').checked;
            
            // *** NOVO: Detectar se o valor mudou ***
            const valorOriginalCompra = pessoaOriginal.compras && pessoaOriginal.compras[0] 
                ? pessoaOriginal.compras[0].valorTotal 
                : pessoaOriginal.valorTotal;
            const valorMudouRecorrente = ehRecorrente && (valorOriginalCompra !== valorTotal);
            
            const compraEditada = {
                nome: nomeCompra,
                valorTotal: valorTotal,
                valorParcela: valorParcela,
                parcelas: parcelasTexto,
                dataCompra: new Date().toLocaleDateString('pt-BR'),
                idUnico: dataCompraAtual,
                observacoes: observacoes,
                _parcelaBase: parcelaBaseOriginal,
                _mesBase: mesBaseOriginal,
                _pagamentoVariavel: ehPagamentoVariavel
            };
            
            adicionarLog(`   ‚úÖ Compra editada com _parcelaBase: ${compraEditada._parcelaBase}, _mesBase: ${compraEditada._mesBase}`, 'success');
            
            pessoasTemp[index] = {
                nome,
                valor: valorParcela,
                valorTotal: valorTotal,
                parcelas: parcelasTexto,
                observacoes: observacoes,
                compras: [compraEditada],
                pago: pessoasTemp[index].pago,
                parcelasJaPagas: jaPagas
            };
            
            adicionarLog(`   üìù Pessoa atualizada em pessoasTemp com parcelas: ${parcelasTexto}`, 'info');
            
            // *** CR√çTICO: Se estamos editando uma conta E precisa propagar altera√ß√µes ***
            if (contaEditando) {
                adicionarLog(`   üîÑ INICIANDO propaga√ß√£o de altera√ß√µes para TODOS os meses`, 'importante');
                
                const valorOriginalCompra = pessoaOriginal.compras && pessoaOriginal.compras[0] 
                    ? pessoaOriginal.compras[0].valorTotal 
                    : pessoaOriginal.valorTotal;
                const valorMudou = valorOriginalCompra !== valorTotal;
                
                adicionarLog(`   üí∞ Valor mudou? ${valorMudou ? 'SIM' : 'N√ÉO'} (${valorOriginalCompra} ‚Üí ${valorTotal})`, valorMudou ? 'warning' : 'info');
                
                if (ehRecorrente && valorMudou) {
                    // *** L√ìGICA ESPECIAL PARA RECORRENTES COM VALOR ALTERADO ***
                    adicionarLog(`   üí∞ CONTA RECORRENTE com valor alterado - Atualizando apenas meses FUTUROS`, 'importante');
                    
                    const chaveAtual = getChaveMes();
                    const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
                    const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
                    
                    adicionarLog(`   üìÖ M√™s atual de refer√™ncia: ${chaveAtual}`, 'info');
                    adicionarLog(`   üîç Procurando por ID da compra: ${dataCompraAtual}`, 'info');
                    
                    // Atualizar o valor APENAS NO M√äS ATUAL e meses FUTUROS
                    let mesesAtualizados = 0;
                    let mesesFuturosProcessados = 0;
                    
                    Object.keys(todasContas).sort().forEach(chaveMes => {
                        const [ano, mes] = chaveMes.split('-').map(Number);
                        const dataMes = new Date(ano, mes - 1);
                        
                        // Apenas meses >= ao atual (incluindo o atual)
                        if (dataMes >= dataAtualMes) {
                            const contasMes = todasContas[chaveMes];
                            const contaEncontrada = contasMes.find(c => c.nome === contaEditando.nome);
                            
                            if (contaEncontrada) {
                                adicionarLog(`   üîé Processando m√™s ${chaveMes}...`, 'info');
                                
                                let pessoasAtualizadas = 0;
                                contaEncontrada.pessoas.forEach((p, pIdx) => {
                                    if (p.nome === nome) {
                                        adicionarLog(`      üë§ Encontrada pessoa "${p.nome}" (√≠ndice ${pIdx})`, 'info');
                                        
                                        if (p.compras && p.compras.length > 0) {
                                            p.compras.forEach((c, cIdx) => {
                                                adicionarLog(`         üì¶ Compra ${cIdx}: "${c.nome}" (ID: ${c.idUnico})`, 'info');
                                                
                                                // Corrigido: Busca pelo ID ou pelo Nome se for recorrente para garantir a sincronia
                                                if (c.idUnico === dataCompraAtual || (ehRecorrente && c.nome === nomeCompra) || (ehRecorrente && pessoaOriginal.compras && pessoaOriginal.compras[0] && c.nome === pessoaOriginal.compras[0].nome)) {
                                                    adicionarLog(`         ‚úÖ MATCH! Atualizando item: ${c.nome}`, 'success');
                                                    
                                                    const valorAnterior = c.valorTotal;
                                                    c.valorTotal = valorTotal;
                                                    c.valorParcela = valorTotal;
                                                    c.nome = nomeCompra;
                                                    c.observacoes = observacoes;
                                                    c._pagamentoVariavel = ehPagamentoVariavel;
                                                    
                                                    mesesAtualizados++;
                                                    pessoasAtualizadas++;
                                                    
                                                    adicionarLog(`         üí∞ Valor: R$ ${valorAnterior.toFixed(2)} ‚Üí R$ ${valorTotal.toFixed(2)}`, 'success');
                                                }
                                            });
                                            
                                            // Recalcular valor total da pessoa
                                            const valorAnteriorPessoa = p.valor;
                                            p.valor = p.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                                            p.valorTotal = p.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                                            
                                            if (pessoasAtualizadas > 0) {
                                                adicionarLog(`      üìä Valor pessoa recalculado: R$ ${valorAnteriorPessoa.toFixed(2)} ‚Üí R$ ${p.valor.toFixed(2)}`, 'info');
                                            }
                                        } else {
                                            adicionarLog(`      ‚ö†Ô∏è Pessoa sem compras detalhadas`, 'warning');
                                        }
                                    }
                                });
                                
                                mesesFuturosProcessados++;
                                
                                if (pessoasAtualizadas > 0) {
                                    adicionarLog(`   ‚úÖ M√™s ${chaveMes}: ${pessoasAtualizadas} atualiza√ß√£o(√µes) realizada(s)`, 'success');
                                } else {
                                    adicionarLog(`   ‚ö†Ô∏è M√™s ${chaveMes}: Nenhuma atualiza√ß√£o (pessoa/compra n√£o encontrada)`, 'warning');
                                }
                            } else {
                                adicionarLog(`   ‚ö†Ô∏è M√™s ${chaveMes}: Conta "${contaEditando.nome}" n√£o encontrada`, 'warning');
                            }
                        }
                    });
                    
                    adicionarLog(`   üìä Resumo: ${mesesAtualizados} atualiza√ß√£o(√µes) em ${mesesFuturosProcessados} m√™s(es) futuro(s)`, 'importante');
                    
                    if (mesesAtualizados === 0) {
                        adicionarLog(`   ‚ö†Ô∏è ATEN√á√ÉO: Nenhuma atualiza√ß√£o foi realizada! Poss√≠veis causas:`, 'error');
                        adicionarLog(`      - ID da compra n√£o encontrado nos meses futuros`, 'error');
                        adicionarLog(`      - Pessoa n√£o existe nos meses futuros`, 'error');
                        adicionarLog(`      - Conta n√£o existe nos meses futuros`, 'error');
                    }
                    
                } else {
                
                    // *** L√ìGICA PADR√ÉO PARA COMPRAS NORMAIS/PARCELADAS ***
                    const chaveAtual = getChaveMes();
                    const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
                    const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
                    
                    adicionarLog(`   üóëÔ∏è FASE 1: Removendo compras antigas de meses FUTUROS`, 'warning');
                    let mesesLimpos = 0;
                    
                    Object.keys(todasContas).forEach(chaveMes => {
                        const [ano, mes] = chaveMes.split('-').map(Number);
                        const dataMes = new Date(ano, mes - 1);
                        
                        // *** CORRE√á√ÉO: Limpar APENAS meses FUTUROS ao atual ***
                        if (dataMes > dataAtualMes) {
                            const contasMes = todasContas[chaveMes];
                            const contaEncontrada = contasMes.find(c => c.nome === contaEditando.nome);
                            
                            if (contaEncontrada) {
                                contaEncontrada.pessoas.forEach(pessoaItem => {
                                    if (pessoaItem.nome === nome && pessoaItem.compras) {
                                        const qtdAntes = pessoaItem.compras.length;
                                        pessoaItem.compras = pessoaItem.compras.filter(c => 
                                            c.idUnico !== dataCompraAtual
                                        );
                                        if (qtdAntes !== pessoaItem.compras.length) {
                                            mesesLimpos++;
                                            adicionarLog(`      M√™s ${chaveMes}: Removida`, 'info');
                                        }
                                    }
                                });
                                
                                // Remover pessoas sem compras
                                contaEncontrada.pessoas = contaEncontrada.pessoas.filter(p => {
                                    if (p.nome !== nome) return true;
                                    if (!p.compras || p.compras.length === 0) return false;
                                    return true;
                                });
                            }
                        }
                    });
                    
                    adicionarLog(`   ‚úÖ ${mesesLimpos} meses futuros limpos`, 'success');
                    
                    // *** FASE 2: Propagar nova vers√£o para meses futuros ***
                    adicionarLog(`   ‚ûï FASE 2: Propagando nova vers√£o para meses futuros`, 'importante');
                    
                    // Usar a fun√ß√£o de propaga√ß√£o que atualiza meses futuros
                    propagarEdicaoCompraParaTodosMeses(
                        contaEditando.nome, 
                        nome, 
                        compraEditada, 
                        parcelaBaseOriginal, 
                        mesBaseOriginal
                    );
                }
                
                // Atualizar tamb√©m a conta no array contas do m√™s atual
                const indexContaAtual = contas.findIndex(c => c.id === contaEditando.id);
                if (indexContaAtual !== -1) {
                    const pessoaNaConta = contas[indexContaAtual].pessoas.find(p => p.nome === nome);
                    if (pessoaNaConta) {
                        pessoaNaConta.compras = [compraEditada];
                        pessoaNaConta.valor = valorParcela;
                        pessoaNaConta.valorTotal = valorTotal;
                        pessoaNaConta.parcelas = parcelasTexto;
                        pessoaNaConta.observacoes = observacoes;
                        pessoaNaConta.parcelasJaPagas = jaPagas;
                        adicionarLog(`   ‚úÖ Conta atual atualizada`, 'success');
                    }
                }
                
                // Salvar altera√ß√µes
                adicionarLog(`   üíæ Salvando altera√ß√µes...`, 'info');
                salvarNoStorage();
                
                // Recarregar do storage
                const dadosAtualizados = localStorage.getItem('todasContas');
                if (dadosAtualizados) {
                    todasContas = JSON.parse(dadosAtualizados);
                    adicionarLog(`   ‚úÖ Dados recarregados do storage`, 'success');
                }
                
                carregarContasMesAtual();
                renderizarContas();
                
                adicionarLog(`‚úÖ salvarEdicaoPessoaTemp CONCLU√çDA COM SUCESSO`, 'importante');
            }
            
            renderizarPessoasForm();
            fecharModalForm();

            // Sincroniza e salva apenas se N√ÉO estivermos no modal principal (Clique Longo)
            if (contaEditando && !document.getElementById('modal').classList.contains('ativo')) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
                salvarNoStorage();
                carregarContasMesAtual();
                renderizarContas();
                contaEditando = null;
                pessoasTemp = [];
            } else if (contaEditando) {
                contaEditando.pessoas = JSON.parse(JSON.stringify(pessoasTemp));
            }
        }

        function renderizarPessoasForm() {
            const lista = document.getElementById('pessoasLista');
            if (pessoasTemp.length === 0) {
                lista.innerHTML = '<p style="color: #999; text-align: center; font-size: 12px;">Nenhuma pessoa/parcela adicionada</p>';
                return;
            }
            
            // Agrupar parcerias
            const parcerias = new Map();
            const pessoasIndividuais = [];
            
            pessoasTemp.forEach((p, i) => {
                const temCompras = p.compras && p.compras.length > 0;
                const ehParceria = temCompras && p.compras[0]._parceria;
                
                if (ehParceria) {
                    const compra = p.compras[0];
                    const idBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                    
                    if (!parcerias.has(idBase)) {
                        parcerias.set(idBase, {
                            nome: compra.nome,
                            parcelas: compra.parcelas,
                            valorTotal: 0,
                            pessoas: []
                        });
                    }
                    
                    const grupo = parcerias.get(idBase);
                    grupo.valorTotal += p.valor;
                    grupo.pessoas.push({ pessoa: p, indice: i });
                } else {
                    pessoasIndividuais.push({ pessoa: p, indice: i });
                }
            });
            
            let html = '';
            
            // Renderizar parcerias como um √∫nico item
            parcerias.forEach((grupo, idBase) => {
                const primeiroIndice = grupo.pessoas[0].indice;
                html += `
                    <div class="pessoa-item">
                        <span>${grupo.nome} ${grupo.parcelas ? `(${grupo.parcelas})` : ''}: R$ ${grupo.valorTotal.toFixed(2)} üë•</span>
                        <div>
                            <button type="button" class="btn-editar-pessoa" onclick="abrirMenuPessoaTemp(${primeiroIndice})">‚úèÔ∏è</button>
                        </div>
                    </div>
                `;
            });
            
            // Renderizar pessoas individuais
            pessoasIndividuais.forEach(({ pessoa: p, indice: i }) => {
                const temCompras = p.compras && p.compras.length > 0;
                const qtdCompras = temCompras ? p.compras.length : 0;
                
                // Determinar o texto a exibir
                let textoCompras = '';
                if (qtdCompras > 0) {
                    textoCompras = `(${qtdCompras}C)`;
                } else if (p.parcelas) {
                    // Se n√£o tem compras mas tem parcelas, mostrar as parcelas
                    textoCompras = `(${p.parcelas})`;
                }
                
                html += `
                    <div class="pessoa-item">
                        <span>${p.nome} ${textoCompras}: R$ ${p.valor.toFixed(2)}</span>
                        <div>
                            <button type="button" class="btn-editar-pessoa" onclick="abrirMenuPessoaTemp(${i})">‚úèÔ∏è</button>
                        </div>
                    </div>
                `;
            });
            
            lista.innerHTML = html;
        }

        function salvarConta(e) {
            e.preventDefault();
            
            const meuValor = parseFloat(document.getElementById('meuValor').value) || 0;
            
            const pessoas = [...pessoasTemp];
            
            adicionarLog(`üìã IN√çCIO salvarConta()`, 'importante');
            adicionarLog(`   Editando? ${contaEditando ? 'SIM' : 'N√ÉO'}`, 'info');
            adicionarLog(`   Meu Valor: R$ ${meuValor.toFixed(2)}`, 'info');
            adicionarLog(`   pessoasTemp inicial: ${pessoasTemp.length} pessoas`, 'info');
            pessoasTemp.forEach((p, i) => {
                adicionarLog(`      ${i+1}. ${p.nome} - Compras: ${p.compras ? p.compras.length : 0}`, 'info');
            });
            
            if (meuValor > 0) {
                let numParcelas, parcelaAtual, parcelasTexto, valorParcela;
                const ehRecorrente = document.getElementById('contaRecorrente').checked;
                const jaPagas = (document.getElementById('compraEmAndamento').checked) ? (parseInt(document.getElementById('parcelasJaPagas').value) || 0) : 0;
                
                if (ehRecorrente) {
                    numParcelas = 1;
                    valorParcela = meuValor;
                    parcelasTexto = 'recorrente';
                } else if (document.getElementById('compraEmAndamento').checked) {
                    numParcelas = parseInt(document.getElementById('numeroParcelas').value) || 1;
                    parcelaAtual = jaPagas + 1;
                    valorParcela = meuValor / numParcelas;
                    parcelasTexto = numParcelas > 1 ? `${parcelaAtual}/${numParcelas}` : '';
                } else {
                    numParcelas = parseInt(document.getElementById('numeroParcelas').value) || 1;
                    valorParcela = meuValor / numParcelas;
                    parcelasTexto = numParcelas > 1 ? `1/${numParcelas}` : '';
                }
                
                const tipoTransacao = document.getElementById('tipoTransacao').value;
                const nomeCompraForm = document.getElementById('nomeCompra').value.trim();
                const nomeCompraInicial = nomeCompraForm || (tipoTransacao === 'recebimento' ? 'Recebimento inicial' : 'Compra inicial');
                const observacoesForm = document.getElementById('observacoes').value || '';
                
                const dataCompraAtual = new Date().toISOString();
                const chaveAtual = getChaveMes();
                
                const novaCompra = {
                    nome: nomeCompraInicial,
                    valorTotal: meuValor,
                    valorParcela: valorParcela,
                    parcelas: parcelasTexto,
                    dataCompra: new Date().toLocaleDateString('pt-BR'),
                    idUnico: dataCompraAtual + '_' + nomeCompraInicial,
                    observacoes: observacoesForm,
                    _parcelaBase: (document.getElementById('compraEmAndamento').checked) ? (jaPagas + 1) : 1,
                    _mesBase: chaveAtual
                };
                
                adicionarLog(`üí∞ PROCESSANDO "MEU VALOR"`, 'importante');
                adicionarLog(`   Valor: R$ ${meuValor.toFixed(2)}`, 'info');
                adicionarLog(`   Nome da compra: ${nomeCompraInicial}`, 'info');
                adicionarLog(`   Pessoas em pessoasTemp: ${pessoasTemp.length}`, 'info');
                pessoasTemp.forEach((p, i) => {
                    adicionarLog(`      ${i+1}. ${p.nome} - Compras: ${p.compras ? p.compras.length : 0}`, 'info');
                    if (p.compras) {
                        p.compras.forEach(c => {
                            adicionarLog(`         - ${c.nome} (Parceria: ${c._parceria ? 'SIM' : 'N√ÉO'})`, 'info');
                        });
                    }
                });
                adicionarLog(`   Pessoas em array "pessoas": ${pessoas.length}`, 'info');
                pessoas.forEach((p, i) => {
                    adicionarLog(`      ${i+1}. ${p.nome}`, 'info');
                });
                
                // *** CORRE√á√ÉO: Verificar se "Eu" j√° existe em pessoas ***
                const euExistente = pessoas.find(p => p.nome === 'Eu');
                adicionarLog(`   Eu j√° existe? ${euExistente ? 'SIM' : 'N√ÉO'}`, euExistente ? 'success' : 'warning');
                
                if (euExistente) {
                    // "Eu" j√° existe - adicionar compra
                    if (!euExistente.compras) {
                        euExistente.compras = [];
                    }
                    euExistente.compras.push(novaCompra);
                    
                    // Recalcular valores somando TODAS as compras
                    euExistente.valor = euExistente.compras.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                    euExistente.valorTotal = euExistente.compras.reduce((sum, c) => sum + (c.valorTotal || 0), 0);
                    
                    // Atualizar parcelas (usar a primeira compra como refer√™ncia)
                    if (euExistente.compras.length > 0) {
                        euExistente.parcelas = euExistente.compras[0].parcelas;
                    }
                    
                    adicionarLog(`   ‚úÖ Compra adicionada a "Eu" existente`, 'success');
                    adicionarLog(`      Total de compras de "Eu": ${euExistente.compras.length}`, 'info');
                    adicionarLog(`      Valor atualizado: R$ ${euExistente.valor.toFixed(2)}`, 'info');
                    
                    // *** CR√çTICO: Remover "Eu" de pessoasTemp para n√£o reprocessar ***
                    const indexEuTemp = pessoasTemp.findIndex(p => p.nome === 'Eu');
                    if (indexEuTemp !== -1) {
                        pessoasTemp.splice(indexEuTemp, 1);
                        adicionarLog(`   üóëÔ∏è "Eu" removido de pessoasTemp para evitar duplica√ß√£o`, 'warning');
                    }
                } else {
                    // "Eu" n√£o existe - criar
                    pessoas.unshift({
                        nome: 'Eu',
                        valor: valorParcela,
                        valorTotal: meuValor,
                        parcelas: parcelasTexto,
                        compras: [novaCompra],
                        pago: false
                    });
                    
                    adicionarLog(`   ‚úÖ "Eu" criado com a compra`, 'success');
                }
            }
            
            adicionarLog(`üìä PESSOAS FINAIS antes de criar conta:`, 'importante');
            adicionarLog(`   Total: ${pessoas.length}`, 'info');
            pessoas.forEach((p, i) => {
                adicionarLog(`      ${i+1}. ${p.nome} - Valor: R$ ${p.valor.toFixed(2)} - Compras: ${p.compras ? p.compras.length : 0}`, 'info');
                if (p.compras) {
                    p.compras.forEach((c, ci) => {
                        adicionarLog(`         ${ci+1}. ${c.nome} - R$ ${c.valorParcela.toFixed(2)} (Parceria: ${c._parceria ? 'SIM' : 'N√ÉO'})`, 'info');
                    });
                }
            });
            
            const nomeContaNovo = document.getElementById('nomeConta').value;
            const nomeContaAntigo = contaEditando ? contaEditando.nome : null;
            
            const conta = {
                id: contaEditando ? contaEditando.id : Date.now(),
                nome: nomeContaNovo,
                tipoTransacao: document.getElementById('tipoTransacao').value,
                tipo: document.getElementById('tipoConta').value,
                limiteTotal: parseFloat(document.getElementById('limiteTotal').value) || 0,
                diaFechamento: document.getElementById('diaFechamento').value ? parseInt(document.getElementById('diaFechamento').value) : null,
                diaVencimento: document.getElementById('diaVencimento').value ? parseInt(document.getElementById('diaVencimento').value) : null,
                observacoes: document.getElementById('observacoes').value || null,
                pessoas: pessoas,
                pago: document.getElementById('contaPaga').checked
            };
            
            // Verificar se h√° compra em andamento para adicionar meses retroativos
            const ehCompraEmAndamento = document.getElementById('compraEmAndamento').checked;
            const jaPagas = ehCompraEmAndamento ? (parseInt(document.getElementById('parcelasJaPagas').value) || 0) : 0;
            
            if (contaEditando) {
                const index = contas.findIndex(c => c.id === contaEditando.id);
                const contaExistente = contas[index];
                
                // ==========================================
                // VERIFICAR SE O NOME DA CONTA MUDOU
                // ==========================================
                if (nomeContaAntigo && nomeContaAntigo !== nomeContaNovo) {
                    adicionarLog(`üîÑ NOME DA CONTA MUDOU: "${nomeContaAntigo}" ‚Üí "${nomeContaNovo}"`, 'importante');
                    
                    // Atualizar nome em TODOS os meses
                    Object.keys(todasContas).forEach(chaveMes => {
                        const contasMes = todasContas[chaveMes];
                        const contaEncontrada = contasMes.find(c => c.nome === nomeContaAntigo);
                        
                        if (contaEncontrada) {
                            contaEncontrada.nome = nomeContaNovo;
                            adicionarLog(`   ‚úÖ M√™s ${chaveMes}: Nome atualizado`, 'success');
                        }
                    });
                }
                
                // ==========================================
                // ATUALIZAR PROPRIEDADES DA CONTA EM TODOS OS MESES
                // ==========================================
                Object.keys(todasContas).forEach(chaveMes => {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === nomeContaNovo);
                    
                    if (contaEncontrada) {
                        contaEncontrada.tipo = conta.tipo;
                        contaEncontrada.tipoTransacao = conta.tipoTransacao;
                        contaEncontrada.limiteTotal = conta.limiteTotal;
                        contaEncontrada.diaFechamento = conta.diaFechamento;
                        contaEncontrada.diaVencimento = conta.diaVencimento;
                        contaEncontrada.observacoes = conta.observacoes;
                    }
                });
                
                // N√ÉO preservar o estado de pagamento - ser√° recalculado ao final
                
                // ==========================================
                // AN√ÅLISE: O QUE O USU√ÅRIO EST√Å FAZENDO?
                // ==========================================
                
                const meuValorPreenchido = parseFloat(document.getElementById('meuValor').value) || 0;
                const temNovasPessoasTemp = pessoasTemp.length > 0;
                
                // *** CORRE√á√ÉO CR√çTICA: Verificar se "Eu" est√° em pessoasTemp (foi editado) ***
                const pessoaEuEmTemp = pessoasTemp.find(p => p.nome === 'Eu');
                
                // Identificar pessoas que foram REMOVIDAS
                const pessoaEuExistia = contaExistente.pessoas.find(p => p.nome === 'Eu');
                const nomesPessoasNovas = [...pessoasTemp.map(p => p.nome)];
                
                // Se "Eu" j√° existia E n√£o preencheu meuValor E n√£o est√° em pessoasTemp, manter na lista
                if (meuValorPreenchido > 0) {
                    nomesPessoasNovas.push('Eu');
                } else if (pessoaEuExistia && !pessoaEuEmTemp) {
                    // Se "Eu" j√° existia e n√£o est√° sendo editado, manter
                    nomesPessoasNovas.push('Eu');
                }
                
                const pessoasRemovidas = contaExistente.pessoas.filter(p => 
                    !nomesPessoasNovas.includes(p.nome)
                );
                
                // Remover apenas pessoas que foram REALMENTE deletadas de TODOS os meses
                pessoasRemovidas.forEach(pessoaRemovida => {
                    removerPessoaDeTodosOsMeses(nomeContaNovo, pessoaRemovida.nome);
                });
                
                // ==========================================
                // CONSTRUIR LISTA FINAL DE PESSOAS
                // ==========================================
                
                const pessoasFinais = [];
                
                // ==========================================
                // PROCESSAR "EU"
                // ==========================================
                
                const pessoaEuExistente = contaExistente.pessoas.find(p => p.nome === 'Eu' && !p.compras?.some(c => c._parceria));
                
                // *** NOVA L√ìGICA: Verificar se "Eu" foi editado atrav√©s de pessoasTemp ***
                if (pessoaEuEmTemp) {
                    // "Eu" FOI EDITADO atrav√©s do modal de edi√ß√£o (pessoasTemp)
                    adicionarLog(`‚úèÔ∏è "Eu" FOI EDITADO via pessoasTemp`, 'importante');
                    
                    if (pessoaEuExistente) {
                        // Remover compras antigas de "Eu" INDIVIDUAL de todos os meses
                        if (pessoaEuExistente.compras && pessoaEuExistente.compras.length > 0) {
                            pessoaEuExistente.compras.forEach(compraAntiga => {
                                if (!compraAntiga._parceria) {
                                    excluirCompraDeTodosOsMeses(nomeContaNovo, 'Eu', compraAntiga.idUnico);
                                }
                            });
                        }
                    }
                    
                    // Adicionar vers√£o editada de pessoasTemp
                    pessoasFinais.push(pessoaEuEmTemp);
                    
                    // Propagar compras editadas
                    if (pessoaEuEmTemp.compras && pessoaEuEmTemp.compras.length > 0) {
                        const comprasNaoParceria = pessoaEuEmTemp.compras.filter(c => !c._parceria);
                        if (comprasNaoParceria.length > 0) {
                            propagarComprasParaTodosMeses(nomeContaNovo, [{
                                ...pessoaEuEmTemp,
                                compras: comprasNaoParceria
                            }]);
                        }
                    }
                    
                    if (pessoaEuEmTemp.parcelasJaPagas && pessoaEuEmTemp.parcelasJaPagas > 0) {
                        adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [pessoaEuEmTemp], pessoaEuEmTemp.parcelasJaPagas);
                    }
                    
                } else if (meuValorPreenchido > 0) {
                    // Usu√°rio PREENCHEU "Meu Valor" = Quer ADICIONAR ou EDITAR "Eu" pelo campo
                    const pessoaEuNova = conta.pessoas.find(p => p.nome === 'Eu');
                    
                    if (pessoaEuExistente) {
                        // "Eu" J√Å EXISTIA = EDI√á√ÉO pelo campo "Meu Valor"
                        
                        // Remover compras antigas de "Eu" INDIVIDUAL de todos os meses
                        if (pessoaEuExistente.compras && pessoaEuExistente.compras.length > 0) {
                            pessoaEuExistente.compras.forEach(compraAntiga => {
                                if (!compraAntiga._parceria) {
                                    excluirCompraDeTodosOsMeses(nomeContaNovo, 'Eu', compraAntiga.idUnico);
                                }
                            });
                        }
                        
                        // Adicionar novas compras de "Eu" em todos os meses
                        if (pessoaEuNova && pessoaEuNova.compras && pessoaEuNova.compras.length > 0) {
                            const comprasNaoParceria = pessoaEuNova.compras.filter(c => !c._parceria);
                            if (comprasNaoParceria.length > 0) {
                                propagarComprasParaTodosMeses(nomeContaNovo, [{
                                    ...pessoaEuNova,
                                    compras: comprasNaoParceria
                                }]);
                            }
                        }
                        
                        pessoasFinais.push(pessoaEuNova);
                        
                        const ehCompraEmAndamento = document.getElementById('compraEmAndamento').checked;
                        const jaPagas = ehCompraEmAndamento ? (parseInt(document.getElementById('parcelasJaPagas').value) || 0) : 0;
                        if (jaPagas > 0 && pessoaEuNova) {
                            adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [pessoaEuNova], jaPagas);
                        }
                        
                    } else {
                        // "Eu" N√ÉO EXISTIA = NOVA ADI√á√ÉO
                        pessoasFinais.push(pessoaEuNova);
                        
                        if (pessoaEuNova && pessoaEuNova.compras && pessoaEuNova.compras.length > 0) {
                            const comprasNaoParceria = pessoaEuNova.compras.filter(c => !c._parceria);
                            if (comprasNaoParceria.length > 0) {
                                propagarComprasParaTodosMeses(nomeContaNovo, [{
                                    ...pessoaEuNova,
                                    compras: comprasNaoParceria
                                }]);
                            }
                        }
                        
                        if (pessoaEuNova && pessoaEuNova.parcelasJaPagas && pessoaEuNova.parcelasJaPagas > 0) {
                            adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [pessoaEuNova], pessoaEuNova.parcelasJaPagas);
                        }
                    }
                    
                } else {
                    // Usu√°rio N√ÉO preencheu "Meu Valor" E "Eu" n√£o est√° em pessoasTemp
                    
                    if (pessoaEuExistente) {
                        // "Eu" existe e n√£o foi tocado = MANTER COMO EST√Å
                        pessoasFinais.push(pessoaEuExistente);
                    }
                    // Se n√£o existe "Eu" e n√£o preencheu = n√£o adicionar
                }
                
                // ==========================================
                // PROCESSAR OUTRAS PESSOAS (pessoasTemp) - MANTENDO ORDEM
                // ==========================================
                
                adicionarLog(`üîÑ Processando pessoasTemp (${pessoasTemp.length} pessoas restantes)`, 'info');
                
                // *** NOVA L√ìGICA: Processar na ordem, verificando se existia antes ***
                pessoasTemp.forEach(novaPessoa => {
                    adicionarLog(`   Processando: ${novaPessoa.nome}`, 'info');
                    
                    const pessoaExistente = contaExistente.pessoas.find(p => p.nome === novaPessoa.nome);
                    
                    adicionarLog(`üîç Processando pessoa: ${novaPessoa.nome}`, 'info');
                    if (novaPessoa.parcelasJaPagas) {
                        adicionarLog(`   üìã Possui ${novaPessoa.parcelasJaPagas} parcelas j√° pagas`, 'warning');
                    }
                    
                    if (pessoaExistente) {
                        // Pessoa J√Å EXISTIA = Verificar se foi REALMENTE editada
                    adicionarLog(`üîç Processando pessoa: ${novaPessoa.nome}`, 'info');
                        if (novaPessoa.compras && novaPessoa.compras[0]) {
                            adicionarLog(`   üìã Parcela Base: ${novaPessoa.compras[0]._parcelaBase}, M√™s Base: ${novaPessoa.compras[0]._mesBase}`, 'info');
                            if (novaPessoa.parcelasJaPagas) {
                                adicionarLog(`   üìã Possui ${novaPessoa.parcelasJaPagas} parcelas j√° pagas`, 'info');
                            }
                        }
                        
                        // Comparar se as compras mudaram OU se parcelas j√° pagas mudaram
                        let foiEditada = false;
                        
                        // FOR√áAR LOG DETALHADO
                        adicionarLog(`   üîé Comparando dados antigos vs novos:`, 'info');
                        
                        if (pessoaExistente.compras && novaPessoa.compras) {
                            // Comparar IDs das compras
                            const idsAntigos = pessoaExistente.compras.map(c => c.idUnico).sort().join(',');
                            const idsNovos = novaPessoa.compras.map(c => c.idUnico).sort().join(',');
                            
                            adicionarLog(`      IDs antigos: ${idsAntigos}`, 'info');
                            adicionarLog(`      IDs novos: ${idsNovos}`, 'info');
                            
                            if (idsAntigos !== idsNovos) {
                                foiEditada = true;
                                adicionarLog(`   üìù IDs das compras mudaram`, 'warning');
                            }
                            
                            // COMPARAR TAMB√âM O CONTE√öDO DAS COMPRAS
                            pessoaExistente.compras.forEach((compraAntiga, idx) => {
                                const compraNova = novaPessoa.compras.find(c => c.idUnico === compraAntiga.idUnico);
                                
                                if (compraNova) {
                                    if (compraAntiga.nome !== compraNova.nome) {
                                        foiEditada = true;
                                        adicionarLog(`      Nome mudou: "${compraAntiga.nome}" ‚Üí "${compraNova.nome}"`, 'warning');
                                    }
                                    
                                    if (compraAntiga.valorTotal !== compraNova.valorTotal) {
                                        foiEditada = true;
                                        adicionarLog(`      Valor total mudou: R$ ${compraAntiga.valorTotal} ‚Üí R$ ${compraNova.valorTotal}`, 'warning');
                                    }
                                    
                                    const parcelasAntigas = compraAntiga.parcelas || '';
                                    const parcelasNovas = compraNova.parcelas || '';
                                    
                                    if (parcelasAntigas !== parcelasNovas) {
                                        const matchAntigo = parcelasAntigas.match(/\/(\d+)/);
                                        const matchNovo = parcelasNovas.match(/\/(\d+)/);
                                        
                                        const totalAntigo = matchAntigo ? parseInt(matchAntigo[1]) : 1;
                                        const totalNovo = matchNovo ? parseInt(matchNovo[1]) : 1;
                                        
                                        if (totalAntigo !== totalNovo) {
                                            foiEditada = true;
                                            adicionarLog(`      N√∫mero de parcelas mudou: ${totalAntigo} ‚Üí ${totalNovo}`, 'warning');
                                        }
                                    }
                                    
                                    if (compraAntiga._parcelaBase !== compraNova._parcelaBase) {
                                        foiEditada = true;
                                        adicionarLog(`      Parcela base mudou: ${compraAntiga._parcelaBase} ‚Üí ${compraNova._parcelaBase}`, 'warning');
                                    }
                                }
                            });
                        }
                        
                        // Verificar mudan√ßa em parcelas j√° pagas
                        const parcelasJaPagasAntigas = pessoaExistente.parcelasJaPagas || 0;
                        const parcelasJaPagasNovas = novaPessoa.parcelasJaPagas || 0;
                        
                        adicionarLog(`      Parcelas j√° pagas antigas: ${parcelasJaPagasAntigas}`, 'info');
                        adicionarLog(`      Parcelas j√° pagas novas: ${parcelasJaPagasNovas}`, 'info');
                        
                        if (parcelasJaPagasAntigas !== parcelasJaPagasNovas) {
                            foiEditada = true;
                            adicionarLog(`   üìù Parcelas j√° pagas mudaram: ${parcelasJaPagasAntigas} ‚Üí ${parcelasJaPagasNovas}`, 'warning');
                        }
                        
                        // Verificar mudan√ßa no valor total
                        const valorTotalAntigo = pessoaExistente.valorTotal || pessoaExistente.valor;
                        const valorTotalNovo = novaPessoa.valorTotal || novaPessoa.valor;
                        
                        if (valorTotalAntigo !== valorTotalNovo) {
                            foiEditada = true;
                            adicionarLog(`   üìù Valor total mudou: R$ ${valorTotalAntigo} ‚Üí R$ ${valorTotalNovo}`, 'warning');
                        }
                        
                        adicionarLog(`   üéØ Resultado: ${foiEditada ? 'FOI EDITADA' : 'N√ÉO foi editada'}`, foiEditada ? 'importante' : 'info');
                        
                        if (foiEditada) {
                            adicionarLog(`‚úèÔ∏è Pessoa foi REALMENTE editada: ${novaPessoa.nome}`, 'warning');
                            
                            // Remover compras antigas
                            if (pessoaExistente.compras && pessoaExistente.compras.length > 0) {
                                adicionarLog(`   üóëÔ∏è Removendo ${pessoaExistente.compras.length} compras antigas`, 'info');
                                pessoaExistente.compras.forEach(compraAntiga => {
                                    excluirCompraDeTodosOsMeses(nomeContaNovo, novaPessoa.nome, compraAntiga.idUnico);
                                });
                            }
                            
                            // Remover parcelas retroativas antigas
                            if (parcelasJaPagasAntigas > 0) {
                                adicionarLog(`   üóëÔ∏è Removendo ${parcelasJaPagasAntigas} parcelas retroativas antigas`, 'warning');
                            }
                            
                            // PRIMEIRO: Adicionar parcelas retroativas
                            if (novaPessoa.parcelasJaPagas && novaPessoa.parcelasJaPagas > 0) {
                                adicionarLog(`   üîÑ Processando ${novaPessoa.parcelasJaPagas} parcelas retroativas`, 'warning');
                                adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [novaPessoa], novaPessoa.parcelasJaPagas);
                            }
                            
                            // DEPOIS: Propagar para meses futuros
                            if (novaPessoa.compras && novaPessoa.compras.length > 0) {
                                adicionarLog(`   üì§ Propagando ${novaPessoa.compras.length} compras para meses futuros`, 'info');
                                propagarComprasParaTodosMeses(nomeContaNovo, [novaPessoa]);
                            }
                            
                            // *** ADICIONAR √† lista na ordem correta ***
                            pessoasFinais.push(novaPessoa);
                        } else {
                            adicionarLog(`‚úì Pessoa n√£o foi editada, mantendo: ${novaPessoa.nome}`, 'info');
                            
                            // *** ADICIONAR pessoa n√£o editada na ordem correta ***
                            if (!pessoasFinais.some(p => p.nome === pessoaExistente.nome)) {
                                pessoasFinais.push(pessoaExistente);
                            }
                        }
                        
                        // GARANTIR _parcelaBase e _mesBase nas compras
                        if (foiEditada && novaPessoa.compras && novaPessoa.compras.length > 0) {
                            novaPessoa.compras.forEach(compra => {
                                if (!compra._parcelaBase || !compra._mesBase) {
                                    const chaveAtual = getChaveMes();
                                    compra._parcelaBase = novaPessoa.parcelasJaPagas 
                                        ? (novaPessoa.parcelasJaPagas + 1) 
                                        : (compra.parcelas && compra.parcelas.match(/(\d+)\//) 
                                            ? parseInt(compra.parcelas.match(/(\d+)\//)[1]) 
                                            : 1);
                                    compra._mesBase = chaveAtual;
                                }
                            });
                        }
                        
                    } else {
                        // Pessoa N√ÉO EXISTIA = NOVA
                        adicionarLog(`‚ûï Adicionando nova pessoa: ${novaPessoa.nome}`, 'success');
                        
                        pessoasFinais.push(novaPessoa);
                        
                        // PRIMEIRO: Adicionar parcelas retroativas (ANTES de propagar)
                        if (novaPessoa.parcelasJaPagas && novaPessoa.parcelasJaPagas > 0) {
                            adicionarLog(`   üîÑ Processando ${novaPessoa.parcelasJaPagas} parcelas retroativas ANTES de propagar`, 'warning');
                            adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [novaPessoa], novaPessoa.parcelasJaPagas);
                        }
                        
                        // DEPOIS: Propagar para meses futuros
                        if (novaPessoa.compras && novaPessoa.compras.length > 0) {
                            adicionarLog(`   üì§ Propagando ${novaPessoa.compras.length} compras para meses futuros`, 'info');
                            propagarComprasParaTodosMeses(nomeContaNovo, [novaPessoa]);
                        }
                        
                        conta.pago = false;
                    }
                });
                
                // ==========================================
                // REMOVER A SE√á√ÉO ANTIGA DE "ADICIONAR PESSOAS QUE N√ÉO FORAM TOCADAS"
                // N√£o precisamos mais dela pois j√° adicionamos tudo na ordem certa acima
                // ==========================================
                
                adicionarLog(`üìã pessoasFinais antes de atribuir √† conta:`, 'importante');
                adicionarLog(`   Total: ${pessoasFinais.length}`, 'info');
                pessoasFinais.forEach((p, i) => {
                    adicionarLog(`      ${i+1}. ${p.nome} - Compras: ${p.compras ? p.compras.length : 0}`, 'info');
                });
                
                // ==========================================
                // FINALIZAR
                // ==========================================
                
                conta.pessoas = pessoasFinais;
                contas[index] = conta;
                
                // Ativar fun√ß√£o retroativa para "Meu Valor" em caso de edi√ß√£o
                const jaPagasEdicao = (document.getElementById('compraEmAndamento').checked) ? (parseInt(document.getElementById('parcelasJaPagas').value) || 0) : 0;
                if (jaPagasEdicao > 0) {
                    const pEu = pessoasFinais.find(p => p.nome === 'Eu');
                    if (pEu) {
                        adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [pEu], jaPagasEdicao);
                    }
                }

                // Ativar para outras pessoas editadas/adicionadas
                pessoasFinais.forEach(pf => {
                    if (pf.parcelasJaPagas > 0) {
                        adicionarCompraEmAndamentoRetroativa(nomeContaNovo, [pf], pf.parcelasJaPagas);
                    }
                });
                
            } else {
                contas.push(conta);
                adicionarLog(`üÜï NOVA CONTA CRIADA: ${conta.nome}`, 'importante');
                adicionarLog(`   Pessoas adicionadas: ${conta.pessoas.map(p => p.nome).join(', ')}`, 'info');
                
                // PRIMEIRO: Propagar para meses futuros (cria estrutura base)
                adicionarLog(`üì§ Propagando compras para meses futuros...`, 'info');
                propagarComprasParaTodosMeses(conta.nome, conta.pessoas);
                
                // DEPOIS: Adicionar parcelas retroativas (sobrescreve/adiciona nos meses passados)
                // Se for compra em andamento DO MEU VALOR, adicionar aos meses anteriores
                if (ehCompraEmAndamento && jaPagas > 0) {
                    adicionarLog(`üîÑ Processando "Eu" com ${jaPagas} parcelas j√° pagas`, 'warning');
                    const pessoaEu = conta.pessoas.find(p => p.nome === 'Eu');
                    if (pessoaEu) {
                        adicionarCompraEmAndamentoRetroativa(conta.nome, [pessoaEu], jaPagas);
                    }
                }
                
                // Processar parcelas retroativas de TODAS as pessoasTemp
                pessoasTemp.forEach(pessoaTemp => {
                    if (pessoaTemp.parcelasJaPagas && pessoaTemp.parcelasJaPagas > 0) {
                        adicionarLog(`üîÑ Processando "${pessoaTemp.nome}" com ${pessoaTemp.parcelasJaPagas} parcelas j√° pagas`, 'warning');
                        adicionarCompraEmAndamentoRetroativa(conta.nome, [pessoaTemp], pessoaTemp.parcelasJaPagas);
                    }
                });
                
                adicionarLog(`‚úÖ CONTA SALVA COM SUCESSO!`, 'success');
            }
            
            // ========================================
            // Recalcular status de pagamento da conta
            // A conta s√≥ est√° paga se TODAS as pessoas est√£o pagas
            const todasPessoasPagas = conta.pessoas.length > 0 && conta.pessoas.every(p => p.pago);
            conta.pago = todasPessoasPagas;
            
            // Salvar SEMPRE, independente do fluxo
            salvarNoStorage();
            
            // FOR√áAR recarga completa do localStorage
            const dadosAtualizados = localStorage.getItem('todasContas');
            if (dadosAtualizados) {
                todasContas = JSON.parse(dadosAtualizados);
            }
            
            // Recarregar para garantir consist√™ncia
            carregarContasMesAtual();
            
            // Renderizar com dados atualizados
            renderizarContas();
            
            // Fechar modal
            fecharModal();
        }

        function excluirConta(id) {
            const conta = contas.find(c => c.id === id);
            const chaveAtual = getChaveMes();
            
            // Verificar se a conta est√° vazia (sem compras ou recebimentos)
            const contaVazia = !conta.pessoas || conta.pessoas.length === 0;
            
            if (contaVazia) {
                // Conta vazia - excluir APENAS do m√™s atual, preservando hist√≥rico
                const confirmacao = confirm(`‚ö†Ô∏è ATEN√á√ÉO!\n\nDeseja excluir a conta "${conta.nome}" APENAS do m√™s atual?\n\nO hist√≥rico de meses anteriores ser√° PRESERVADO.`);
                if (!confirmacao) return;
                
                // Remover APENAS do m√™s atual
                contas = contas.filter(c => c.id !== id);
                
                // Atualizar apenas o m√™s atual no todasContas
                if (todasContas[chaveAtual]) {
                    todasContas[chaveAtual] = todasContas[chaveAtual].filter(c => c.nome !== conta.nome);
                }
                
                adicionarLog(`üóëÔ∏è Conta "${conta.nome}" exclu√≠da apenas do m√™s atual. Hist√≥rico preservado.`, 'success');
            } else {
                // Conta com dados - excluir de TODOS os meses
                const confirmacao = confirm(`‚ö†Ô∏è ATEN√á√ÉO!\n\nDeseja realmente excluir a conta "${conta.nome}" de TODOS OS MESES?\n\nEsta a√ß√£o excluir√° TODO O HIST√ìRICO e n√£o pode ser desfeita!`);
                if (!confirmacao) return;
                
                const nomeConta = conta.nome;
                
                // Excluir de todos os meses
                Object.keys(todasContas).forEach(chaveMes => {
                    todasContas[chaveMes] = todasContas[chaveMes].filter(c => c.nome !== nomeConta);
                });
                
                // Remover do m√™s atual tamb√©m
                contas = contas.filter(c => c.id !== id);
                
                adicionarLog(`üóëÔ∏è Conta "${conta.nome}" exclu√≠da de TODOS os meses.`, 'warning');
            }
            
            // Salvar altera√ß√µes
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
            renderizarContas();
        }

        function togglePagoConta(id) {
            const conta = contas.find(c => c.id === id);
            
            if (conta.pago) {
                // Se est√° pago e quer desmarcar, perguntar confirma√ß√£o
                const confirmar = confirm(`‚ö†Ô∏è Desmarcar Pagamento\n\nDesmarcar "${conta.nome}" como paga?\n\nIsso desmarcar√° TODAS as pessoas/compras desta conta (incluindo parcerias).`);
                if (!confirmar) {
                    return;
                }
                
                // Desmarcar tudo
                conta.pago = false;
                conta.pessoas.forEach(p => p.pago = false);
            } else {
                // Se n√£o est√° pago e quer marcar, marcar tudo
                const confirmar = confirm(`‚úÖ Marcar como Pago\n\nMarcar "${conta.nome}" como paga?\n\nIsso marcar√° TODAS as pessoas/compras desta conta (incluindo parcerias).`);
                if (!confirmar) {
                    return;
                }
                
                conta.pago = true;
                conta.pessoas.forEach(p => p.pago = true);
            }
            
            // CR√çTICO: Salvar IMEDIATAMENTE
            salvarNoStorage();
            
            // Recarregar do storage para garantir consist√™ncia
            carregarContasMesAtual();
            
            // Renderizar com dados atualizados
            renderizarContas();
        }

        function togglePagoPessoa(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            const pessoa = conta.pessoas[pessoaIndex];
            
            if (conta.tipoTransacao === 'pagamento-custom' && !pessoa.pago) {
                abrirModalPagamentoCustom(contaId, pessoaIndex);
                return;
            }
            
            if (pessoa.pago) {
                let nomePessoa = pessoa.nome === 'Eu' && conta.tipoTransacao === 'recebimento' ? 'Devedor' : pessoa.nome;
                if (!confirm(`‚ö†Ô∏è Reverter Pagamento\n\nDesmarcar "${nomePessoa}" como pago?\n\nValor: R$ ${pessoa.valor.toFixed(2)}`)) return;
                delete pessoa._valorPagoReal;
            }
            
            // Inverte o status
            pessoa.pago = !pessoa.pago;
            
            // Sincroniza com o banco de dados global (todasContas)
            const chaveAtual = getChaveMes();
            if (todasContas[chaveAtual]) {
                const contaGlobal = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaGlobal && contaGlobal.pessoas[pessoaIndex]) {
                    contaGlobal.pessoas[pessoaIndex].pago = pessoa.pago;
                    if (!pessoa.pago) delete contaGlobal.pessoas[pessoaIndex]._valorPagoReal;
                }
            }
            
            // Recalcula status da conta
            conta.pago = conta.pessoas.every(p => p.pago);
            
            // CR√çTICO: Atualizar tamb√©m o status da conta no todasContas
            if (todasContas[chaveAtual]) {
                const contaGlobal = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaGlobal) {
                    contaGlobal.pago = conta.pago;
                }
            }
            
            // SALVA NO STORAGE
            localStorage.setItem('todasContas', JSON.stringify(todasContas));
            
            // RECARREGA TUDO EM TEMPO REAL PARA REAVALIAR VISIBILIDADE
            carregarContasMesAtual();
            renderizarContas();
            
            adicionarLog(`‚úÖ Status atualizado para ${pessoa.pago ? 'PAGO' : 'PENDENTE'}`, 'success');
        }

        function calcularTotal(conta) {
            return conta.pessoas.reduce((sum, p) => {
                const valorConsiderar = p._valorPagoReal !== undefined ? p._valorPagoReal : p.valor;
                return sum + valorConsiderar;
            }, 0);
        }

        function calcularLimiteDisponivel(conta) {
            if (!conta.limiteTotal) return 0;
            
            const chaveAtual = getChaveMes();
            let totalOcupadoGeral = 0;
            let totalLiberadoPorPagamentos = 0;
            
            // Percorrer TODOS os meses para calcular o total ocupado e o total liberado
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                
                if (contaEncontrada) {
                    contaEncontrada.pessoas.forEach(pessoa => {
                        if (pessoa.compras && pessoa.compras.length > 0) {
                            pessoa.compras.forEach(compra => {
                                // Verificar se a compra ainda n√£o foi totalmente paga
                                const parcelaMatch = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                
                                if (parcelaMatch) {
                                    const parcelaAtual = parseInt(parcelaMatch[1]);
                                    const totalParcelas = parseInt(parcelaMatch[2]);
                                    
                                    // Se for a primeira parcela, adiciona o valor total ao ocupado
                                    if (parcelaAtual === 1) {
                                        totalOcupadoGeral += compra.valorTotal;
                                    }
                                } else if (!compra.parcelas) {
                                    // Compra sem parcelamento
                                    totalOcupadoGeral += compra.valorTotal;
                                }
                                
                                // Se foi pago, adiciona ao total liberado
                                if (pessoa.pago) {
                                    totalLiberadoPorPagamentos += compra.valorParcela;
                                }
                            });
                        } else {
                            // Pessoa sem compras detalhadas
                            const parcelaMatch = pessoa.parcelas ? pessoa.parcelas.match(/(\d+)\/(\d+)/) : null;
                            
                            if (parcelaMatch) {
                                const parcelaAtual = parseInt(parcelaMatch[1]);
                                
                                if (parcelaAtual === 1) {
                                    totalOcupadoGeral += pessoa.valorTotal || pessoa.valor;
                                }
                            } else {
                                totalOcupadoGeral += pessoa.valorTotal || pessoa.valor;
                            }
                            
                            if (pessoa.pago) {
                                totalLiberadoPorPagamentos += pessoa.valor;
                            }
                        }
                    });
                }
            });
            
            return conta.limiteTotal - totalOcupadoGeral + totalLiberadoPorPagamentos;
        }
        
        function mostrarDetalhesParceria(idBase, contaId) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            // Encontrar todas as pessoas dessa parceria
            const pessoasDaParceria = conta.pessoas.filter(p => {
                if (p.compras && p.compras.length > 0 && p.compras[0]._parceria) {
                    const partesIdP = p.compras[0].idUnico.split('_');
                    const nomeCompraDessaPessoa = partesIdP.slice(0, -1).join('_');
                    const ehMesmaParceria = nomeCompraDessaPessoa === idBase;
                    return ehMesmaParceria;
                }
                return false;
            });
            
            if (pessoasDaParceria.length === 0) return;
            
            const primeiraCompra = pessoasDaParceria[0].compras[0];
            const nomeCompra = primeiraCompra.nome;
            
            // *** CORRE√á√ÉO: Calcular valor total COMPLETO da parceria (todas as parcelas) ***
            const match = primeiraCompra.parcelas ? primeiraCompra.parcelas.match(/(\d+)\/(\d+)/) : null;
            const totalParcelas = match ? parseInt(match[2]) : 1;
            
            // Valor do m√™s atual (soma de todas as pessoas)
            const valorMesAtual = pessoasDaParceria.reduce((sum, p) => {
                const compraParceria = p.compras.find(c => {
                    const partesId = c.idUnico.split('_');
                    const nomeCompraId = partesId.slice(0, -1).join('_');
                    return nomeCompraId === idBase && c._parceria;
                });
                return sum + (compraParceria ? compraParceria.valorParcela : 0);
            }, 0);
            
            // Valor TOTAL completo (todas as parcelas somadas)
            const valorCompletoParceria = valorMesAtual * totalParcelas;
            
            // Calcular valor j√° pago considerando TODOS os meses
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            let valorJaPago = 0;
            
            // Percorrer TODOS os meses at√© o atual
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                const ehMesAtual = chaveMes === chaveAtual;
                const deveContar = dataMes < dataAtualMes || (ehMesAtual && pessoasDaParceria.some(p => p.pago));
                
                if (deveContar) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                    
                    if (contaEncontrada) {
                        // Verificar se PELO MENOS UMA pessoa da parceria pagou neste m√™s
                        let algumaPessoaPagou = false;
                        let valorDaParcelaNesteMes = 0;
                        
                        contaEncontrada.pessoas.forEach(p => {
                            if (p.pago && p.compras && p.compras.length > 0) {
                                p.compras.forEach(compra => {
                                    if (compra._parceria) {
                                        const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                                        if (compraIdBase === idBase) {
                                            algumaPessoaPagou = true;
                                        }
                                    }
                                });
                            }
                        });
                        
                        // Se pelo menos uma pessoa pagou, somar o valor TOTAL da parcela
                        if (algumaPessoaPagou) {
                            contaEncontrada.pessoas.forEach(p => {
                                if (p.compras && p.compras.length > 0) {
                                    p.compras.forEach(compra => {
                                        if (compra._parceria) {
                                            const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                                            if (compraIdBase === idBase) {
                                                valorDaParcelaNesteMes += compra.valorParcela;
                                            }
                                        }
                                    });
                                }
                            });
                            
                            valorJaPago += valorDaParcelaNesteMes;
                        }
                    }
                }
            });
            
            const valorRestante = valorCompletoParceria - valorJaPago;
            
            const ehRecebimento = conta.tipoTransacao === 'recebimento';
            const icone = ehRecebimento ? 'üí∞' : 'üõí';
            
            const tipoIcone = conta.tipo === 'cartao' ? 'üí≥' : conta.tipo === 'boleto' ? 'üßæ' : conta.tipo === 'dinheiro' ? 'üíµ' : conta.tipo === 'pix' ? '‚ùñ' : 'ü™ô';
            const tipoNome = conta.tipo === 'cartao' ? 'Cart√£o de Cr√©dito' : conta.tipo === 'boleto' ? 'Boleto/Conta' : conta.tipo === 'dinheiro' ? 'Dinheiro' : conta.tipo === 'pix' ? 'PIX' : 'Outro';
            document.getElementById('modalDetalhesTitulo').innerHTML = `<div style="display: grid; grid-template-columns: 1fr auto; margin-top: -10px; align-items: start; padding-right: 0px; width: 100%;"><div><div style="font-size: 22px; font-weight: bold; color: #667eea; margin-bottom: 8px;">${conta.nome}</div></div><div style="font-size: 13px; color: #666; font-weight: 600; background: #f0f0f0; padding: 6px 6px; border-radius: 8px; white-space: nowrap;">${tipoIcone} ${tipoNome}</div></div>`;
            document.getElementById('modalDetalhesSubtitulo').innerHTML = `<strong>üë• ${nomeCompra} (Parceria)</strong>`;
            
            let conteudoHTML = '';
            
            // Cards de resumo (duas colunas)
            conteudoHTML += `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="padding: 12px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">Valor deste m√™s</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 20px;">R$ ${valorMesAtual.toFixed(2)}</div>
                    </div>
                    <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="padding: 12px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">üí∞ Valor Restante</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 20px;">R$ ${valorRestante.toFixed(2)}</div>
                    </div>
                </div>
            `;
            
            // Lista de pessoas em UM √öNICO BLOCO
            const primeiraCompraRef = pessoasDaParceria[0].compras.find(c => {
                const partesId = c.idUnico.split('_');
                const nomeCompraId = partesId.slice(0, -1).join('_');
                return nomeCompraId === idBase && c._parceria;
            });
            const todasPagas = pessoasDaParceria.every(p => p.pago);
            
            conteudoHTML += `
                <div class="modal-detalhes-secao">
                    <div class="modal-detalhes-secao-titulo">üë• Pessoas na Parceria</div>
                    
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 12px; border-left: 4px solid ${ehRecebimento ? '#28a745' : '#667eea'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="background: ${todasPagas ? '#28a745' : '#ffc107'}; color: ${todasPagas ? 'white' : '#333'}; padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: bold;">${todasPagas ? '‚úÖ PAGO' : '‚è≥ PENDENTE'}</span>
                            <span style="background: ${ehRecebimento ? '#28a745' : '#667eea'}; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: bold;">üìä Parcelas ${primeiraCompraRef.parcelas || '√önica'}</span>
                        </div>
                        
                        <div style="background: #e7f3ff; border-left: 4px solid #2196F3; padding: 10px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; color: #1976D2;">
                            <strong>üìã Compra:</strong> ${primeiraCompraRef.nome}<br>
                            <strong>üìÖ Data:</strong> ${primeiraCompraRef.dataCompra}<br>
                        </div>
            `;
            
            pessoasDaParceria.forEach((p, idx) => {
                const nomePessoa = p.nome === 'Eu' && ehRecebimento ? 'Devedor' : p.nome;
                
                const compraParceria = p.compras.find(c => {
                    const partesId = c.idUnico.split('_');
                    const nomeCompraId = partesId.slice(0, -1).join('_');
                    return nomeCompraId === idBase && c._parceria;
                });
                
                if (!compraParceria) return;
                
                const observacoes = compraParceria.observacoes || '';
                
                conteudoHTML += `
                    <div style="padding: 8px 0; ${idx < pessoasDaParceria.length - 1 ? 'border-bottom: 1px solid #e0e0e0;' : ''}">
                        <div style="font-weight: bold; color: #333; font-size: 14px; margin-bottom: 6px;">${idx + 1}. ${nomePessoa}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <div style="font-size: 12px; color: #666;">üí∞ Valor por Parcela</div>
                            <div style="font-weight: bold; color: ${ehRecebimento ? '#28a745' : '#667eea'}; font-size: 15px;">R$ ${compraParceria.valorParcela.toFixed(2)}</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 11px; color: #999;">üìä Valor Total (${nomePessoa})</div>
                            <div style="font-size: 12px; color: #666;">R$ ${compraParceria.valorTotal.toFixed(2)}</div>
                        </div>
                    </div>
                `;
            });
            
            conteudoHTML += `
                    </div>
            `;
            
            // Adicionar observa√ß√µes se existirem
            const primeiraCompraObs = pessoasDaParceria[0].compras.find(c => {
                const partesId = c.idUnico.split('_');
                const nomeCompraId = partesId.slice(0, -1).join('_');
                return nomeCompraId === idBase && c._parceria;
            });
            if (primeiraCompraObs && primeiraCompraObs.observacoes) {
                conteudoHTML += `
                    <div style="background: #e7f3ff; border-left: 4px solid #2196F3; padding: 12px; border-radius: 6px; margin-top: 12px;">
                        <div style="font-weight: bold; color: #1976D2; font-size: 12px; margin-bottom: 4px;">üìù Observa√ß√µes</div>
                        <div style="color: #1976D2; font-size: 13px; white-space: pre-wrap; word-break: break-word;">${primeiraCompraObs.observacoes}</div>
                    </div>
                `;
            }
            
            conteudoHTML += `
                </div>
            `;
            
            // Total do m√™s
            conteudoHTML += `
                <div class="modal-detalhes-total ${ehRecebimento ? 'recebimento' : ''}" style="cursor: pointer;" onclick="mostrarResumoDetalhadoParceria('${idBase.replace(/'/g, "\\'")}', ${contaId})" title="Clique para ver resumo completo">
                    <div class="modal-detalhes-total-label">TOTAL DAS COMPRAS üìä</div>
                    <div class="modal-detalhes-total-valor">R$ ${valorCompletoParceria.toFixed(2)}</div>
                </div>
            `;
            
            document.getElementById('modalDetalhesConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalDetalhes').classList.add('ativo');
        }
        
        function abrirModalMarcarParceria(idBase, contaId) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            // Encontrar todas as pessoas dessa parceria
            const pessoasParceria = [];
            const indicesPessoas = [];
            
            conta.pessoas.forEach((p, idx) => {
                if (p.compras && p.compras.length > 0) {
                    // Procurar SE esta pessoa tem alguma compra da parceria espec√≠fica
                    const temCompraDaParceria = p.compras.some(compra => {
                        if (compra._parceria) {
                            const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                            return compraIdBase === idBase;
                        }
                        return false;
                    });
                    
                    if (temCompraDaParceria) {
                        // Criar uma c√≥pia da pessoa APENAS com as compras desta parceria
                        const comprasDaParceria = p.compras.filter(compra => {
                            if (compra._parceria) {
                                const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                                return compraIdBase === idBase;
                            }
                            return false;
                        });
                        
                        // Calcular valor APENAS das compras desta parceria
                        const valorDaParceria = comprasDaParceria.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
                        
                        pessoasParceria.push({
                            ...p,
                            compras: comprasDaParceria,
                            valor: valorDaParceria
                        });
                        indicesPessoas.push(idx);
                    }
                }
            });
            
            if (pessoasParceria.length === 0) return;
            
            const primeiraCompra = pessoasParceria[0].compras[0];
            const nomeCompra = primeiraCompra.nome;
            const ehRecebimento = conta.tipoTransacao === 'recebimento';
            
            // Verificar se todas est√£o pagas
            const todasPagas = pessoasParceria.every(p => p.pago);
            
            document.getElementById('modalMarcarParceriaTitulo').textContent = `üë• ${nomeCompra}`;
            
            let conteudoHTML = '';
            
            // Listar cada pessoa (clic√°vel)
            conteudoHTML += `<div style="margin-bottom: 16px;">`;
            
            pessoasParceria.forEach((pessoa, idx) => {
                const indicePessoa = indicesPessoas[idx];
                let nomePessoa = pessoa.nome;
                if (pessoa.nome === 'Eu' && ehRecebimento) {
                    nomePessoa = 'Devedor';
                }
                
                conteudoHTML += `
                    <div class="parceria-modal-item ${pessoa.pago ? 'pago' : ''}" 
                         onclick="togglePagoPessoaParceria(${contaId}, ${indicePessoa}, '${idBase.replace(/'/g, "\\'")}')"
                         style="cursor: pointer;">
                        <div class="parceria-modal-nome">
                            <span>${nomePessoa}</span>
                            <span class="parceria-modal-status ${pessoa.pago ? 'pago' : 'pendente'}">
                                ${pessoa.pago ? '‚úÖ PAGO' : '‚è≥ PENDENTE'}
                            </span>
                        </div>
                        <div class="parceria-modal-valor">üí∞ Valor: R$ ${pessoa.valor.toFixed(2)}</div>
                    </div>
                `;
            });
            
            conteudoHTML += `</div>`;
            
            // Bot√µes de a√ß√£o
            conteudoHTML += `
                <div style="border-top: 2px solid #e0e0e0; padding-top: 16px; margin-top: 16px;">
                    <button class="menu-btn ${todasPagas ? 'menu-btn-cancelar' : 'menu-btn-adicionar'}" 
                            onclick="toggleTodasPessoasParceria(${contaId}, '${idBase.replace(/'/g, "\\'")}', ${!todasPagas})" 
                            style="width: 100%; margin-bottom: 10px;">
                        ${todasPagas ? '‚Ü©Ô∏è Desmarcar Todas' : '‚úÖ Marcar como Pago'}
                    </button>
                    <button class="menu-btn menu-btn-cancelar" onclick="fecharModalMarcarParceria()" style="width: 100%;">
                        ‚úï Fechar
                    </button>
                </div>
            `;
            
            document.getElementById('modalMarcarParceriaConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalMarcarParceria').classList.add('ativo');
        }
        
        function fecharModalMarcarParceria() {
            document.getElementById('modalMarcarParceria').classList.remove('ativo');
        }
        
        function togglePagoPessoaParceria(contaId, pessoaIndex, idBase) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            
            // *** NOVO: Verificar se esta pessoa espec√≠fica pertence √† parceria ***
            let pertenceAParceria = false;
            if (pessoa.compras && pessoa.compras.length > 0) {
                pessoa.compras.forEach(compra => {
                    if (compra._parceria) {
                        const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                        if (compraIdBase === idBase) {
                            pertenceAParceria = true;
                        }
                    }
                });
            }
            
            if (!pertenceAParceria) {
                alert('‚ùå Erro: Esta pessoa n√£o pertence a esta parceria!');
                return;
            }
            
            if (pessoa.pago) {
                // Desmarcar
                const confirmar = confirm(`‚ö†Ô∏è Reverter Pagamento\n\nDesmarcar "${pessoa.nome}" como pago?\n\nValor: R$ ${pessoa.valor.toFixed(2)}`);
                if (!confirmar) return;
            }
            
            // *** CORRE√á√ÉO: Alternar status APENAS para esta pessoa espec√≠fica ***
            pessoa.pago = !pessoa.pago;
            
            // *** NOVO: Salvar no m√™s atual com identifica√ß√£o da parceria ***
            const chaveAtual = getChaveMes();
            if (todasContas[chaveAtual]) {
                const contaMesAtual = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaMesAtual && contaMesAtual.pessoas[pessoaIndex]) {
                    contaMesAtual.pessoas[pessoaIndex].pago = pessoa.pago;
                }
            }
            
            // Verificar se TODAS as pessoas da conta est√£o pagas
            const todasPessoasConta = conta.pessoas.every(p => p.pago);
            conta.pago = todasPessoasConta;
            
            // CR√çTICO: Atualizar tamb√©m no todasContas do m√™s atual
            if (todasContas[chaveAtual]) {
                const contaGlobal = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaGlobal) {
                    contaGlobal.pago = conta.pago;
                }
            }
            
            // Salvar e atualizar
            salvarNoStorage();
            carregarContasMesAtual();
            renderizarContas();
            
            // Reabrir o modal atualizado
            abrirModalMarcarParceria(idBase, contaId);
        }
        
        function toggleTodasPessoasParceria(contaId, idBase, marcarComoPago) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            // *** CORRE√á√ÉO: Encontrar APENAS pessoas desta parceria espec√≠fica ***
            const indicesParceria = [];
            conta.pessoas.forEach((p, idx) => {
                if (p.compras && p.compras.length > 0) {
                    // Verificar se tem alguma compra desta parceria
                    const temCompraDaParceria = p.compras.some(compra => {
                        if (compra._parceria) {
                            const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                            return compraIdBase === idBase;
                        }
                        return false;
                    });
                    
                    if (temCompraDaParceria) {
                        indicesParceria.push(idx);
                    }
                }
            });
            
            if (indicesParceria.length === 0) return;
            
            // *** CORRE√á√ÉO: Marcar/desmarcar APENAS as pessoas desta parceria ***
            indicesParceria.forEach(idx => {
                conta.pessoas[idx].pago = marcarComoPago;
            });
            
            // *** NOVO: Atualizar no todasContas do m√™s atual ***
            const chaveAtual = getChaveMes();
            if (todasContas[chaveAtual]) {
                const contaMesAtual = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaMesAtual) {
                    indicesParceria.forEach(idx => {
                        if (contaMesAtual.pessoas[idx]) {
                            contaMesAtual.pessoas[idx].pago = marcarComoPago;
                        }
                    });
                }
            }
            
            // Verificar se TODAS as pessoas da conta est√£o pagas
            const todasPessoasConta = conta.pessoas.every(p => p.pago);
            conta.pago = todasPessoasConta;
            
            // CR√çTICO: Atualizar tamb√©m no todasContas do m√™s atual
            if (todasContas[chaveAtual]) {
                const contaGlobal = todasContas[chaveAtual].find(c => c.nome === conta.nome);
                if (contaGlobal) {
                    contaGlobal.pago = conta.pago;
                }
            }
            
            // Salvar e atualizar
            salvarNoStorage();
            carregarContasMesAtual();
            renderizarContas();
            
            // Reabrir o modal atualizado
            abrirModalMarcarParceria(idBase, contaId);
        }
        
        function mostrarDetalhesPessoa(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            if (!pessoa || !pessoa.compras) return;
            
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && conta.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const ehRecebimento = conta.tipoTransacao === 'recebimento';
            const tipoLabel = ehRecebimento ? 'RECEBIMENTOS' : 'COMPRAS';
            const icone = ehRecebimento ? 'üí∞' : 'üõí';
            const labelParcela = ehRecebimento ? 'Valor a receber este m√™s' : 'Valor deste m√™s';
            const labelJaPago = ehRecebimento ? 'Valores j√° recebidos' : 'Valores j√° pagos';
            
            // *** FILTRAR APENAS COMPRAS N√ÉO PERTENCENTES A PARCERIAS ***
            const comprasIndividuais = pessoa.compras.filter(c => !c._parceria);
            
            // *** VERIFICAR SE √â RECORRENTE ***
            const ehRecorrente = comprasIndividuais.length > 0 && comprasIndividuais[0].parcelas === 'recorrente';
            
            // *** CALCULAR VALORES J√Å PAGOS/RECEBIDOS AT√â O M√äS ATUAL (APENAS COMPRAS INDIVIDUAIS) ***
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            let totalJaPago = 0;
            
            // Percorrer todos os meses AT√â o atual (incluindo o atual se estiver pago)
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                // Meses anteriores OU m√™s atual se a pessoa estiver paga
                const ehMesAtual = chaveMes === chaveAtual;
                const deveContar = dataMes < dataAtualMes || (ehMesAtual && pessoa.pago);
                
                if (deveContar) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas.forEach(p => {
                            if (p.nome === pessoa.nome && p.pago) {
                                // Verificar se tem compras detalhadas
                                if (p.compras && p.compras.length > 0) {
                                    p.compras.forEach(compra => {
                                        // *** APENAS SE N√ÉO FOR PARCERIA ***
                                        if (!compra._parceria) {
                                            // Verificar se √© a mesma compra (pelo ID √∫nico)
                                            const mesmaCompra = comprasIndividuais.some(pc => 
                                                pc.idUnico === compra.idUnico || 
                                                (pc.nome === compra.nome && pc.dataCompra === compra.dataCompra)
                                            );
                                            
                                            if (mesmaCompra) {
                                                // *** CORRE√á√ÉO: Para recorrentes, n√£o somar - apenas o valor do m√™s atual ***
                                                if (!ehRecorrente) {
                                                    // Usar valor alterado se existir, sen√£o usar valor normal
                                                    const valorPago = p._valorPagoReal !== undefined ? p._valorPagoReal : compra.valorParcela;
                                                    totalJaPago += valorPago;
                                                }
                                            }
                                        }
                                    });
                                } else {
                                    // Sem compras detalhadas, usar valor da pessoa
                                    if (!ehRecorrente) {
                                        const valorPago = p._valorPagoReal !== undefined ? p._valorPagoReal : p.valor;
                                        totalJaPago += valorPago;
                                    }
                                }
                            }
                        });
                    }
                }
            });
            
            // T√≠tulo e subt√≠tulo
            const tipoIcone = conta.tipo === 'cartao' ? 'üí≥' : conta.tipo === 'boleto' ? 'üßæ' : conta.tipo === 'dinheiro' ? 'üíµ' : conta.tipo === 'pix' ? '‚ùñ' : 'ü™ô';
            const tipoNome = conta.tipo === 'cartao' ? 'Cart√£o de Cr√©dito' : conta.tipo === 'boleto' ? 'Boleto/Conta' : conta.tipo === 'dinheiro' ? 'Dinheiro' : conta.tipo === 'pix' ? 'PIX' : 'Outro';
            document.getElementById('modalDetalhesTitulo').innerHTML = `<div style="display: grid; grid-template-columns: 1fr auto; margin-top: -10px; align-items: start; padding-right: 0px; width: 100%;"><div><div style="font-size: 22px; font-weight: bold; color: #667eea; margin-bottom: 8px;">${conta.nome}</div></div><div style="font-size: 13px; color: #666; font-weight: 600; background: #f0f0f0; padding: 6px 6px; border-radius: 8px; white-space: nowrap;">${tipoIcone} ${tipoNome}</div></div>`;
            document.getElementById('modalDetalhesSubtitulo').innerHTML = `<strong>üìä ${nomePessoa}</strong>`;
            
            // Conte√∫do
            let conteudoHTML = '';
            
            // *** CALCULAR TOTAL GERAL E VALORES RESTANTES (APENAS COMPRAS INDIVIDUAIS) ***
            let totalGeralCompras = 0;
            
            if (ehRecorrente) {
                // Para recorrentes, o total √© apenas o valor da parcela atual
                totalGeralCompras = comprasIndividuais[0]?.valorParcela || 0;
                // Se est√° pago no m√™s atual, totalJaPago deve ser igual ao valor da parcela
                if (pessoa.pago) {
                    totalJaPago = totalGeralCompras;
                } else {
                    totalJaPago = 0;
                }
            } else {
                // Para n√£o-recorrentes, somar todos os valores totais
                comprasIndividuais.forEach(compra => {
                    totalGeralCompras += compra.valorTotal || 0;
                });
            }
            
            const valoresRestantes = totalGeralCompras - totalJaPago;
            
            // *** CALCULAR VALOR DO M√äS ATUAL (APENAS COMPRAS INDIVIDUAIS) ***
            const valorMesAtual = comprasIndividuais.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
            
            // *** RESUMO COM DUAS COLUNAS ***
            conteudoHTML += `
                <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 16px;">
                    <div>
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">${labelParcela}</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 22px;">R$ ${valorMesAtual.toFixed(2)}</div>
                    </div>
                    <div style="border-left: 2px solid rgba(255,255,255,0.3); padding-left: 16px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">üí∞ Valor Restante</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 22px;">R$ ${valoresRestantes.toFixed(2)}</div>
                    </div>
                </div>
            `;
            
            // Se√ß√£o de compras
            conteudoHTML += `
                <div class="modal-detalhes-secao">
                    <div class="modal-detalhes-secao-titulo">${icone} ${tipoLabel}</div>
            `;
            
            let totalGeral = 0;
            
            comprasIndividuais.forEach((compra, idx) => {
                const nomeCompra = compra.nome || 'Sem nome';
                const dataCompra = compra.dataCompra || 'Data n√£o registrada';
                const valorTotal = compra.valorTotal || 0;
                const valorParcela = compra.valorParcela || 0;
                const parcelas = compra.parcelas || '';
                const observacoes = compra.observacoes || '';
                
                totalGeral += valorTotal;
                
                conteudoHTML += `
                    <div class="detalhes-compra-card ${ehRecebimento ? 'recebimento' : ''}">
                        <div class="detalhes-compra-nome">
                            <span>${idx + 1}. ${nomeCompra}</span>
                            ${parcelas ? `<span class="detalhes-compra-badge ${ehRecebimento ? 'recebimento' : ''}">${parcelas}</span>` : ''}
                        </div>
                        <div class="detalhes-compra-info">
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üìÖ Data</div>
                                <div>${dataCompra}</div>
                            </div>
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üí∞ Valor Total</div>
                                <div class="detalhes-compra-info-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${valorTotal.toFixed(2)}</div>
                            </div>
                            <div class="detalhes-compra-info-item" style="grid-column: 1 / -1;">
                                <div class="detalhes-compra-info-label">${labelParcela}</div>
                                <div class="detalhes-compra-info-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${valorParcela.toFixed(2)}</div>
                            </div>
                            ${observacoes ? `
                            <div class="detalhes-compra-info-item" style="grid-column: 1 / -1;">
                                <div class="detalhes-compra-info-label">üìù Observa√ß√µes</div>
                                <div style="color: #666; font-size: 12px; white-space: pre-wrap; word-break: break-word;">${observacoes}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            conteudoHTML += `</div>`;
            
            // Total geral (agora clic√°vel)
            conteudoHTML += `
                <div class="modal-detalhes-total ${ehRecebimento ? 'recebimento' : ''}" style="cursor: pointer;" onclick="mostrarResumoDetalhadoPessoa(${contaId}, ${pessoaIndex})" title="Clique para ver resumo completo">
                    <div class="modal-detalhes-total-label">TOTAL ${ehRecebimento ? 'A RECEBER' : 'DAS COMPRAS'} üìä</div>
                    <div class="modal-detalhes-total-valor">R$ ${totalGeral.toFixed(2)}</div>
                </div>
            `;
            
            document.getElementById('modalDetalhesConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalDetalhes').classList.add('ativo');
        }

        function mostrarDetalhesTotal() {
            // Calcular apenas os gastos da pessoa "Eu"
            const totalPagamentos = contas
                .filter(c => c.tipoTransacao !== 'recebimento')
                .reduce((sum, c) => {
                    const minhasCompras = c.pessoas
                        .filter(p => p.nome === 'Eu')
                        .reduce((total, p) => total + p.valor, 0);
                    return sum + minhasCompras;
                }, 0);
            
            // Calcular apenas os recebimentos da pessoa "Eu" que J√Å FORAM PAGOS (recebidos)
            const totalRecebimentos = contas
                .filter(c => c.tipoTransacao === 'recebimento')
                .reduce((sum, c) => {
                    const meusRecebimentos = c.pessoas
                        .filter(p => p.nome === 'Eu' && p.pago)
                        .reduce((total, p) => total + p.valor, 0);
                    return sum + meusRecebimentos;
                }, 0);
            
            const saldo = totalRecebimentos - totalPagamentos;
            const saldoPositivo = saldo >= 0;
            
            // Contar quantidades
            const qtdPagamentos = contas.filter(c => c.tipoTransacao !== 'recebimento').length;
            const qtdRecebimentos = contas.filter(c => c.tipoTransacao === 'recebimento').length;
            
            // *** CORRE√á√ÉO: Contar apenas contas com pessoas cadastradas ***
            const contasPagas = contas.filter(c => c.pago && c.pessoas && c.pessoas.length > 0).length;
            const contasPendentes = contas.filter(c => !c.pago && c.pessoas && c.pessoas.length > 0).length;
            
            // Calcular totais gerais (todas as pessoas) para informa√ß√£o adicional
            const totalGeralPagamentos = contas
                .filter(c => c.tipoTransacao !== 'recebimento')
                .reduce((sum, c) => sum + calcularTotal(c), 0);
            
            const totalGeralRecebimentos = contas
                .filter(c => c.tipoTransacao === 'recebimento')
                .reduce((sum, c) => {
                    const totalRecebidoNestaConta = c.pessoas
                        .filter(p => p.pago)
                        .reduce((total, p) => {
                            const valorConsiderar = p._valorPagoReal !== undefined ? p._valorPagoReal : p.valor;
                            return total + valorConsiderar;
                        }, 0);
                    return sum + totalRecebidoNestaConta;
                }, 0);
            
            let conteudoHTML = '';
            
            // Card de Gastos (apenas "Eu")
            conteudoHTML += `
                <div class="resumo-card">
                    <div class="resumo-card-label">üí∏ Meus Gastos</div>
                    <div class="resumo-card-valor">R$ ${totalPagamentos.toFixed(2)}</div>
                    ${qtdPagamentos > 0 ? `<div style="font-size: 12px; opacity: 0.9; margin-top: 8px;">${qtdPagamentos} ${qtdPagamentos === 1 ? 'conta' : 'contas'} de pagamento</div>` : ''}
                    ${totalGeralPagamentos !== totalPagamentos ? `<div style="font-size: 11px; opacity: 0.95; margin-top: 4px; color: #ffffff; background: rgba(0,0,0,0.2); padding: 4px 8px; border-radius: 4px;">‚úÖ Total geral (com outras pessoas): R$ ${totalGeralPagamentos.toFixed(2)}</div>` : ''}
                </div>
            `;
            
            // Card de Recebimentos (apenas "Eu")
            conteudoHTML += `
                <div class="resumo-card recebimentos">
                    <div class="resumo-card-label">üí∞ Meus Recebimentos</div>
                    <div class="resumo-card-valor">R$ ${totalRecebimentos.toFixed(2)}</div>
                    ${qtdRecebimentos > 0 ? `<div style="font-size: 12px; opacity: 0.9; margin-top: 8px;">${qtdRecebimentos} ${qtdRecebimentos === 1 ? 'conta' : 'contas'} de recebimento</div>` : ''}
                    ${totalGeralRecebimentos !== totalRecebimentos ? `<div style="font-size: 11px; opacity: 0.95; margin-top: 4px; color: #ffffff; background: rgba(0,0,0,0.2); padding: 4px 8px; border-radius: 4px;">Total geral (com outras pessoas): R$ ${totalGeralRecebimentos.toFixed(2)}</div>` : ''}
                </div>
            `;
            
            // Divisor
            conteudoHTML += `<hr class="resumo-divisor">`;
            
            // Saldo Final (baseado apenas em "Eu")
            conteudoHTML += `
                <div class="resumo-saldo">
                    <div class="resumo-saldo-header">
                        <div class="resumo-icone-grande">${saldoPositivo ? 'üíö' : 'üî¥'}</div>
                        <div class="resumo-saldo-label">Meu Saldo do M√™s</div>
                        <div class="resumo-saldo-valor ${saldoPositivo ? 'positivo' : 'negativo'}">
                            R$ ${Math.abs(saldo).toFixed(2)}
                        </div>
                        <div class="resumo-saldo-badge ${saldoPositivo ? 'positivo' : 'negativo'}">
                            ${saldoPositivo ? '‚úÖ Saldo Positivo' : '‚ö†Ô∏è Saldo Negativo'}
                        </div>
                    </div>
                    
                    <div class="resumo-detalhes">
                        <div class="resumo-detalhes-item">
                            <span class="resumo-detalhes-label">‚úÖ Contas Pagas</span>
                            <span class="resumo-detalhes-valor">${contasPagas}</span>
                        </div>
                        <div class="resumo-detalhes-item">
                            <span class="resumo-detalhes-label">‚è≥ Contas Pendentes</span>
                            <span class="resumo-detalhes-valor">${contasPendentes}</span>
                        </div>
                    </div>
                </div>
            `;
            
            // Informa√ß√£o adicional
            if (saldoPositivo && saldo > 0) {
                conteudoHTML += `
                    <div class="resumo-info-box">
                        üí° Voc√™ tem R$ ${saldo.toFixed(2)} dispon√≠vel ap√≥s pagar todas as suas contas deste m√™s!
                    </div>
                `;
            } else if (!saldoPositivo) {
                conteudoHTML += `
                    <div class="resumo-info-box" style="background: #ffebee; border-left-color: #f44336; color: #c62828;">
                        ‚ö†Ô∏è Aten√ß√£o: Seus gastos excedem seus recebimentos em R$ ${Math.abs(saldo).toFixed(2)} neste m√™s.
                    </div>
                `;
            }
            
            // Informa√ß√£o sobre outras pessoas (se houver)
            const temOutrasPessoas = contas.some(c => c.pessoas.some(p => p.nome !== 'Eu'));
            if (temOutrasPessoas) {
                const totalOutrasPessoasPagamentos = totalGeralPagamentos - totalPagamentos;
                const totalOutrasPessoasRecebimentos = totalGeralRecebimentos - totalRecebimentos;
                
                if (totalOutrasPessoasPagamentos > 0) {
                    conteudoHTML += `
                        <div class="resumo-info-box" style="background: #e3f2fd; border-left-color: #2196F3; color: #1565C0;">
                            üë• Outras pessoas t√™m R$ ${totalOutrasPessoasPagamentos.toFixed(2)} em compras/despesas cadastradas neste m√™s.
                        </div>
                    `;
                }
                
                if (totalOutrasPessoasRecebimentos > 0) {
                    conteudoHTML += `
                        <div class="resumo-info-box" style="background: #e8f5e9; border-left-color: #4caf50; color: #2e7d32;">
                            üí∞ Outras pessoas t√™m R$ ${totalOutrasPessoasRecebimentos.toFixed(2)} j√° recebidos neste m√™s.
                        </div>
                    `;
                }
            }
            
            document.getElementById('modalResumoConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalResumo').classList.add('ativo');
        }

function verificarContaFinalizada(conta) {
            // Verifica se √© recebimento, pagamento custom OU pagamento normal
            if (conta.tipoTransacao !== 'recebimento' && 
                conta.tipoTransacao !== 'pagamento-custom' && 
                conta.tipoTransacao !== 'pagamento') {
                return { finalizada: false, temPendencias: false };
            }
            
            // Verificar se tem contas recorrentes
            const temRecorrente = conta.pessoas.some(p => 
                p.parcelas === 'recorrente' || 
                (p.compras && p.compras.some(c => c.parcelas === 'recorrente'))
            );
            
            if (temRecorrente) {
                return { finalizada: false, temPendencias: false };
            }
            
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            // *** NOVO: Verificar se existem parcelas FUTURAS ***
            let existemParcelasFuturas = false;
            let temPendencias = false;
            
            // Verificar se h√° parcelas em meses futuros ao atual
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                // Se for m√™s futuro
                if (dataMes > dataAtualMes) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                    
                    if (contaEncontrada && contaEncontrada.pessoas && contaEncontrada.pessoas.length > 0) {
                        existemParcelasFuturas = true;
                    }
                }
            });
            
            // Se existem parcelas futuras, conta N√ÉO finalizou
            if (existemParcelasFuturas) {
                return { finalizada: false, temPendencias: false };
            }
            
            // *** Verificar pend√™ncias em meses ANTERIORES ao atual ***
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                // Apenas meses anteriores
                if (dataMes < dataAtualMes) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas.forEach(p => {
                            // Se n√£o est√° pago = pend√™ncia
                            if (!p.pago) {
                                temPendencias = true;
                            }
                        });
                    }
                }
            });
            
            // Conta finalizou = n√£o tem parcelas futuras E n√£o tem parcelas no m√™s atual
            const todasParcelasFinalizadas = !existemParcelasFuturas && 
                                            (!conta.pessoas || conta.pessoas.length === 0);
            
            return { 
                finalizada: todasParcelasFinalizadas, 
                temPendencias: temPendencias 
            };
        }

        function verificarPendenciasConta(nomeConta) {
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtual] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtual - 1);
            
            let pendencias = [];
            
            // Determinar se √© recebimento ou pagamento
            const contaAtualRef = contas.find(c => c.nome === nomeConta);
            const ehRecebimento = contaAtualRef && contaAtualRef.tipoTransacao === 'recebimento';
            
            if (ehRecebimento) {
                // ==========================================
                // L√ìGICA PARA RECEBIMENTOS
                // ==========================================
                
                const recebimentosInfo = new Map();
                
                // PRIMEIRA PASSADA: Coletar informa√ß√µes sobre todos os recebimentos
                Object.keys(todasContas).sort().forEach(chaveMes => {
                    const [ano, mes] = chaveMes.split('-').map(Number);
                    const dataMes = new Date(ano, mes - 1);
                    
                    if (dataMes <= dataAtualMes) {
                        const contasMes = todasContas[chaveMes];
                        const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                        
                        if (contaEncontrada) {
                            contaEncontrada.pessoas.forEach(pessoa => {
                                if (pessoa.compras && pessoa.compras.length > 0) {
                                    pessoa.compras.forEach(compra => {
                                        const idCompra = compra.idUnico || (compra.nome + '_' + compra.dataCompra);
                                        
                                        if (!recebimentosInfo.has(idCompra)) {
                                            let totalParcelas = 1;
                                            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                            if (match) {
                                                totalParcelas = parseInt(match[2]);
                                            }
                                            
                                            recebimentosInfo.set(idCompra, {
                                                totalParcelas: totalParcelas,
                                                parcelasPagas: 0,
                                                maiorParcelaVista: 0,
                                                mesesDetalhados: [],
                                                recorrente: compra.parcelas === 'recorrente',
                                                ehParcelaUnica: !compra.parcelas || compra.parcelas === '',
                                                valorParcela: compra.valorParcela,
                                                valorTotal: compra.valorTotal,
                                                nome: compra.nome,
                                                nomePessoa: pessoa.nome === 'Eu' ? 'Devedor' : pessoa.nome,
                                                mesOrigem: chaveMes
                                            });
                                        }
                                        
                                        const info = recebimentosInfo.get(idCompra);
                                        
                                        // Rastrear qual √© a maior parcela vista at√© agora
                                        const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                                        if (match) {
                                            const parcelaNum = parseInt(match[1]);
                                            if (parcelaNum > info.maiorParcelaVista) {
                                                info.maiorParcelaVista = parcelaNum;
                                            }
                                        }
                                        
                                        // Registrar detalhes deste m√™s
                                        info.mesesDetalhados.push({
                                            mes: chaveMes,
                                            pago: pessoa.pago,
                                            parcela: compra.parcelas
                                        });
                                        
                                        // Contar se foi pago
                                        if (pessoa.pago) {
                                            info.parcelasPagas++;
                                        }
                                    });
                                } else {
                                    // Pessoa sem compras detalhadas
                                    const idGenerico = pessoa.nome + '_' + pessoa.valor + '_' + (pessoa.parcelas || 'unico');
                                    
                                    if (!recebimentosInfo.has(idGenerico)) {
                                        let totalParcelas = 1;
                                        const match = pessoa.parcelas ? pessoa.parcelas.match(/(\d+)\/(\d+)/) : null;
                                        if (match) {
                                            totalParcelas = parseInt(match[2]);
                                        }
                                        
                                        recebimentosInfo.set(idGenerico, {
                                            totalParcelas: totalParcelas,
                                            parcelasPagas: 0,
                                            maiorParcelaVista: 0,
                                            mesesDetalhados: [],
                                            recorrente: pessoa.parcelas === 'recorrente',
                                            ehParcelaUnica: !pessoa.parcelas || pessoa.parcelas === '',
                                            valorParcela: pessoa.valor,
                                            valorTotal: pessoa.valorTotal || pessoa.valor,
                                            nome: 'Valor direto',
                                            nomePessoa: pessoa.nome === 'Eu' ? 'Devedor' : pessoa.nome,
                                            mesOrigem: chaveMes
                                        });
                                    }
                                    
                                    const info = recebimentosInfo.get(idGenerico);
                                    
                                    const match = pessoa.parcelas ? pessoa.parcelas.match(/(\d+)\/(\d+)/) : null;
                                    if (match) {
                                        const parcelaNum = parseInt(match[1]);
                                        if (parcelaNum > info.maiorParcelaVista) {
                                            info.maiorParcelaVista = parcelaNum;
                                        }
                                    }
                                    
                                    info.mesesDetalhados.push({
                                        mes: chaveMes,
                                        pago: pessoa.pago,
                                        parcela: pessoa.parcelas
                                    });
                                    
                                    if (pessoa.pago) {
                                        info.parcelasPagas++;
                                    }
                                }
                            });
                        }
                    }
                });
                
                // SEGUNDA PASSADA: Criar pend√™ncias baseado nas informa√ß√µes coletadas
                recebimentosInfo.forEach((info, idCompra) => {
                    let quantidadePendencias = 0;
                    
                    if (info.recorrente) {
                        // Recorrente: cada m√™s n√£o pago √© uma pend√™ncia
                        quantidadePendencias = info.mesesDetalhados.filter(m => !m.pago).length;
                    } else if (info.ehParcelaUnica) {
                        // *** CORRE√á√ÉO PRINCIPAL: Parcela √∫nica ***
                        // Se N√ÉO foi pago em nenhum m√™s anterior (exceto atual), √© pend√™ncia
                        const foiPagoEmMesAnterior = info.mesesDetalhados.some(m => m.mes !== chaveAtual && m.pago);
                        if (!foiPagoEmMesAnterior && info.mesOrigem !== chaveAtual) {
                            quantidadePendencias = 1;
                        }
                    } else {
                        // Parcelado: maior parcela vista - parcelas pagas
                        const parcelasQueJaPassaram = Math.min(info.maiorParcelaVista, info.totalParcelas);
                        quantidadePendencias = parcelasQueJaPassaram - info.parcelasPagas;
                    }
                    
                    if (quantidadePendencias > 0) {
                        // Adicionar pend√™ncias para os meses n√£o pagos (exceto o atual)
                        let pendenciasAdicionadas = 0;
                        
                        info.mesesDetalhados
                            .filter(m => m.mes !== chaveAtual && !m.pago)
                            .forEach(mesInfo => {
                                if (pendenciasAdicionadas < quantidadePendencias) {
                                    pendencias.push({
                                        mes: mesInfo.mes,
                                        nomePessoa: info.nomePessoa,
                                        nomeCompra: info.nome,
                                        valor: info.valorParcela,
                                        valorTotal: info.valorTotal,
                                        parcelas: mesInfo.parcela,
                                        tipoTransacao: 'recebimento',
                                        idCompra: idCompra
                                    });
                                    pendenciasAdicionadas++;
                                }
                            });
                    }
                });
                
            } else {
                // ==========================================
                // L√ìGICA PARA PAGAMENTOS (ORIGINAL)
                // ==========================================
                
                Object.keys(todasContas).sort().forEach(chaveMes => {
                    const [ano, mes] = chaveMes.split('-').map(Number);
                    const dataMes = new Date(ano, mes - 1);
                    
                    if (dataMes <= dataAtualMes) {
                        const contasMes = todasContas[chaveMes];
                        const contaEncontrada = contasMes.find(c => c.nome === nomeConta);
                        
                        if (contaEncontrada) {
                            contaEncontrada.pessoas.forEach(pessoa => {
                                if (pessoa.compras && pessoa.compras.length > 0) {
                                    pessoa.compras.forEach(compra => {
                                        const idCompra = compra.idUnico || (compra.nome + '_' + compra.dataCompra);
                                        
                                        // Se for parceria, verificar cada pessoa individualmente
                                        if (compra._parceria) {
                                            if (!pessoa.pago) {
                                                if (chaveMes !== chaveAtual) {
                                                    const jaAdicionado = pendencias.some(p => 
                                                        p.idCompra === idCompra && p.mes === chaveMes && p.nomePessoa === pessoa.nome
                                                    );
                                                    
                                                    if (!jaAdicionado) {
                                                        pendencias.push({
                                                            mes: chaveMes,
                                                            nomePessoa: pessoa.nome,
                                                            nomeCompra: compra.nome + ' (Parceria)',
                                                            valor: compra.valorParcela,
                                                            valorTotal: compra.valorTotal,
                                                            parcelas: compra.parcelas || pessoa.parcelas,
                                                            tipoTransacao: contaEncontrada.tipoTransacao,
                                                            idCompra: idCompra
                                                        });
                                                    }
                                                }
                                            }
                                        } else {
                                            // Compra n√£o-parceria (l√≥gica original)
                                            if (!pessoa.pago) {
                                                if (compra.parcelas === 'recorrente' || pessoa.parcelas === 'recorrente') {
                                                    if (chaveMes !== chaveAtual) {
                                                        const jaAdicionado = pendencias.some(p => 
                                                            p.idCompra === idCompra && p.mes === chaveMes
                                                        );
                                                        
                                                        if (!jaAdicionado) {
                                                            pendencias.push({
                                                                mes: chaveMes,
                                                                nomePessoa: pessoa.nome,
                                                                nomeCompra: compra.nome,
                                                                valor: compra.valorParcela,
                                                                valorTotal: compra.valorTotal,
                                                                parcelas: compra.parcelas || pessoa.parcelas,
                                                                tipoTransacao: contaEncontrada.tipoTransacao,
                                                                idCompra: idCompra
                                                            });
                                                        }
                                                    }
                                                } else {
                                                    if (chaveMes !== chaveAtual) {
                                                        const jaAdicionado = pendencias.some(p => 
                                                            p.idCompra === idCompra && p.mes === chaveMes
                                                        );
                                                        
                                                        if (!jaAdicionado) {
                                                            pendencias.push({
                                                                mes: chaveMes,
                                                                nomePessoa: pessoa.nome,
                                                                nomeCompra: compra.nome,
                                                                valor: compra.valorParcela,
                                                                valorTotal: compra.valorTotal,
                                                                parcelas: compra.parcelas || pessoa.parcelas,
                                                                tipoTransacao: contaEncontrada.tipoTransacao,
                                                                idCompra: idCompra
                                                            });
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    });
                                } else {
                                    const idGenerico = pessoa.nome + '_' + pessoa.valor + '_' + (pessoa.parcelas || 'unico');
                                    
                                    if (!pessoa.pago) {
                                        if (pessoa.parcelas === 'recorrente') {
                                            if (chaveMes !== chaveAtual) {
                                                const jaAdicionado = pendencias.some(p => 
                                                    p.idCompra === idGenerico && p.mes === chaveMes
                                                );
                                                
                                                if (!jaAdicionado) {
                                                    pendencias.push({
                                                        mes: chaveMes,
                                                        nomePessoa: pessoa.nome,
                                                        nomeCompra: 'Valor direto',
                                                        valor: pessoa.valor,
                                                        valorTotal: pessoa.valorTotal || pessoa.valor,
                                                        parcelas: pessoa.parcelas,
                                                        tipoTransacao: contaEncontrada.tipoTransacao,
                                                        idCompra: idGenerico
                                                    });
                                                }
                                            }
                                        } else {
                                            if (chaveMes !== chaveAtual) {
                                                const jaAdicionado = pendencias.some(p => 
                                                    p.idCompra === idGenerico && p.mes === chaveMes
                                                );
                                                
                                                if (!jaAdicionado) {
                                                    pendencias.push({
                                                        mes: chaveMes,
                                                        nomePessoa: pessoa.nome,
                                                        nomeCompra: 'Valor direto',
                                                        valor: pessoa.valor,
                                                        valorTotal: pessoa.valorTotal || pessoa.valor,
                                                        parcelas: pessoa.parcelas,
                                                        tipoTransacao: contaEncontrada.tipoTransacao,
                                                        idCompra: idGenerico
                                                    });
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                });
            }
            
            return pendencias;
        }
        
        function mostrarPendenciasConta(nomeConta) {
            const pendencias = verificarPendenciasConta(nomeConta);
            
            document.getElementById('modalPendenciasTitulo').innerHTML = `‚ö†Ô∏è PEND√äNCIAS - ${nomeConta}`;
            
            if (pendencias.length === 0) {
                document.getElementById('modalPendenciasSubtitulo').textContent = '';
                document.getElementById('modalPendenciasConteudo').innerHTML = `
                    <div class="pendencia-sem-resultado">
                        <div class="pendencia-sem-resultado-icone">‚úÖ</div>
                        <div class="pendencia-sem-resultado-texto">Nenhuma pend√™ncia encontrada</div>
                        <div class="pendencia-sem-resultado-sub">Todos os pagamentos est√£o em dia! üéâ</div>
                    </div>
                `;
                document.getElementById('modalPendencias').classList.add('ativo');
                return;
            }
            
            document.getElementById('modalPendenciasSubtitulo').textContent = 
                `Total de ${pendencias.length} ${pendencias.length === 1 ? 'pagamento atrasado' : 'pagamentos atrasados'}`;
            
            // Agrupar por m√™s
            const porMes = {};
            pendencias.forEach(p => {
                if (!porMes[p.mes]) porMes[p.mes] = [];
                porMes[p.mes].push(p);
            });
            
            let conteudoHTML = '';
            
            Object.keys(porMes).sort().forEach(mes => {
                const [ano, mesNum] = mes.split('-');
                const meses = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho', 
                              'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
                const mesesCurtos = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                
                conteudoHTML += `<div class="pendencia-mes">`;
                conteudoHTML += `<div class="pendencia-mes-titulo">üìÖ ${mesesCurtos[parseInt(mesNum) - 1]}/${ano}</div>`;
                
                // Agrupar por pessoa dentro do m√™s
                const porPessoa = {};
                porMes[mes].forEach(p => {
                    if (!porPessoa[p.nomePessoa]) porPessoa[p.nomePessoa] = [];
                    porPessoa[p.nomePessoa].push(p);
                });
                
                Object.keys(porPessoa).forEach(nomePessoa => {
                    const comprasDaPessoa = porPessoa[nomePessoa];
                    const icone = comprasDaPessoa[0].tipoTransacao === 'recebimento' ? 'üí∞' : 'üí∏';
                    
                    conteudoHTML += `<div class="pendencia-pessoa">`;
                    conteudoHTML += `<div class="pendencia-pessoa-nome">${icone} ${nomePessoa}</div>`;
                    
                    comprasDaPessoa.forEach(compra => {
                        conteudoHTML += `<div class="pendencia-compra">`;
                        conteudoHTML += `<div class="pendencia-compra-nome">‚Ä¢ ${compra.nomeCompra}</div>`;
                        conteudoHTML += `<div class="pendencia-compra-valor">R$ ${compra.valor.toFixed(2)}`;
                        
                        if (compra.parcelas && compra.parcelas !== 'recorrente') {
                            conteudoHTML += ` <span style="font-size: 12px; font-weight: normal;">(${compra.parcelas})</span>`;
                        } else if (compra.parcelas === 'recorrente') {
                            conteudoHTML += ` <span style="font-size: 12px; font-weight: normal;">(Recorrente)</span>`;
                        }
                        
                        conteudoHTML += `</div>`;
                        
                        if (compra.valorTotal && compra.valorTotal !== compra.valor) {
                            conteudoHTML += `<div class="pendencia-compra-info">Valor total: R$ ${compra.valorTotal.toFixed(2)}</div>`;
                        }
                        
                        conteudoHTML += `</div>`;
                    });
                    
                    conteudoHTML += `</div>`;
                });
                
                conteudoHTML += `</div>`;
            });
            
            const totalPendente = pendencias.reduce((sum, p) => sum + p.valor, 0);
            
            conteudoHTML += `
                <div class="pendencia-total">
                    <div class="pendencia-total-titulo">TOTAL PENDENTE</div>
                    <div class="pendencia-total-valor">R$ ${totalPendente.toFixed(2)}</div>
                </div>
            `;
            
            document.getElementById('modalPendenciasConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalPendencias').classList.add('ativo');
        }

function mostrarResumoDetalhadoPessoa(contaId, pessoaIndex) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const pessoa = conta.pessoas[pessoaIndex];
            if (!pessoa || !pessoa.compras) return;
            
            let nomePessoa = pessoa.nome;
            if (pessoa.nome === 'Eu' && conta.tipoTransacao === 'recebimento') {
                nomePessoa = 'Devedor';
            }
            
            const ehRecebimento = conta.tipoTransacao === 'recebimento';
            const icone = ehRecebimento ? 'üí∞' : 'üõí';
            
            // *** FILTRAR APENAS COMPRAS N√ÉO PERTENCENTES A PARCERIAS ***
            const comprasIndividuais = pessoa.compras.filter(c => !c._parceria);
            
            // Calcular todos os valores
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            let totalJaPago = 0;
            let totalGeral = 0;
            let totalParcelas = 0;
            let parcelasPagas = 0;
            
            // *** CALCULAR TOTAL GERAL E TOTAL J√Å PAGO (APENAS COMPRAS INDIVIDUAIS) ***
            comprasIndividuais.forEach(compra => {
                totalGeral += compra.valorTotal || 0;
                
                const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                if (match) {
                    totalParcelas = Math.max(totalParcelas, parseInt(match[2]));
                }
            });
            
            // Calcular valores j√° pagos
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                const ehMesAtual = chaveMes === chaveAtual;
                const deveContar = dataMes < dataAtualMes || (ehMesAtual && pessoa.pago);
                
                if (deveContar) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                    
                    if (contaEncontrada) {
                        contaEncontrada.pessoas.forEach(p => {
                            if (p.nome === pessoa.nome && p.pago) {
                                if (p.compras && p.compras.length > 0) {
                                    p.compras.forEach(compra => {
                                        // *** APENAS SE N√ÉO FOR PARCERIA ***
                                        if (!compra._parceria) {
                                            const mesmaCompra = comprasIndividuais.some(pc => 
                                                pc.idUnico === compra.idUnico || 
                                                (pc.nome === compra.nome && pc.dataCompra === compra.dataCompra)
                                            );
                                            
                                            if (mesmaCompra) {
                                                const valorPago = p._valorPagoReal !== undefined ? p._valorPagoReal : compra.valorParcela;
                                                totalJaPago += valorPago;
                                                parcelasPagas++;
                                            }
                                        }
                                    });
                                } else {
                                    const valorPago = p._valorPagoReal !== undefined ? p._valorPagoReal : p.valor;
                                    totalJaPago += valorPago;
                                    parcelasPagas++;
                                }
                            }
                        });
                    }
                }
            });
            
            const totalRestante = totalGeral - totalJaPago;
            const percentualPago = totalGeral > 0 ? (totalJaPago / totalGeral) * 100 : 0;
            
            // *** CALCULAR VALOR DO M√äS ATUAL (APENAS COMPRAS INDIVIDUAIS) ***
            const valorMesAtual = comprasIndividuais.reduce((sum, c) => sum + (c.valorParcela || 0), 0);
            
            // Montar o modal
            const tipoIcone = conta.tipo === 'cartao' ? 'üí≥' : conta.tipo === 'boleto' ? 'üßæ' : conta.tipo === 'dinheiro' ? 'üíµ' : conta.tipo === 'pix' ? '‚ùñ' : 'ü™ô';
            const tipoNome = conta.tipo === 'cartao' ? 'Cart√£o de Cr√©dito' : conta.tipo === 'boleto' ? 'Boleto/Conta' : conta.tipo === 'dinheiro' ? 'Dinheiro' : conta.tipo === 'pix' ? 'PIX' : 'Outro';
            document.getElementById('modalResumoDetalhadoTitulo').innerHTML = `<div style="display: grid; grid-template-columns: 1fr auto; margin-top: -10px; align-items: start; padding-right: 0px; width: 100%;"><div><div style="font-size: 22px; font-weight: bold; color: #667eea; margin-bottom: 8px;">${conta.nome}</div></div><div style="font-size: 13px; color: #666; font-weight: 600; background: #f0f0f0; padding: 6px 6px; border-radius: 8px; white-space: nowrap;">${tipoIcone} ${tipoNome}</div></div>`;
            document.getElementById('modalResumoDetalhadoSubtitulo').innerHTML = `<strong>${icone} Resumo Completo - ${nomePessoa}</strong>`;
            
            let conteudoHTML = '';
            
            // Cards principais
            conteudoHTML += `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="padding: 12px; border-radius: 8px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">${ehRecebimento ? 'üíµ Este M√™s' : 'üí∏ Este M√™s'}</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 22px;">R$ ${valorMesAtual.toFixed(2)}</div>
                    </div>
                    <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="padding: 12px; border-radius: 8px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">üí∞ Total Geral</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 22px;">R$ ${totalGeral.toFixed(2)}</div>
                    </div>
                </div>
            `;
            
            // Informa√ß√µes detalhadas
            conteudoHTML += `
                <div class="modal-valor-info ${ehRecebimento ? 'recebimento' : ''}" style="margin-bottom: 16px;">
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">‚úÖ J√° ${ehRecebimento ? 'Recebido' : 'Pago'}</span>
                        <span class="modal-valor-info-valor">R$ ${totalJaPago.toFixed(2)}</span>
                    </div>
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">‚è≥ Restante</span>
                        <span class="modal-valor-info-valor">R$ ${totalRestante.toFixed(2)}</span>
                    </div>
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">üìä Progresso</span>
                        <span class="modal-valor-info-valor">${percentualPago.toFixed(1)}%</span>
                    </div>
                    ${totalParcelas > 0 ? `
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">üî¢ Parcelas</span>
                        <span class="modal-valor-info-valor">${parcelasPagas}/${totalParcelas}</span>
                    </div>
                    ` : ''}
                </div>
            `;
            
            // Lista de compras detalhada
            conteudoHTML += `
                <div class="modal-detalhes-secao">
                    <div class="modal-detalhes-secao-titulo">${icone} Detalhamento das ${ehRecebimento ? 'Entradas' : 'Compras'}</div>
            `;
            
            comprasIndividuais.forEach((compra, idx) => {
                const nomeCompra = compra.nome || 'Sem nome';
                const dataCompra = compra.dataCompra || 'Data n√£o registrada';
                const valorTotal = compra.valorTotal || 0;
                const valorParcela = compra.valorParcela || 0;
                const parcelas = compra.parcelas || '';
                const observacoes = compra.observacoes || '';
                
                conteudoHTML += `
                    <div class="detalhes-compra-card ${ehRecebimento ? 'recebimento' : ''}" style="margin-bottom: 12px;">
                        <div class="detalhes-compra-nome">
                            <span>${idx + 1}. ${nomeCompra}</span>
                            ${parcelas ? `<span class="detalhes-compra-badge ${ehRecebimento ? 'recebimento' : ''}">${parcelas}</span>` : ''}
                        </div>
                        <div class="detalhes-compra-info">
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üìÖ Data</div>
                                <div>${dataCompra}</div>
                            </div>
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üí∞ Valor Total</div>
                                <div class="detalhes-compra-info-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${valorTotal.toFixed(2)}</div>
                            </div>
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üìä Por Parcela</div>
                                <div class="detalhes-compra-info-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${valorParcela.toFixed(2)}</div>
                            </div>
                            ${observacoes ? `
                            <div class="detalhes-compra-info-item" style="grid-column: 1 / -1;">
                                <div class="detalhes-compra-info-label">üìù Observa√ß√µes</div>
                                <div style="color: #666; font-size: 12px; white-space: pre-wrap; word-break: break-word;">${observacoes}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            conteudoHTML += `</div>`;
            
            // Status final
            if (totalRestante === 0) {
                conteudoHTML += `
                    <div class="modal-valor-destaque" style="margin-top: 16px;">
                        <div class="modal-valor-destaque-texto">
                            ‚úÖ <strong>Totalmente ${ehRecebimento ? 'Recebido' : 'Pago'}</strong><br>
                            N√£o h√° valores pendentes.
                        </div>
                    </div>
                `;
            } else {
                conteudoHTML += `
                    <div class="modal-valor-destaque alerta" style="margin-top: 16px;">
                        <div class="modal-valor-destaque-texto">
                            ‚è≥ <strong>Ainda Faltam R$ ${totalRestante.toFixed(2)}</strong><br>
                            ${percentualPago.toFixed(0)}% j√° foi ${ehRecebimento ? 'recebido' : 'pago'}.
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('modalResumoDetalhadoConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalResumoDetalhado').classList.add('ativo');
        }
        
        function mostrarResumoDetalhadoParceria(idBase, contaId) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            // Encontrar todas as pessoas dessa parceria
            const pessoasParceria = conta.pessoas.filter(p => {
                if (p.compras && p.compras.length > 0 && p.compras[0]._parceria) {
                    const compraIdBase = p.compras[0].idUnico.substring(0, p.compras[0].idUnico.lastIndexOf('_'));
                    return compraIdBase === idBase;
                }
                return false;
            });
            
            if (pessoasParceria.length === 0) return;
            
            const primeiraCompra = pessoasParceria[0].compras[0];
            const nomeCompra = primeiraCompra.nome;
            const ehRecebimento = conta.tipoTransacao === 'recebimento';
            const icone = ehRecebimento ? 'üí∞' : 'üõí';
            
            // Calcular todos os valores
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
            
            let totalJaPago = 0;
            let totalGeral = 0;
            let totalParcelas = 0;
            let parcelasPagas = 0;
            
            // *** CORRE√á√ÉO: Calcular total geral APENAS DAS COMPRAS DA PARCERIA ***
            pessoasParceria.forEach(pessoa => {
                if (pessoa.compras && pessoa.compras.length > 0) {
                    pessoa.compras.forEach(compra => {
                        // *** FILTRAR: S√≥ somar se for da parceria espec√≠fica ***
                        const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                        if (compraIdBase === idBase && compra._parceria) {
                            totalGeral += compra.valorTotal || 0;
                            
                            const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                            if (match) {
                                totalParcelas = Math.max(totalParcelas, parseInt(match[2]));
                            }
                        }
                    });
                }
            });
            
            // *** CORRE√á√ÉO PRINCIPAL: Calcular valores j√° pagos corretamente ***
            Object.keys(todasContas).forEach(chaveMes => {
                const [ano, mes] = chaveMes.split('-').map(Number);
                const dataMes = new Date(ano, mes - 1);
                
                const ehMesAtual = chaveMes === chaveAtual;
                
                // *** CORRIGIDO: Verificar cada m√™s (incluindo o atual) ***
                if (dataMes <= dataAtualMes) {
                    const contasMes = todasContas[chaveMes];
                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                    
                    if (contaEncontrada) {
                        // *** NOVA L√ìGICA: Verificar se PELO MENOS UMA pessoa da parceria pagou ***
                        let algumaPessoaPagou = false;
                        let valorDaParcelaNesteMes = 0;
                        
                        // Primeiro: verificar se h√° algum pagamento neste m√™s
                        contaEncontrada.pessoas.forEach(p => {
                            if (p.pago && p.compras && p.compras.length > 0) {
                                p.compras.forEach(compra => {
                                    // *** FILTRAR: S√≥ contar se for da parceria espec√≠fica ***
                                    if (compra._parceria) {
                                        const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                                        
                                        if (compraIdBase === idBase) {
                                            algumaPessoaPagou = true;
                                        }
                                    }
                                });
                            }
                        });
                        
                        // Se pelo menos uma pessoa pagou, somar o valor TOTAL da parcela daquele m√™s
                        if (algumaPessoaPagou) {
                            contaEncontrada.pessoas.forEach(p => {
                                if (p.compras && p.compras.length > 0) {
                                    p.compras.forEach(compra => {
                                        if (compra._parceria) {
                                            const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                                            
                                            if (compraIdBase === idBase) {
                                                valorDaParcelaNesteMes += compra.valorParcela;
                                            }
                                        }
                                    });
                                }
                            });
                            
                            totalJaPago += valorDaParcelaNesteMes;
                            parcelasPagas++;
                        }
                    }
                }
            });
            
            const totalRestante = totalGeral - totalJaPago;
            const percentualPago = totalGeral > 0 ? (totalJaPago / totalGeral) * 100 : 0;
            const valorMesAtual = pessoasParceria.reduce((sum, p) => {
                // *** CORRE√á√ÉO: Somar APENAS o valor da compra da parceria espec√≠fica ***
                if (p.compras && p.compras.length > 0) {
                    p.compras.forEach(compra => {
                        const compraIdBase = compra.idUnico.substring(0, compra.idUnico.lastIndexOf('_'));
                        if (compraIdBase === idBase && compra._parceria) {
                            sum += compra.valorParcela;
                        }
                    });
                }
                return sum;
            }, 0);
            
            // Montar o modal
            const tipoIcone = conta.tipo === 'cartao' ? 'üí≥' : conta.tipo === 'boleto' ? 'üßæ' : conta.tipo === 'dinheiro' ? 'üíµ' : conta.tipo === 'pix' ? '‚ùñ' : 'ü™ô';
            const tipoNome = conta.tipo === 'cartao' ? 'Cart√£o de Cr√©dito' : conta.tipo === 'boleto' ? 'Boleto/Conta' : conta.tipo === 'dinheiro' ? 'Dinheiro' : conta.tipo === 'pix' ? 'PIX' : 'Outro';
            document.getElementById('modalResumoDetalhadoTitulo').innerHTML = `<div style="display: grid; grid-template-columns: 1fr auto; margin-top: -10px; align-items: start; padding-right: 0px; width: 100%;"><div><div style="font-size: 22px; font-weight: bold; color: #667eea; margin-bottom: 8px;">${conta.nome}</div></div><div style="font-size: 13px; color: #666; font-weight: 600; background: #f0f0f0; padding: 6px 6px; border-radius: 8px; white-space: nowrap;">${tipoIcone} ${tipoNome}</div></div>`;
            document.getElementById('modalResumoDetalhadoSubtitulo').innerHTML = `<strong>${icone} Resumo Completo - üë• ${nomeCompra} (Parceria)</strong>`;
            
            let conteudoHTML = '';
            
            // Cards principais
            conteudoHTML += `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="padding: 12px; border-radius: 8px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">${ehRecebimento ? 'üíµ Este M√™s' : 'üí∏ Este M√™s'}</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 22px;">R$ ${valorMesAtual.toFixed(2)}</div>
                    </div>
                    <div class="modal-detalhes-resumo ${ehRecebimento ? 'recebimento' : ''}" style="padding: 12px; border-radius: 8px;">
                        <div class="modal-detalhes-resumo-label" style="font-size: 11px;">üí∞ Total Geral</div>
                        <div class="modal-detalhes-resumo-valor" style="font-size: 22px;">R$ ${totalGeral.toFixed(2)}</div>
                    </div>
                </div>
            `;
            
            // Informa√ß√µes detalhadas
            conteudoHTML += `
                <div class="modal-valor-info ${ehRecebimento ? 'recebimento' : ''}" style="margin-bottom: 16px;">
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">‚úÖ J√° ${ehRecebimento ? 'Recebido' : 'Pago'}</span>
                        <span class="modal-valor-info-valor">R$ ${totalJaPago.toFixed(2)}</span>
                    </div>
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">‚è≥ Restante</span>
                        <span class="modal-valor-info-valor">R$ ${totalRestante.toFixed(2)}</span>
                    </div>
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">üìä Progresso</span>
                        <span class="modal-valor-info-valor">${percentualPago.toFixed(1)}%</span>
                    </div>
                    ${totalParcelas > 0 ? `
                    <div class="modal-valor-info-row">
                        <span class="modal-valor-info-label">üî¢ Parcelas</span>
                        <span class="modal-valor-info-valor">${parcelasPagas}/${totalParcelas}</span>
                    </div>
                    ` : ''}
                </div>
            `;
            
            // Lista detalhada das pessoas
            conteudoHTML += `
                <div class="modal-detalhes-secao">
                    <div class="modal-detalhes-secao-titulo">üë• Detalhamento por Pessoa</div>
            `;
            
            pessoasParceria.forEach((pessoa, idx) => {
                const nomePessoa = pessoa.nome === 'Eu' && ehRecebimento ? 'Devedor' : pessoa.nome;
                const compra = pessoa.compras[0];
                
                conteudoHTML += `
                    <div class="detalhes-compra-card ${ehRecebimento ? 'recebimento' : ''}" style="margin-bottom: 12px;">
                        <div class="detalhes-compra-nome">
                            <span>${idx + 1}. ${nomePessoa}</span>
                            ${compra.parcelas ? `<span class="detalhes-compra-badge ${ehRecebimento ? 'recebimento' : ''}">${compra.parcelas}</span>` : ''}
                        </div>
                        <div class="detalhes-compra-info">
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üìÖ Data</div>
                                <div>${compra.dataCompra}</div>
                            </div>
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üí∞ Valor Total</div>
                                <div class="detalhes-compra-info-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${compra.valorTotal.toFixed(2)}</div>
                            </div>
                            <div class="detalhes-compra-info-item">
                                <div class="detalhes-compra-info-label">üìä Por Parcela</div>
                                <div class="detalhes-compra-info-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${compra.valorParcela.toFixed(2)}</div>
                            </div>
                            ${compra.observacoes ? `
                            <div class="detalhes-compra-info-item" style="grid-column: 1 / -1;">
                                <div class="detalhes-compra-info-label">üìù Observa√ß√µes</div>
                                <div style="color: #666; font-size: 12px; white-space: pre-wrap; word-break: break-word;">${compra.observacoes}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            conteudoHTML += `</div>`;
            
            // Status final
            if (totalRestante === 0) {
                conteudoHTML += `
                    <div class="modal-valor-destaque" style="margin-top: 16px;">
                        <div class="modal-valor-destaque-texto">
                            ‚úÖ <strong>Totalmente ${ehRecebimento ? 'Recebido' : 'Pago'}</strong><br>
                            N√£o h√° valores pendentes para esta parceria.
                        </div>
                    </div>
                `;
            } else {
                conteudoHTML += `
                    <div class="modal-valor-destaque alerta" style="margin-top: 16px;">
                        <div class="modal-valor-destaque-texto">
                            ‚è≥ <strong>Ainda Faltam R$ ${totalRestante.toFixed(2)}</strong><br>
                            ${percentualPago.toFixed(0)}% da parceria j√° foi ${ehRecebimento ? 'recebido' : 'pago'}.
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('modalResumoDetalhadoConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalResumoDetalhado').classList.add('ativo');
        }

function mostrarDetalhesValor(contaId) {
            const conta = contas.find(c => c.id === contaId);
            if (!conta) return;
            
            const totalMensal = calcularTotal(conta);
            const ehRecebimento = conta.tipoTransacao === 'recebimento';
            
            let totalCompleto = 0;
            let totalJaPago = 0;
            
            const chaveAtual = getChaveMes();
            const [anoAtual, mesAtualNum] = chaveAtual.split('-').map(Number);
            
            conta.pessoas.forEach(pessoa => {
                if (pessoa.compras && pessoa.compras.length > 0) {
                    pessoa.compras.forEach(compra => {
                        const match = compra.parcelas ? compra.parcelas.match(/(\d+)\/(\d+)/) : null;
                        
                        if (match) {
                            const parcelaAtual = parseInt(match[1]);
                            const totalParcelas = parseInt(match[2]);
                            
                            totalCompleto += compra.valorTotal;
                            
                            Object.keys(todasContas).forEach(chaveMes => {
                                const [ano, mes] = chaveMes.split('-').map(Number);
                                const dataMes = new Date(ano, mes - 1);
                                const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
                                
                                if (dataMes < dataAtualMes) {
                                    const contasMes = todasContas[chaveMes];
                                    const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                                    
                                    if (contaEncontrada) {
                                        contaEncontrada.pessoas.forEach(p => {
                                            if (p.compras && p.pago) {
                                                p.compras.forEach(c => {
                                                    if (c.idUnico === compra.idUnico || 
                                                        (c.nome === compra.nome && c.valorTotal === compra.valorTotal)) {
                                                        totalJaPago += c.valorParcela;
                                                    }
                                                });
                                            }
                                        });
                                    }
                                }
                            });
                            
                            if (pessoa.pago) {
                                totalJaPago += compra.valorParcela;
                            }
                            
                        } else if (compra.parcelas === 'recorrente') {
                            totalCompleto += compra.valorTotal;
                            if (pessoa.pago) {
                                totalJaPago += compra.valorParcela;
                            }
                        } else {
                            totalCompleto += compra.valorTotal;
                            if (pessoa.pago) {
                                totalJaPago += compra.valorTotal;
                            }
                        }
                    });
                } else {
                    const match = pessoa.parcelas ? pessoa.parcelas.match(/(\d+)\/(\d+)/) : null;
                    
                    if (match) {
                        const parcelaAtual = parseInt(match[1]);
                        const totalParcelas = parseInt(match[2]);
                        
                        totalCompleto += pessoa.valorTotal || (pessoa.valor * totalParcelas);
                        
                        Object.keys(todasContas).forEach(chaveMes => {
                            const [ano, mes] = chaveMes.split('-').map(Number);
                            const dataMes = new Date(ano, mes - 1);
                            const dataAtualMes = new Date(anoAtual, mesAtualNum - 1);
                            
                            if (dataMes < dataAtualMes) {
                                const contasMes = todasContas[chaveMes];
                                const contaEncontrada = contasMes.find(c => c.nome === conta.nome);
                                
                                if (contaEncontrada) {
                                    contaEncontrada.pessoas.forEach(p => {
                                        if (p.nome === pessoa.nome && p.pago) {
                                            totalJaPago += p.valor;
                                        }
                                    });
                                }
                            }
                        });
                        
                        if (pessoa.pago) {
                            totalJaPago += pessoa.valor;
                        }
                        
                    } else if (pessoa.parcelas === 'recorrente') {
                        totalCompleto += pessoa.valor;
                        if (pessoa.pago) {
                            totalJaPago += pessoa.valor;
                        }
                    } else {
                        totalCompleto += pessoa.valor;
                        if (pessoa.pago) {
                            totalJaPago += pessoa.valor;
                        }
                    }
                }
            });
            
            const totalRestante = totalCompleto - totalJaPago;
            const percentualPago = totalCompleto > 0 ? (totalJaPago / totalCompleto) * 100 : 0;
            
            // Montar o modal
            const icone = ehRecebimento ? 'üí∞' : 'üí≥';
            const tipoIcone = conta.tipo === 'cartao' ? 'üí≥' : conta.tipo === 'boleto' ? 'üßæ' : conta.tipo === 'dinheiro' ? 'üíµ' : conta.tipo === 'pix' ? '‚ùñ' : 'ü™ô';
            const tipoNome = conta.tipo === 'cartao' ? 'Cart√£o de Cr√©dito' : conta.tipo === 'boleto' ? 'Boleto/Conta' : conta.tipo === 'dinheiro' ? 'Dinheiro' : conta.tipo === 'pix' ? 'PIX' : 'Outro';
            document.getElementById('modalValorTitulo').innerHTML = `<div style="display: grid; grid-template-columns: 1fr auto; margin-top: -10px; align-items: start; padding-right: 0px; width: 100%;"><div><div style="font-size: 22px; font-weight: bold; color: #667eea; margin-bottom: 8px;">${conta.nome}</div></div><div style="font-size: 13px; color: #666; font-weight: 600; background: #f0f0f0; padding: 6px 6px; border-radius: 8px; white-space: nowrap;">${tipoIcone} ${tipoNome}</div></div>`;
            document.getElementById('modalValorSubtitulo').textContent = `${icone} Detalhamento financeiro completo`;
            
            let conteudoHTML = '';
            
            // Card do valor mensal
            conteudoHTML += `
                <div class="modal-valor-card ${ehRecebimento ? 'recebimento' : ''}">
                    <div class="modal-valor-card-label">${ehRecebimento ? 'üíµ Valor a Receber Este M√™s' : 'üí∏ Valor a Pagar Este M√™s'}</div>
                    <div class="modal-valor-card-valor ${ehRecebimento ? 'recebimento' : ''}">R$ ${totalMensal.toFixed(2)}</div>
                </div>
            `;
            
            // Informa√ß√µes detalhadas
            if (totalMensal !== totalCompleto) {
                conteudoHTML += `
                    <div class="modal-valor-info ${ehRecebimento ? 'recebimento' : ''}">
                        <div class="modal-valor-info-row">
                            <span class="modal-valor-info-label">üí∞ Valor Total (todas parcelas)</span>
                            <span class="modal-valor-info-valor">R$ ${totalCompleto.toFixed(2)}</span>
                        </div>
                        <div class="modal-valor-info-row">
                            <span class="modal-valor-info-label">‚úÖ J√° ${ehRecebimento ? 'Recebido' : 'Pago'}</span>
                            <span class="modal-valor-info-valor">R$ ${totalJaPago.toFixed(2)}</span>
                        </div>
                        <div class="modal-valor-info-row">
                            <span class="modal-valor-info-label">‚è≥ Restante</span>
                            <span class="modal-valor-info-valor">R$ ${totalRestante.toFixed(2)}</span>
                        </div>
                        <div class="modal-valor-info-row">
                            <span class="modal-valor-info-label">üìä Progresso</span>
                            <span class="modal-valor-info-valor">${percentualPago.toFixed(1)}%</span>
                        </div>
                    </div>
                `;
            }
            
            // Mensagem de status
            if (totalMensal === totalCompleto && totalRestante === 0) {
                conteudoHTML += `
                    <div class="modal-valor-destaque">
                        <div class="modal-valor-destaque-texto">
                            ‚úÖ <strong>Pagamento √önico ou Parcela Final</strong><br>
                            Esta conta foi totalmente ${ehRecebimento ? 'recebida' : 'paga'}. N√£o h√° valores pendentes.
                        </div>
                    </div>
                `;
            } else if (totalMensal === totalCompleto && totalRestante > 0) {
                conteudoHTML += `
                    <div class="modal-valor-destaque alerta">
                        <div class="modal-valor-destaque-texto">
                            ‚ö†Ô∏è <strong>Pagamento √önico ou Parcela Final</strong><br>
                            Este √© o valor total a ${ehRecebimento ? 'receber' : 'pagar'} neste m√™s.
                        </div>
                    </div>
                `;
            } else {
                conteudoHTML += `
                    <div class="modal-valor-destaque">
                        <div class="modal-valor-destaque-texto">
                            üí° <strong>Pagamento Parcelado em Andamento</strong><br>
                            Voc√™ j√° ${ehRecebimento ? 'recebeu' : 'pagou'} R$ ${totalJaPago.toFixed(2)} de um total de R$ ${totalCompleto.toFixed(2)}. 
                            Faltam R$ ${totalRestante.toFixed(2)} para finalizar.
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('modalValorConteudo').innerHTML = conteudoHTML;
            document.getElementById('modalValor').classList.add('ativo');
        }
        function renderizarContas() {
            const lista = document.getElementById('listaContas');
            adicionarLog(`üé® renderizarContas() - Total de contas: ${contas.length}`, 'info');
            contas.forEach(c => {
                adicionarLog(`   ${c.nome}: ${c.pessoas.length} pessoas`, 'info');
            });
            
            adicionarLog(`üé® renderizarContas() - Total de contas: ${contas.length}`, 'info');
            contas.forEach(c => {
                adicionarLog(`   ${c.nome}: ${c.pessoas.length} pessoas`, 'info');
            });
            
            // *** NOVO: Filtrar contas de recebimento sem pessoas e totalmente quitadas ***
            const contasVisiveis = contas.filter(conta => {
                // Se tem pessoas, sempre mostrar
                if (conta.pessoas && conta.pessoas.length > 0) return true;
                
                // Se n√£o tem pessoas, verificar se √© recebimento ou pagamento-custom
                if (conta.tipoTransacao === 'recebimento' || conta.tipoTransacao === 'pagamento-custom') {
                    // Verificar se tem pend√™ncias
                    const statusConta = verificarContaFinalizada(conta);
                    
                    // S√≥ mostrar se tiver pend√™ncias
                    return statusConta.temPendencias;
                }
                
                // *** CORRE√á√ÉO: Pagamentos normais SEMPRE mostram (mesmo sem pessoas) ***
                return true;
            });
            
            if (contasVisiveis.length === 0) {
                lista.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">Nenhuma conta cadastrada. Clique em "Adicionar Conta" para come√ßar.</p>';
                document.getElementById('totalValor').textContent = 'R$ 0,00';
                return;
            }
            
            lista.innerHTML = contasVisiveis.map((conta, index) => {
                // CORRE√á√ÉO: Usar calcularTotal que j√° considera valores alterados
                const total = conta.pessoas.reduce((sum, p) => {
                    const valorConsiderar = p._valorPagoReal !== undefined ? p._valorPagoReal : p.valor;
                    return sum + valorConsiderar;
                }, 0);
                if (conta.pessoas.some(p => p._valorPagoReal !== undefined)) {
                    adicionarLog(`   üí∞ Conta "${conta.nome}" tem valores alterados`, 'warning');
                    conta.pessoas.forEach(p => {
                        if (p._valorPagoReal !== undefined) {
                            adicionarLog(`      ${p.nome}: Normal R$ ${p.valor.toFixed(2)} ‚Üí Pago R$ ${p._valorPagoReal.toFixed(2)}`, 'info');
                        }
                    });
                }
                const limiteDisp = calcularLimiteDisponivel(conta);
                const ehPrimeiro = index === 0;
                const ehUltimo = index === contas.length - 1;
                
                // *** NOVO: Verificar se conta finalizou ***
                const statusConta = verificarContaFinalizada(conta);
                const contaFinalizadaComPendencias = statusConta.finalizada && statusConta.temPendencias && conta.pessoas.length === 0;
                const qtdPendencias = contaFinalizadaComPendencias ? verificarPendenciasConta(conta.nome).length : 0;
                
                return `
                    <div class="conta-wrapper">
                        <div class="conta-setas">
                            <button class="btn-seta" onclick="moverContaCima(${conta.id})" ${ehPrimeiro ? 'disabled' : ''} title="Mover para cima">‚ñ≤</button>
                            <button class="btn-seta" onclick="moverContaBaixo(${conta.id})" ${ehUltimo ? 'disabled' : ''} title="Mover para baixo">‚ñº</button>
                        </div>
                        <div class="conta-conteudo">
                            <div class="conta ${conta.pago ? 'pago' : ''} ${conta.tipoTransacao === 'recebimento' ? 'recebimento' : ''}" data-conta-id="${conta.id}">
                        <div class="conta-header">
                            <div>
                                <span class="conta-nome">${conta.tipoTransacao === 'recebimento' ? 'üí∞' : 'üè¶'} ${conta.nome}</span>
                                ${contaFinalizadaComPendencias ? '<span class="status-badge" style="background: #dc3545; color: white;">‚ö†Ô∏è FINALIZADA</span>' : (conta.pessoas && conta.pessoas.length > 0 ? (conta.pago ? '<span class="status-badge badge-pago">‚úÖ PAGO</span>' : '<span class="status-badge badge-pendente">‚è≥ Pendente</span>') : '')}
                            </div>
                            ${!contaFinalizadaComPendencias ? `<span class="conta-valor" style="cursor: pointer; white-space: nowrap;" onclick="mostrarDetalhesValor(${conta.id})" title="Clique para ver detalhes">R$ ${total.toFixed(2)}</span>` : ''}
                        </div>
                        
                        ${contaFinalizadaComPendencias ? `
                            <div style="margin: 10px 0; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 6px;">
                                <div style="color: #856404; font-size: 13px; font-weight: bold; margin-bottom: 6px;">‚ö†Ô∏è Conta Finalizada com Pend√™ncias</div>
                                <div style="color: #666; font-size: 12px;">Todas as parcelas terminaram, mas h√° <strong style="color: #dc3545;">${qtdPendencias} ${qtdPendencias === 1 ? 'pagamento pendente' : 'pagamentos pendentes'}</strong> em meses anteriores.</div>
                            </div>
                        ` : (conta.pessoas && conta.pessoas.length > 0 ? `
                            <div style="margin: 10px 0;">
                                ${(() => {
                                    // Agrupar compras em parceria E separar compras individuais
                                    const comprasParceria = new Map();
                                    const pessoasIndividuais = [];
                                    const indicesJaProcessados = new Set(); // NOVO: rastrear √≠ndices processados
                                    
                                    conta.pessoas.forEach((p, i) => {
                                        // *** SEPARAR compras em parceria das individuais ***
                                        const comprasEmParceria = [];
                                        const comprasIndividuais = [];
                                        
                                        if (p.compras && p.compras.length > 0) {
                                            p.compras.forEach(compra => {
                                                if (compra._parceria) {
                                                    comprasEmParceria.push(compra);
                                                } else {
                                                    comprasIndividuais.push(compra);
                                                }
                                            });
                                        }
                                        
                                        // *** IMPORTANTE: Se pessoa tem APENAS compras em parceria, n√£o adicionar como individual ***
                                        const apenasCompraParceria = comprasEmParceria.length > 0 && comprasIndividuais.length === 0;
                                        
                                        // Processar compras em parceria
                                        if (comprasEmParceria.length > 0) {
                                            comprasEmParceria.forEach(compraParceria => {
                                                const idBaseParceria = compraParceria.idUnico.substring(0, compraParceria.idUnico.lastIndexOf('_'));
                                                
                                                if (!comprasParceria.has(idBaseParceria)) {
                                                    comprasParceria.set(idBaseParceria, {
                                                        nome: compraParceria.nome,
                                                        pessoas: [],
                                                        valorTotal: 0,
                                                        todospagos: true
                                                    });
                                                }
                                                
                                                const grupo = comprasParceria.get(idBaseParceria);
                                                grupo.pessoas.push({ pessoa: p, indice: i });
                                                grupo.valorTotal += compraParceria.valorParcela;
                                                if (!p.pago) grupo.todospagos = false;
                                            });
                                            
                                            // MARCAR que este √≠ndice tem parceria
                                            indicesJaProcessados.add(i);
                                        }
                                        
                                        // *** CORRE√á√ÉO: S√≥ adicionar como individual se tiver compras n√£o-parceria OU n√£o tiver compras detalhadas ***
                                        if (comprasIndividuais.length > 0) {
                                            // Criar c√≥pia da pessoa apenas com compras individuais
                                            const pessoaIndividual = {
                                                ...p,
                                                compras: comprasIndividuais,
                                                valor: comprasIndividuais.reduce((sum, c) => sum + (c.valorParcela || 0), 0),
                                                // Marcar que √© apenas individual (sem parceria)
                                                _apenasIndividual: true
                                            };
                                            pessoasIndividuais.push({ pessoa: pessoaIndividual, indice: i });
                                        } else if (!indicesJaProcessados.has(i) && !apenasCompraParceria) {
                                            // Se n√£o tem compras em parceria E n√£o tem compras individuais,
                                            // adicionar normalmente (caso de pessoas sem compras detalhadas)
                                            pessoasIndividuais.push({ pessoa: p, indice: i });
                                        }
                                        // *** Se tem APENAS compra em parceria, N√ÉO adicionar como individual ***
                                    });
                                    
                                    let html = '';
                                    
                                    // Renderizar compras em parceria
                                    comprasParceria.forEach((grupo, idBase) => {
                                        html += `
                                            <div class="pessoa ${grupo.todospagos ? 'pago' : ''}" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                                                <span onclick="abrirModalMarcarParceria('${idBase.replace(/'/g, "\\'")}', ${conta.id})" style="flex: 1; user-select: none;">
                                                    ${grupo.nome} (P. üë•): R$ ${grupo.valorTotal.toFixed(2)} ${grupo.todospagos ? '‚úì' : ''}
                                                </span>
                                                <span onclick="mostrarDetalhesParceria('${idBase.replace(/'/g, "\\'")}', ${conta.id})" style="color: #667eea; font-size: 11px; margin-left: 8px; white-space: nowrap;" title="Ver detalhes">‚ÑπÔ∏è detalhes</span>
                                            </div>
                                        `;
                                    });
                                    
                                    // Renderizar pessoas individuais
                                    pessoasIndividuais.sort((a, b) => 
                                        a.pessoa.nome === 'Eu' ? -1 : b.pessoa.nome === 'Eu' ? 1 : 0
                                    ).forEach(({ pessoa: p, indice: i }) => {
                                        let nomePessoa = p.nome;
                                        if (p.nome === 'Eu' && conta.tipoTransacao === 'recebimento') {
                                            nomePessoa = 'Devedor';
                                        }
                                        const temCompras = p.compras && p.compras.length > 0;
                                        
                                        // *** CORRE√á√ÉO: Calcular valor correto excluindo compras em parceria ***
                                        let valorReal = 0;
                                        if (p.compras && p.compras.length > 0) {
                                            p.compras.forEach(compra => {
                                                // S√≥ somar se N√ÉO for parceria (parceria j√° foi agrupada)
                                                if (!compra._parceria) {
                                                    valorReal += compra.valorParcela;
                                                }
                                            });
                                        } else {
                                            valorReal = p.valor;
                                        }
                                        
                                        const valorMostrar = p._valorPagoReal !== undefined ? p._valorPagoReal : valorReal;
                                        const temValorAlterado = p._valorPagoReal !== undefined && p._valorPagoReal !== p.valor;
                                        
                                        html += `
                                            <div class="pessoa ${p.pago ? 'pago' : ''}" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;" data-pessoa-index="${i}">
                                                <span 
                                                    onclick="${(conta.tipoTransacao === 'recebimento' || conta.tipoTransacao === 'pagamento-custom') && !p.pago ? (conta.tipoTransacao === 'recebimento' ? `abrirModalPagamentoRecebimento(${conta.id}, ${i})` : `abrirModalPagamentoCustom(${conta.id}, ${i})`) : `togglePagoPessoa(${conta.id}, ${i})`}" 
                                                    ontouchstart="iniciarLongPress(${conta.id}, ${i}, event)"
                                                    ontouchend="cancelarLongPress()"
                                                    ontouchmove="cancelarLongPress()"
                                                    style="flex: 1; user-select: none;">
                                                    ${nomePessoa}: R$ ${valorMostrar.toFixed(2)} ${temValorAlterado ? 'üí∞' : ''} ${p.pago ? '‚úì' : ''}
                                                </span>
                                                ${temCompras ? `<span onclick="mostrarDetalhesPessoa(${conta.id}, ${i})" style="color: #667eea; font-size: 11px; margin-left: 8px; white-space: nowrap;" title="Ver detalhes">‚ÑπÔ∏è detalhes</span>` : ''}
                                            </div>
                                        `;
                                    });
                                    
                                    return html;
                                })()}
                            </div>
                        ` : '<p style="color: #999; font-size: 12px; margin: 10px 0; text-align: center;">Nenhum item cadastrado ainda</p>')}
                        
                        ${conta.tipo === 'cartao' && !contaFinalizadaComPendencias ? `
                            <div class="info-conta">
                                ${conta.diaFechamento ? `‚óâ Fecha: ${conta.diaFechamento}` : ''} 
                                ${conta.diaVencimento ? `/ ‚óâ Venc: ${conta.diaVencimento}` : ''}
                                ${conta.limiteTotal ? `<br>‚óâ <span class="limite">(Limite dispon√≠vel: ${limiteDisp.toLocaleString('pt-BR', {minimumFractionDigits: 2})})</span>` : ''}
                            </div>
                        ` : ''}
                        
                        <div class="acoes" style="${conta.pessoas && conta.pessoas.length > 0 || contaFinalizadaComPendencias ? '' : 'justify-content: center;'}">
                            ${!contaFinalizadaComPendencias && conta.pessoas && conta.pessoas.length > 0 ? `
                            <button class="btn-pequeno btn-pagar" onclick="togglePagoConta(${conta.id})">
                                ${conta.pago ? '‚Ü©Ô∏è Desfazer' : '‚úÖ Marcar Pago'}
                            </button>
                            ` : ''}
                            ${conta.pessoas && conta.pessoas.length > 0 || contaFinalizadaComPendencias ? `
                            <button class="btn-pequeno" onclick="mostrarPendenciasConta('${conta.nome.replace(/'/g, "\\'")}')" style="background: ${verificarPendenciasConta(conta.nome).length > 0 ? '#dc3545' : '#6c757d'}; color: white;">
                                üìã Pend√™ncias ${verificarPendenciasConta(conta.nome).length > 0 ? `(${verificarPendenciasConta(conta.nome).length})` : ''}
                            </button>
                            ` : ''}
                            <button class="btn-pequeno btn-editar" onclick='abrirModal(${JSON.stringify(conta).replace(/'/g, "&apos;")})'>‚úèÔ∏è Editar</button>
                            <button class="btn-pequeno btn-excluir" onclick="excluirConta(${conta.id})">üóëÔ∏è Excluir</button>
                        </div>
                    </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Calcular total de pagamentos (excluindo recebimentos) usando valores alterados
            const totalPagamentos = contasVisiveis
                .filter(c => c.tipoTransacao !== 'recebimento')
                .reduce((sum, c) => {
                    return sum + c.pessoas.reduce((pSum, p) => {
                        const valorConsiderar = p._valorPagoReal !== undefined ? p._valorPagoReal : p.valor;
                        return pSum + valorConsiderar;
                    }, 0);
                }, 0);
            
            document.getElementById('totalValor').textContent = `R$ ${totalPagamentos.toFixed(2)}`;
        }
        
        function moverContaCima(contaId) {
            const index = contas.findIndex(c => c.id === contaId);
            
            if (index <= 0) {
                return; // J√° est√° no topo
            }
            
            const nomeConta1 = contas[index].nome;
            const nomeConta2 = contas[index - 1].nome;
            
            // Trocar no m√™s atual
            [contas[index - 1], contas[index]] = [contas[index], contas[index - 1]];
            
            // Aplicar mesma ordem em TODOS os meses
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const idx1 = contasMes.findIndex(c => c.nome === nomeConta1);
                const idx2 = contasMes.findIndex(c => c.nome === nomeConta2);
                
                if (idx1 !== -1 && idx2 !== -1) {
                    [contasMes[idx2], contasMes[idx1]] = [contasMes[idx1], contasMes[idx2]];
                }
            });
            
            adicionarLog(`‚¨ÜÔ∏è Conta movida para cima em TODOS os meses`, 'success');
            salvarNoStorage();
            renderizarContas();
        }
        
        function moverContaBaixo(contaId) {
            const index = contas.findIndex(c => c.id === contaId);
            
            if (index < 0 || index >= contas.length - 1) {
                return; // J√° est√° no final
            }
            
            const nomeConta1 = contas[index].nome;
            const nomeConta2 = contas[index + 1].nome;
            
            // Trocar no m√™s atual
            [contas[index], contas[index + 1]] = [contas[index + 1], contas[index]];
            
            // Aplicar mesma ordem em TODOS os meses
            Object.keys(todasContas).forEach(chaveMes => {
                const contasMes = todasContas[chaveMes];
                const idx1 = contasMes.findIndex(c => c.nome === nomeConta1);
                const idx2 = contasMes.findIndex(c => c.nome === nomeConta2);
                
                if (idx1 !== -1 && idx2 !== -1) {
                    [contasMes[idx1], contasMes[idx2]] = [contasMes[idx2], contasMes[idx1]];
                }
            });
            
            adicionarLog(`‚¨áÔ∏è Conta movida para baixo em TODOS os meses`, 'success');
            salvarNoStorage();
            renderizarContas();
        }

        inicializar();
        
        // Prevenir sa√≠da acidental ao recarregar ou fechar
        window.addEventListener('beforeunload', function (e) {
            if (contas.length > 0) {
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        });
        
        // Prevenir uso do bot√£o voltar
        history.pushState(null, null, location.href);
        window.addEventListener('popstate', function () {
            if (contas.length > 0) {
                if (confirm('‚ö†Ô∏è ATEN√á√ÉO!\n\nVoc√™ tem contas cadastradas. Deseja realmente sair?\n\nTodos os dados n√£o salvos ser√£o perdidos!')) {
                    history.back();
                } else {
                    history.pushState(null, null, location.href);
                }
            }
        });
        
        // ===== PREVENIR SUBMIT COM ENTER NO TEXTAREA =====
        document.addEventListener('DOMContentLoaded', function() {
            document.addEventListener('keydown', function(e) {
                // Se o elemento focado √© um textarea e a tecla pressionada √© Enter
                if (e.target.tagName === 'TEXTAREA' && e.key === 'Enter') {
                    // N√£o fazer nada, deixar o Enter funcionar normalmente no textarea
                    return;
                }
            });
            
            // Prevenir submit do formul√°rio ao pressionar Enter em qualquer campo
            const forms = document.querySelectorAll('form');
            forms.forEach(form => {
                form.addEventListener('keydown', function(e) {
                    // Se a tecla √© Enter E n√£o √© um textarea
                    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        return false;
                    }
                });
            });
        });
        
        // ===== PWA: REGISTRAR SERVICE WORKER =====
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('‚úÖ Service Worker registrado:', reg.scope))
                    .catch(err => console.error('‚ùå Erro ao registrar SW:', err));
            });
        }
        
        // ===== PWA: PROMPT DE INSTALA√á√ÉO =====
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('üì± PWA instal√°vel detectado');
            
            // Opcional: Mostrar bot√£o de instala√ß√£o personalizado
            // (Voc√™ pode adicionar um bot√£o no HTML se desejar)
        });
    </script>
</body>
</html>
